## API Report File for "@atlaskit/media-client".

> Do not edit this file. This report is auto-generated by [API Extractor](https://api-extractor.com/).

[Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

```ts
import { AsapBasedAuth } from '@atlaskit/media-core';
import { Auth } from '@atlaskit/media-core';
import { AuthContext } from '@atlaskit/media-core';
import { AuthProvider } from '@atlaskit/media-core';
import { ChunkinatorFile } from '@atlaskit/chunkinator';
import { ClientAltBasedAuth } from '@atlaskit/media-core';
import { FileStatus as FileStatus_2 } from '@atlaskit/media-common';
import { MediaApiConfig } from '@atlaskit/media-core';
import { MediaClientConfig } from '@atlaskit/media-core';
import { MediaFeatureFlags } from '@atlaskit/media-common';
import { MediaType } from '@atlaskit/media-common';
import { default as React_2 } from 'react';
import { ReplaySubject } from 'rxjs/ReplaySubject';

export declare type AbortFunction = () => void;

export declare const addFileAttrsToUrl: (
  url: string,
  fileAttrs: MediaBlobUrlAttrs,
) => string;

export declare type AppendChunksToUploadRequestBody = {
  readonly chunks: string[];
  readonly hash?: string;
  readonly offset?: number;
};

export declare type Artifacts = {
  [name: string]: MediaArtifact;
};

/**
 * Base class for media errors
 */
declare abstract class BaseMediaClientError<
    Attributes extends MediaClientErrorAttributes
  >
  extends Error
  implements MediaClientError<Attributes> {
  readonly message: string;
  constructor(message: string);
  abstract get attributes(): Attributes;
}

export declare const checkWebpSupport: () => Promise<boolean>;

export declare type ClientOptions = {
  readonly retryOptions?: Partial<RetryOptions>;
  readonly clientTimeout?: number;
};

export declare class CollectionFetcher {
  readonly mediaStore: MediaStore;
  constructor(mediaStore: MediaStore);
  private createFileStateObserver;
  private populateCache;
  private removeFromCache;
  getItems(
    collectionName: string,
    params?: MediaStoreGetCollectionItemsParams,
  ): MediaSubscribable<MediaCollectionItem[]>;
  removeFile(
    id: string,
    collectionName: string,
    occurrenceKey?: string,
  ): Promise<void>;
  loadNextPage(
    collectionName: string,
    params?: MediaStoreGetCollectionItemsParams,
  ): Promise<void>;
}

declare type CompletionObserver<T> = PartialObserver<T> &
  Required<Pick<PartialObserver<T>, 'complete'>>;

export declare interface CopyDestination
  extends MediaStoreCopyFileWithTokenParams {
  authProvider: AuthProvider;
  mediaStore?: MediaStore;
}

export declare interface CopyFileOptions {
  preview?: FilePreview | Promise<FilePreview>;
  mimeType?: string;
}

export declare interface CopySourceFile {
  id: string;
  collection?: string;
  authProvider: AuthProvider;
}

export declare interface CreatedTouchedFile {
  fileId: string;
  uploadId: string;
}

export declare function createMediaSubject<T extends MediaSubscribableItem>(
  initialState?: T | Error,
): ReplaySubject<T>;

export declare function createMediaSubscribable<
  T extends MediaSubscribableItem
>(mediaSubscribableItem?: T | Error): MediaSubscribable<T>;

export declare function createUrl(
  url: string,
  { params, auth }: CreateUrlOptions,
): string;

export declare type CreateUrlOptions = {
  readonly params?: RequestParams;
  readonly auth?: Auth;
};

export declare type Dimensions = {
  width: number;
  height: number;
};

export declare interface EdgeData {
  data: {
    clientId: string;
    token: string;
    baseUrl: string;
    expiresIn: number;
    iat: number;
  };
}

export declare interface EmptyFile {
  readonly id: string;
  readonly createdAt: number;
}

export declare interface ErrorFileState {
  status: 'error';
  id: string;
  occurrenceKey?: string;
  message?: string;
}

declare type ErrorObserver<T> = PartialObserver<T> &
  Required<Pick<PartialObserver<T>, 'error'>>;

export declare type EventPayloadListener<
  M extends EventPayloadMap<P>,
  E extends keyof M,
  P = any
> = (payload: M[E]) => void;

declare type EventPayloadMap<P> = {
  readonly [event: string]: P;
};

export declare type Executor = () => Promise<void>;

export declare interface ExternalImageIdentifier {
  readonly mediaItemType: 'external-image';
  readonly dataURI: string;
  readonly name?: string;
}

declare type ExternalUploadPayload = {
  uploadableFileUpfrontIds: UploadableFileUpfrontIds;
  dimensions: Dimensions;
};

export declare interface FileDetails {
  id: string;
  name?: string;
  size?: number;
  mimeType?: string;
  mediaType?: MediaType;
  creationDate?: number;
  processingStatus?: FileProcessingStatus;
  artifacts?: Artifacts;
  createdAt?: number;
}

export declare interface FileFetcher {
  getFileState(
    id: string,
    options?: GetFileOptions,
  ): MediaSubscribable<FileState>;
  getArtifactURL(
    artifacts: MediaFileArtifacts,
    artifactName: keyof MediaFileArtifacts,
    collectionName?: string,
  ): Promise<string>;
  touchFiles(
    descriptors: TouchFileDescriptor[],
    collection?: string,
  ): Promise<TouchedFiles>;
  upload(
    file: UploadableFile,
    controller?: UploadController,
    uploadableFileUpfrontIds?: UploadableFileUpfrontIds,
  ): MediaSubscribable<FileState>;
  uploadExternal(
    url: string,
    collection?: string,
  ): Promise<ExternalUploadPayload>;
  downloadBinary(
    id: string,
    name?: string,
    collectionName?: string,
  ): Promise<void>;
  getCurrentState(id: string, options?: GetFileOptions): Promise<FileState>;
  copyFile(
    source: CopySourceFile,
    destination: CopyDestination,
    options?: CopyFileOptions,
  ): Promise<MediaFile>;
  getFileBinaryURL(id: string, collectionName?: string): Promise<string>;
}

export declare class FileFetcherError extends BaseMediaClientError<
  FileFetcherErrorAttributes
> {
  readonly reason: FileFetcherErrorReason;
  readonly id: string;
  readonly metadata?:
    | {
        readonly collectionName?: string | undefined;
        readonly occurrenceKey?: string | undefined;
      }
    | undefined;
  constructor(
    reason: FileFetcherErrorReason,
    id: string,
    metadata?:
      | {
          readonly collectionName?: string | undefined;
          readonly occurrenceKey?: string | undefined;
        }
      | undefined,
  );
  get attributes(): {
    reason: FileFetcherErrorReason;
    id: string;
    collectionName: string | undefined;
    occurrenceKey: string | undefined;
  };
}

export declare type FileFetcherErrorAttributes = {
  readonly reason: FileFetcherErrorReason;
  readonly id: string;
  readonly metadata?: {
    readonly collectionName?: string;
    readonly occurrenceKey?: string;
  };
};

export declare type FileFetcherErrorReason =
  | 'invalidFileId'
  | 'emptyItems'
  | 'zeroVersionFile';

export declare class FileFetcherImpl implements FileFetcher {
  private readonly mediaStore;
  private readonly dataloader;
  constructor(mediaStore: MediaStore);
  getFileState(
    id: string,
    options?: GetFileOptions,
  ): MediaSubscribable<FileState>;
  getCurrentState(id: string, options?: GetFileOptions): Promise<FileState>;
  getArtifactURL(
    artifacts: MediaFileArtifacts,
    artifactName: keyof MediaFileArtifacts,
    collectionName?: string,
  ): Promise<string>;
  getFileBinaryURL(id: string, collectionName?: string): Promise<string>;
  private createDownloadFileStream;
  touchFiles(
    descriptors: TouchFileDescriptor[],
    collection?: string,
  ): Promise<TouchedFiles>;
  private generateUploadableFileUpfrontIds;
  uploadExternal(
    url: string,
    collection?: string,
  ): Promise<ExternalUploadPayload>;
  upload(
    file: UploadableFile,
    controller?: UploadController,
    uploadableFileUpfrontIds?: UploadableFileUpfrontIds,
  ): MediaSubscribable<FileState>;
  downloadBinary(
    id: string,
    name?: string,
    collectionName?: string,
  ): Promise<void>;
  copyFile(
    source: CopySourceFile,
    destination: CopyDestination,
    options?: CopyFileOptions,
  ): Promise<MediaFile>;
}

export declare interface FileIdentifier {
  readonly mediaItemType: 'file';
  readonly id: string;
  readonly occurrenceKey?: string;
  readonly collectionName?: string;
}

export declare interface FileItem {
  type: 'file';
  details: FileDetails;
}

export declare interface FilePreview {
  value: Blob | string;
  origin?: 'local' | 'remote';
  originalDimensions?: {
    width: number;
    height: number;
  };
}

export declare type FileProcessingStatus =
  | 'pending'
  | 'running'
  | 'succeeded'
  | 'failed';

export declare type FileState =
  | UploadingFileState
  | ProcessingFileState
  | ProcessedFileState
  | ErrorFileState
  | ProcessingFailedState;

export declare type FileStatus = FileStatus_2;

export declare const getArtifactUrl: (
  artifacts: MediaFileArtifacts,
  prop: keyof MediaFileArtifacts,
) => string | undefined;

export declare const getAttrsFromUrl: (
  blobUrl: string,
) => MediaBlobUrlAttrs | undefined;

export declare const getDimensionsFromBlob: (
  mediaType: MediaType,
  blob: Blob,
) => Promise<Dimensions>;

export declare interface GetFileOptions {
  preview?: PreviewOptions;
  collectionName?: string;
  occurrenceKey?: string;
}

export declare const getMediaClient: (
  mediaClientConfig: MediaClientConfig,
  featureFlags?: MediaFeatureFlags | undefined,
) => MediaClient;

export declare function getMediaClientErrorReason(
  err: Error,
): MediaClientErrorReason | 'unknown';

export declare const getMediaEnvironment: () => string | undefined;

export declare const getMediaRegion: () => string | undefined;

/**
 * @deprecated This export will be removed. Please use one from @atlaskit/media-common or @atlaskit/media-common/mediaTypeUtils
 */
export declare const getMediaTypeFromMimeType: (mimeType: string) => MediaType;

export declare const globalMediaEventEmitter: {
  on<E extends keyof UploadEventPayloadMap>(
    event: E,
    listener: EventPayloadListener<UploadEventPayloadMap, E, any>,
  ): void;
  off<E_1 extends keyof UploadEventPayloadMap>(
    event: E_1,
    listener: EventPayloadListener<UploadEventPayloadMap, E_1, any>,
  ): void;
  emit<E_2 extends keyof UploadEventPayloadMap>(
    event: E_2,
    payload: UploadEventPayloadMap[E_2],
  ): boolean | undefined;
};

export declare type Identifier = FileIdentifier | ExternalImageIdentifier;

export declare interface ImageMetadata {
  pending: boolean;
  preview?: ImageMetadataArtifact;
  original?: ImageMetadataArtifact;
}

export declare type ImageMetadataArtifact = {
  url?: string;
  width?: number;
  height?: number;
  size?: number;
};

export declare type ImageResizeMode =
  | 'crop'
  | 'fit'
  | 'full-fit'
  | 'stretchy-fit';

export declare const imageResizeModeToFileImageMode: (
  resizeMode?: ImageResizeMode | undefined,
) => MediaStoreGetFileImageParams['mode'];

export declare function isAbortedRequestError(err: any): boolean;

/**
 * @deprecated This export will be removed. Please use one from @atlaskit/media-common or @atlaskit/media-common/mediaTypeUtils
 */
export declare const isAudioMimeTypeSupportedByServer: (
  mimeType: string,
) => boolean;

export declare const isDifferentIdentifier: (
  a: Identifier,
  b: Identifier,
) => boolean;

/**
 * @deprecated This export will be removed. Please use one from @atlaskit/media-common or @atlaskit/media-common/mediaTypeUtils
 */
export declare const isDocumentMimeTypeSupportedByBrowser: (
  mimeType: string,
) => boolean;

/**
 * @deprecated This export will be removed. Please use one from @atlaskit/media-common or @atlaskit/media-common/mediaTypeUtils
 */
export declare const isDocumentMimeTypeSupportedByServer: (
  mimeType: string,
) => boolean;

export declare const isErrorFileState: (
  fileState: FileState,
) => fileState is ErrorFileState;

export declare const isExternalImageIdentifier: (
  identifier: Identifier,
) => identifier is ExternalImageIdentifier;

export declare function isFileFetcherError(err: Error): err is FileFetcherError;

export declare const isFileIdentifier: (
  identifier: Identifier,
) => identifier is FileIdentifier;

export declare const isFinalFileState: (
  fileState: FileState,
) => fileState is ProcessedFileState | ProcessingFailedState | ErrorFileState;

/**
 * @deprecated This export will be removed. Please use one from @atlaskit/media-common or @atlaskit/media-common/mediaTypeUtils
 */
export declare const isImageMimeTypeSupportedByBrowser: (
  mimeType: string,
) => boolean;

/**
 * @deprecated This export will be removed. Please use one from @atlaskit/media-common or @atlaskit/media-common/mediaTypeUtils
 */
export declare const isImageMimeTypeSupportedByServer: (
  mimeType: string,
) => boolean;

export declare const isImageRemote: (
  imageUrl: string,
  windowOrigin?: string,
) => boolean;

export declare const isImageRepresentationReady: (
  fileState: FileState,
) => boolean;

export declare const isMediaBlobUrl: (url: string) => boolean;

export declare function isMediaClientError(
  error: any,
): error is MediaClientError<{
  reason: MediaClientErrorReason;
}>;

export declare const isMediaCollectionItemFullDetails: (
  mediaCollectionItem: MediaCollectionItemDetails,
) => mediaCollectionItem is MediaCollectionItemFullDetails;

export declare function isMediaStoreError(err: Error): err is MediaStoreError;

/**
 * @deprecated This export will be removed. Please use one from @atlaskit/media-common or @atlaskit/media-common/mediaTypeUtils
 */
export declare const isMimeTypeSupportedByBrowser: (
  mimeType: string,
) => boolean;

/**
 * @deprecated This export will be removed. Please use one from @atlaskit/media-common or @atlaskit/media-common/mediaTypeUtils
 */
export declare const isMimeTypeSupportedByServer: (mimeType: string) => boolean;

export declare function isPollingError(err?: Error): err is PollingError;

export declare const isPreviewableFileState: (
  fileState: FileState,
) => fileState is (
  | UploadingFileState
  | ProcessingFileState
  | ProcessedFileState
  | ProcessingFailedState
) &
  PreviewableFileState;

export declare const isPreviewableType: (
  type: MediaType,
  featureFlags?: MediaFeatureFlags | undefined,
) => boolean;

export declare const isProcessedFileState: (
  fileState: FileState,
) => fileState is ProcessedFileState;

export declare const isProcessingFileState: (
  fileState: FileState,
) => fileState is ProcessingFileState;

export declare function isRateLimitedError(error: Error | undefined): boolean;

export declare function isRequestError(err: Error): err is RequestError;

/**
 * @deprecated This export will be removed. Please use one from @atlaskit/media-common or @atlaskit/media-common/mediaTypeUtils
 */
export declare const isUnknownMimeTypeSupportedByServer: (
  mimeType: string,
) => boolean;

export declare const isUploadingFileState: (
  fileState: FileState,
) => fileState is UploadingFileState;

/**
 * @deprecated This export will be removed. Please use one from @atlaskit/media-common or @atlaskit/media-common/mediaTypeUtils
 */
export declare const isVideoMimeTypeSupportedByServer: (
  mimeType: string,
) => boolean;

export declare interface ItemsPayload {
  items: ResponseFileItem[];
}

export declare const mapMediaFileToFileState: (
  mediaFile: MediaStoreResponse<MediaFile>,
) => FileState;

export declare const mapMediaItemToFileState: (
  id: string,
  item: MediaCollectionItemFullDetails,
) => FileState;

/**
 * @deprecated Helper is deprecated and will be removed in the next major version.
 * TODO: https://product-fabric.atlassian.net/browse/BMPT-1354
 */
export declare function mapResponseToBlob(response: Response): Promise<Blob>;

/**
 * @deprecated Helper is deprecated and will be removed in the next major version.
 * TODO: https://product-fabric.atlassian.net/browse/BMPT-1354
 */
export declare function mapResponseToJson(response: Response): Promise<any>;

/**
 * @deprecated Helper is deprecated and will be removed in the next major version.
 * TODO: https://product-fabric.atlassian.net/browse/BMPT-1354
 */
export declare function mapResponseToVoid(): Promise<void>;

export declare const MAX_RESOLUTION = 4096;

export declare interface MediaArtifact {
  processingStatus?: FileProcessingStatus;
  url?: string;
}

export declare interface MediaBlobUrlAttrs {
  id: string;
  contextId: string;
  collection?: string;
  size?: number;
  name?: string;
  mimeType?: string;
  width?: number;
  height?: number;
  alt?: string;
}

export declare type MediaChunksProbe = {
  readonly results: {
    readonly [etag: string]: {
      readonly exists: boolean;
    };
  };
};

export declare class MediaClient {
  readonly mediaClientConfig: MediaClientConfig;
  readonly featureFlags?: MediaFeatureFlags | undefined;
  readonly mediaStore: MediaStore;
  readonly collection: CollectionFetcher;
  readonly file: FileFetcher;
  readonly stargate: StargateClient;
  private readonly eventEmitter;
  private mobileUpload?;
  readonly config: MediaClientConfig;
  constructor(
    mediaClientConfig: MediaClientConfig,
    featureFlags?: MediaFeatureFlags | undefined,
  );
  getImage(
    id: string,
    params?: MediaStoreGetFileImageParams,
    controller?: AbortController,
    fetchMaxRes?: boolean,
  ): Promise<Blob>;
  getImageUrl(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): Promise<string>;
  getImageUrlSync(id: string, params?: MediaStoreGetFileImageParams): string;
  getImageMetadata(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): Promise<ImageMetadata>;
  mobileUploadPromise(): Promise<MobileUpload>;
  on<E extends keyof UploadEventPayloadMap>(
    event: E,
    listener: EventPayloadListener<UploadEventPayloadMap, E>,
  ): void;
  off<E extends keyof UploadEventPayloadMap>(
    event: E,
    listener: EventPayloadListener<UploadEventPayloadMap, E>,
  ): void;
  emit<E extends keyof UploadEventPayloadMap>(
    event: E,
    payload: UploadEventPayloadMap[E],
  ): boolean;
}

/**
 * MediaClientError is the main interface which all the errors
 * in Media Client must implement.
 * MediaClientErrorReason is a dictionary that restricts all the possible
 * reasons that the erros can define. Its values are private to this file.
 * Any new error has to define its own Error Reasons locally, and also declare them
 * here to comply with the interface restrictions
 */
export declare interface MediaClientError<
  Attributes extends MediaClientErrorAttributes
> extends Error {
  readonly attributes: Attributes;
}

export declare interface MediaClientErrorAttributes {
  reason: MediaClientErrorReason;
}

export declare type MediaClientErrorReason =
  | 'clientOffline'
  | 'clientAbortedRequest'
  | 'clientTimeoutRequest'
  | 'serverInvalidBody'
  | 'serverBadRequest'
  | 'serverUnauthorized'
  | 'serverForbidden'
  | 'serverNotFound'
  | 'serverRateLimited'
  | 'serverInternalError'
  | 'serverBadGateway'
  | 'serverUnexpectedError'
  | 'failedAuthProvider'
  | 'tokenExpired'
  | 'missingInitialAuth'
  | 'emptyAuth'
  | 'authProviderTimedOut'
  | 'invalidFileId'
  | 'emptyItems'
  | 'zeroVersionFile'
  | 'pollingMaxAttemptsExceeded'
  | 'fileSizeExceedsLimit';

export declare type MediaCollection = {
  readonly name: string;
  readonly createdAt: number;
};

export declare type MediaCollectionItem = {
  readonly id: string;
  readonly insertedAt: number;
  readonly occurrenceKey: string;
  readonly details: MediaCollectionItemDetails;
};

export declare type MediaCollectionItemDetails =
  | MediaCollectionItemMinimalDetails
  | MediaCollectionItemFullDetails;

export declare type MediaCollectionItemFullDetails = {
  readonly mediaType: MediaType;
  readonly mimeType: string;
  readonly name: string;
  readonly processingStatus: MediaFileProcessingStatus;
  readonly size: number;
  readonly artifacts: MediaFileArtifacts;
  readonly representations: MediaRepresentations;
  readonly createdAt?: number;
};

export declare type MediaCollectionItemMinimalDetails = {
  readonly name: string;
  readonly size: number;
};

export declare type MediaCollectionItems = {
  readonly contents: MediaCollectionItem[];
  readonly nextInclusiveStartKey?: string;
};

export declare type MediaFile = {
  readonly id: string;
  readonly mediaType: MediaType;
  readonly mimeType: string;
  readonly name: string;
  readonly processingStatus?: MediaFileProcessingStatus;
  readonly size: number;
  readonly artifacts: MediaFileArtifacts;
  readonly representations: MediaRepresentations;
  readonly createdAt?: number;
};

export declare type MediaFileArtifact = {
  readonly url: string;
  readonly processingStatus: MediaFileProcessingStatus;
};

export declare interface MediaFileArtifacts {
  'video_1280.mp4'?: MediaFileArtifact;
  'video_640.mp4'?: MediaFileArtifact;
  'document.pdf'?: MediaFileArtifact;
  'audio.mp3'?: MediaFileArtifact;
}

export declare type MediaFileProcessingStatus =
  | 'pending'
  | 'succeeded'
  | 'failed';

export declare type MediaItemType = 'file' | 'external-image';

export declare type MediaObserver<T> =
  | NextObserver<T>
  | ErrorObserver<T>
  | CompletionObserver<T>
  | ((value: T) => void);

export declare type MediaRepresentations = {
  image?: Object;
};

export declare class MediaStore {
  private readonly config;
  readonly featureFlags?: MediaFeatureFlags | undefined;
  constructor(
    config: MediaApiConfig,
    featureFlags?: MediaFeatureFlags | undefined,
  );
  getCollectionItems(
    collectionName: string,
    params?: MediaStoreGetCollectionItemsParams,
  ): Promise<MediaStoreResponse<MediaCollectionItems>>;
  removeCollectionFile(
    id: string,
    collectionName: string,
    occurrenceKey?: string,
  ): Promise<void>;
  createUpload(
    createUpTo?: number,
    collectionName?: string,
  ): Promise<MediaStoreResponse<MediaUpload[]>>;
  uploadChunk(
    etag: string,
    blob: Blob,
    {
      collectionName,
      uploadId,
      partNumber,
    }?: {
      collectionName?: string;
      uploadId?: string;
      partNumber?: number;
    },
  ): Promise<void>;
  probeChunks(
    chunks: string[],
    {
      collectionName,
      uploadId,
    }?: {
      collectionName?: string;
      uploadId?: string;
    },
  ): Promise<MediaStoreResponse<MediaChunksProbe>>;
  createFileFromUpload(
    body: MediaStoreCreateFileFromUploadBody,
    params?: MediaStoreCreateFileFromUploadParams,
  ): Promise<MediaStoreResponse<MediaFile>>;
  touchFiles(
    body: MediaStoreTouchFileBody,
    params?: MediaStoreTouchFileParams,
  ): Promise<MediaStoreResponse<TouchedFiles>>;
  getFile(
    fileId: string,
    params?: MediaStoreGetFileParams,
  ): Promise<MediaStoreResponse<MediaFile>>;
  getFileImageURL(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): Promise<string>;
  getFileImageURLSync(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): string;
  private createFileImageURL;
  getFileBinaryURL(id: string, collectionName?: string): Promise<string>;
  getArtifactURL(
    artifacts: MediaFileArtifacts,
    artifactName: keyof MediaFileArtifacts,
    collectionName?: string,
  ): Promise<string>;
  getImage(
    id: string,
    params?: MediaStoreGetFileImageParams,
    controller?: AbortController,
    fetchMaxRes?: boolean,
  ): Promise<Blob>;
  getItems(
    ids: string[],
    collectionName?: string,
  ): Promise<MediaStoreResponse<ItemsPayload>>;
  getImageMetadata(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): Promise<{
    metadata: ImageMetadata;
  }>;
  appendChunksToUpload(
    uploadId: string,
    body: AppendChunksToUploadRequestBody,
    collectionName?: string,
  ): Promise<void>;
  copyFileWithToken(
    body: MediaStoreCopyFileWithTokenBody,
    params: MediaStoreCopyFileWithTokenParams,
  ): Promise<MediaStoreResponse<MediaFile>>;
  request(
    path: string,
    options?: MediaStoreRequestOptions,
    controller?: AbortController,
  ): Promise<Response>;
  resolveAuth: (authContext?: AuthContext | undefined) => Promise<Auth>;
  resolveInitialAuth: () => Auth;
}

export declare type MediaStoreCopyFileWithTokenBody = {
  sourceFile: SourceFile;
};

export declare type MediaStoreCopyFileWithTokenParams = {
  readonly collection?: string;
  readonly replaceFileId?: string;
  readonly occurrenceKey?: string;
};

export declare type MediaStoreCreateFileFromBinaryParams = {
  readonly replaceFileId?: string;
  readonly collection?: string;
  readonly occurrenceKey?: string;
  readonly expireAfter?: number;
  readonly skipConversions?: boolean;
  readonly name?: string;
};

export declare type MediaStoreCreateFileFromUploadBody = {
  readonly uploadId: string;
  readonly name?: string;
  readonly mimeType?: string;
  readonly conditions?: MediaStoreCreateFileFromUploadConditions;
};

export declare type MediaStoreCreateFileFromUploadConditions = {
  readonly hash: string;
  readonly size: number;
};

export declare type MediaStoreCreateFileFromUploadParams = {
  readonly collection?: string;
  readonly occurrenceKey?: string;
  readonly expireAfter?: number;
  readonly replaceFileId?: string;
  readonly skipConversions?: boolean;
};

export declare type MediaStoreCreateFileParams = {
  readonly occurrenceKey?: string;
  readonly collection?: string;
};

export declare class MediaStoreError extends BaseMediaClientError<
  MediaStoreErrorAttributes
> {
  readonly reason: MediaStoreErrorReason;
  readonly innerError?: Error | undefined;
  constructor(reason: MediaStoreErrorReason, innerError?: Error | undefined);
  get attributes(): {
    reason: MediaStoreErrorReason;
    innerError: Error | undefined;
  };
}

export declare type MediaStoreErrorAttributes = {
  readonly reason: MediaStoreErrorReason;
  readonly innerError?: Error;
};

export declare type MediaStoreErrorReason =
  | 'failedAuthProvider'
  | 'tokenExpired'
  | 'missingInitialAuth'
  | 'emptyAuth'
  | 'authProviderTimedOut';

export declare type MediaStoreGetCollectionItemsParams = {
  readonly limit?: number;
  readonly inclusiveStartKey?: string;
  readonly sortDirection?: 'asc' | 'desc';
  readonly details?: 'minimal' | 'full';
};

export declare type MediaStoreGetFileImageParams = {
  readonly allowAnimated?: boolean;
  readonly version?: number;
  readonly collection?: string;
  readonly width?: number;
  readonly height?: number;
  readonly mode?: 'fit' | 'full-fit' | 'crop';
  readonly upscale?: boolean;
  readonly 'max-age'?: number;
};

export declare type MediaStoreGetFileParams = {
  readonly version?: number;
  readonly collection?: string;
};

export declare type MediaStoreRequestOptions = RequestMetadata & {
  readonly method?: RequestMethod;
  readonly authContext?: AuthContext;
  readonly params?: RequestParams;
  readonly headers?: RequestHeaders;
  readonly body?: any;
  readonly clientOptions?: ClientOptions;
};

export declare interface MediaStoreResponse<Data> {
  readonly data: Data;
}

export declare interface MediaStoreTouchFileBody {
  descriptors: TouchFileDescriptor[];
}

export declare interface MediaStoreTouchFileParams {
  readonly collection?: string;
}

export declare type MediaSubscribable<T> = {
  subscribe(observer?: MediaObserver<T>): MediaSubscription;
};

export declare type MediaSubscribableItem = FileState | MediaCollectionItem[];

export declare type MediaSubscription = {
  unsubscribe: () => void;
};

export { MediaType };

export declare type MediaUpload = {
  readonly id: string;
  readonly created: number;
  readonly expires: number;
};

export declare interface MediaViewedEventPayload {
  fileId: string;
  viewingLevel: 'minimal' | 'full' | 'download';
  isUserCollection?: boolean;
}

export declare interface MobileUpload {
  notifyUploadStart(event: MobileUploadStartEvent): void;
  notifyUploadProgress(event: MobileUploadProgressEvent): void;
  notifyUploadEnd(event: MobileUploadEndEvent): void;
  notifyUploadError(event: MobileUploadErrorEvent): void;
}

export declare type MobileUploadEndEvent = {
  fileId: string;
};

export declare type MobileUploadErrorEvent = {
  fileId: string;
  message: string;
};

export declare type MobileUploadProgressEvent = {
  fileId: string;
  progress: number;
};

export declare type MobileUploadStartEvent = {
  fileId: string;
  collectionName?: string;
  occurrenceKey?: string;
  fileName: string;
  fileSize: number;
  fileMimetype: string;
  preview?: FilePreview;
  createdAt?: number;
};

declare type NextObserver<T> = PartialObserver<T> &
  Required<Pick<PartialObserver<T>, 'next'>>;

export declare type NonErrorFileState = Exclude<FileState, ErrorFileState>;

export declare const objectToQueryString: (json: {
  [key: string]: string | number | boolean | null | undefined;
}) => string;

declare type PartialObserver<T> = {
  next?: (value: T) => void;
  error?: (err: any) => void;
  complete?: () => void;
};

export declare class PollingError extends BaseMediaClientError<
  PollingErrorAttributes
> {
  readonly reason: PollingErrorReason;
  readonly attempts: number;
  constructor(reason: PollingErrorReason, attempts: number);
  get attributes(): {
    reason: 'pollingMaxAttemptsExceeded';
    attempts: number;
  };
}

export declare type PollingErrorAttributes = {
  readonly reason: PollingErrorReason;
  readonly attempts: number;
  readonly innerError?: Error;
};

export declare type PollingErrorReason = 'pollingMaxAttemptsExceeded';

/**
 * This class encapsulates polling functionality with the following features:
 *
 *  - async executor function provides each attempt
 *  - executor will only repeat defined max amount of times (options)
 *  - each attempt uses a timeout to the next attempt by an interval (ms)
 *  - each attempt increases the timeout interval by a "poll_backoffFactor"
 *  - if max attempts are exceeded or executor has exception then onError handler is called
 *
 * IMPORTANT! the executor function must explicitly call ".next()" for the next iteration to run
 */
export declare class PollingFunction {
  options: PollingOptions;
  poll_intervalMs: number;
  attempt: number;
  shouldIterate: boolean;
  onError?: (error: Error) => void;
  timeoutId: number;
  constructor(options?: Partial<PollingOptions>);
  execute(executor: Executor): Promise<void>;
  private fail;
  getIntervalMsForIteration(iteration: number): number;
  next(): void;
  cancel(): void;
}

declare interface PollingOptions {
  poll_intervalMs: number;
  poll_maxAttempts: number;
  poll_backoffFactor: number;
  poll_maxIntervalMs: number;
}

export declare interface PreviewableFileState {
  preview: FilePreview | Promise<FilePreview>;
}

export declare interface PreviewOptions {}

export declare interface ProcessedFileState {
  status: 'processed';
  id: string;
  occurrenceKey?: string;
  name: string;
  size: number;
  artifacts: MediaFileArtifacts;
  mediaType: MediaType;
  mimeType: string;
  preview?: FilePreview | Promise<FilePreview>;
  representations?: MediaRepresentations;
  createdAt?: number;
}

export declare interface ProcessingFailedState {
  status: 'failed-processing';
  id: string;
  occurrenceKey?: string;
  name: string;
  size: number;
  artifacts: Object;
  mediaType: MediaType;
  mimeType: string;
  preview?: FilePreview | Promise<FilePreview>;
  representations?: MediaRepresentations;
  createdAt?: number;
}

export declare interface ProcessingFileState {
  status: 'processing';
  id: string;
  occurrenceKey?: string;
  name: string;
  size: number;
  artifacts?: MediaFileArtifacts;
  mediaType: MediaType;
  mimeType: string;
  preview?: FilePreview | Promise<FilePreview>;
  representations?: MediaRepresentations;
  createdAt?: number;
}

export declare const RECENTS_COLLECTION = 'recents';

export declare function request(
  url: string,
  options?: RequestOptions,
  controller?: AbortController,
): Promise<Response>;

export declare class RequestError extends BaseMediaClientError<
  RequestErrorAttributes
> {
  readonly reason: RequestErrorReason;
  readonly metadata?: RequestErrorMetadata | undefined;
  readonly innerError?: Error | undefined;
  constructor(
    reason: RequestErrorReason,
    metadata?: RequestErrorMetadata | undefined,
    innerError?: Error | undefined,
  );
  get attributes(): {
    reason: RequestErrorReason;
    method: RequestMethod | undefined;
    endpoint: string | undefined;
    mediaRegion: string | undefined;
    mediaEnv: string | undefined;
    attempts: number | undefined;
    clientExhaustedRetries: boolean | undefined;
    statusCode: number | undefined;
    innerError: Error | undefined;
  };
}

export declare type RequestErrorAttributes = RequestErrorMetadata & {
  readonly reason: RequestErrorReason;
};

export declare type RequestErrorMetadata = RequestMetadata & {
  readonly attempts?: number;
  readonly clientExhaustedRetries?: boolean;
  readonly statusCode?: number;
};

export declare type RequestErrorReason =
  | 'clientOffline'
  | 'clientAbortedRequest'
  | 'clientTimeoutRequest'
  | 'serverInvalidBody'
  | 'serverBadRequest'
  | 'serverUnauthorized'
  | 'serverForbidden'
  | 'serverNotFound'
  | 'serverRateLimited'
  | 'serverInternalError'
  | 'serverBadGateway'
  | 'serverUnexpectedError';

export declare type RequestHeaders = {
  [key: string]: string;
};

export declare type RequestMetadata = {
  readonly method?: RequestMethod;
  readonly endpoint?: string;
  readonly mediaRegion?: string;
  readonly mediaEnv?: string;
};

export declare type RequestMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

export declare type RequestOptions = RequestMetadata & {
  readonly auth?: Auth;
  readonly params?: RequestParams;
  readonly headers?: RequestHeaders;
  readonly body?: any;
  readonly clientOptions?: ClientOptions;
};

export declare type RequestParams = {
  [key: string]: any;
};

export declare interface ResponseFileItem {
  id: string;
  type: 'file';
  details: MediaCollectionItemFullDetails;
  collection?: string;
}

export declare type RetryOptions = {
  readonly startTimeoutInMs: number;
  readonly maxAttempts: number;
  readonly factor: number;
};

export declare const safeUnsubscribe: (subscription: MediaSubscription) => void;

export declare interface SourceFile {
  id: string;
  owner: ClientAltBasedAuth | AsapBasedAuth;
  collection?: string;
  version?: number;
}

export declare class StargateClient {
  private baseUrl;
  constructor(baseUrl: string | undefined);
  fetchToken(clientId: string): Promise<EdgeData>;
  isTokenExpired(token: EdgeData): boolean;
}

export declare type TouchedFiles = {
  created: CreatedTouchedFile[];
};

export declare interface TouchFileDescriptor {
  fileId: string;
  collection?: string;
  occurrenceKey?: string;
  expireAfter?: number;
  deletable?: boolean;
}

export declare type UploadableFile = {
  content: ChunkinatorFile;
  name?: string;
  mimeType?: string;
  collection?: string;
};

export declare type UploadableFileUpfrontIds = {
  id: string;
  deferredUploadId: Promise<string>;
  occurrenceKey?: string;
};

export declare class UploadController {
  abortFunction?: AbortFunction;
  constructor();
  setAbort(abortFunction: AbortFunction): void;
  abort(): void;
}

export declare type UploadEventPayloadMap = {
  'file-added': FileState;
  'media-viewed': MediaViewedEventPayload;
};

export declare const uploadFile: (
  file: UploadableFile,
  store: MediaStore,
  uploadableFileUpfrontIds: UploadableFileUpfrontIds,
  callbacks?: UploadFileCallbacks | undefined,
) => UploadFileResult;

export declare type UploadFileCallbacks = {
  onProgress: (progress: number) => void;
  onUploadFinish: (error?: any) => void;
};

export declare interface UploadFileResult {
  cancel: () => void;
}

export declare interface UploadingFileState {
  status: 'uploading';
  id: string;
  occurrenceKey?: string;
  name: string;
  size: number;
  progress: number;
  mediaType: MediaType;
  mimeType: string;
  preview?: FilePreview | Promise<FilePreview>;
  createdAt?: number;
}

export declare interface WithMediaClient {
  mediaClient: MediaClient;
  identifier?: Identifier;
}

export declare const withMediaClient: WithMediaClientFunction;

export declare interface WithMediaClientConfig {
  mediaClientConfig: MediaClientConfig;
}

export declare type WithMediaClientConfigProps<
  P extends WithMediaClient
> = Omit<P, 'mediaClient'> & WithMediaClientConfig;

export declare type WithMediaClientFunction = <P extends WithMediaClient>(
  Component: React_2.ComponentType<P>,
  featureFlags?: MediaFeatureFlags,
) => React_2.ComponentType<WithMediaClientConfigProps<P>>;

export {};
```
