## API Report File for "@atlaskit/media-ui".

> Do not edit this file. This report is auto-generated by [API Extractor](https://api-extractor.com/).

[Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

```ts
/// <reference types="react" />

import { Appearance } from '@atlaskit/button/types';
import { Component } from 'react';
import { CustomThemeButtonProps } from '@atlaskit/button/types';
import { MediaFeatureFlags } from '@atlaskit/media-common';
import { MediaType } from '@atlaskit/media-common';
import { MessageDescriptor } from 'react-intl-next';
import { NumericalCardDimensions } from '@atlaskit/media-common';
import { default as React_2 } from 'react';
import { ReactElement } from 'react';
import { RefObject } from 'react';
import SourceCodeIcon from '@atlaskit/icon-file-type/glyph/source-code/24';
import { WithAnalyticsEventsProps } from '@atlaskit/analytics-next';

export declare const absolute: (top?: number, left?: number) => string;

export declare interface AccessContext {
  accessType?: AccessTypes;
  cloudId?: string;
  url?: string;
  smartLinksAccessMetadataExperimentCohort?:
    | 'experiment'
    | 'control'
    | 'not-enrolled';
}

export declare type AccessTypes =
  | 'REQUEST_ACCESS'
  | 'PENDING_REQUEST_EXISTS'
  | 'FORBIDDEN'
  | 'DIRECT_ACCESS'
  | 'DENIED_REQUEST_EXISTS'
  | 'APPROVED_REQUEST_EXISTS'
  | 'ACCESS_EXISTS';

export declare const borderRadius: string;

export declare const borderRadiusBottom: string;

export declare class Bounds extends Rectangle {
  readonly x: number;
  readonly y: number;
  readonly width: number;
  readonly height: number;
  constructor(x: number, y: number, width: number, height: number);
  get origin(): Vector2;
  get corner(): Vector2;
  get center(): Vector2;
  get rect(): Rectangle;
  get left(): number;
  get top(): number;
  get right(): number;
  get bottom(): number;
  flipped(): Bounds;
  scaled(scale: number): Bounds;
  relativeTo(bounds: Bounds): Bounds;
  clone(): Bounds;
  map(fn: (value: number) => number): Bounds;
  hFlipWithin(containerBounds: Bounds): Bounds;
  vFlipWithin(containerBounds: Bounds): Bounds;
  rotate90DegWithin(containerBounds: Bounds): Bounds;
  translated(xDelta: number, yDelta: number): Bounds;
  equals(bounds: Bounds): boolean;
}

export declare class Camera {
  readonly viewport: Rectangle;
  readonly originalImg: Rectangle;
  constructor(viewport: Rectangle, originalImg: Rectangle);
  resizedViewport(newViewport: Rectangle): Camera;
  get scaleToFit(): number;
  get scaleDownToFit(): number;
  get fittedImg(): Rectangle;
  scaledImg(newScale: number): Rectangle;
  scaledOffset(
    prevOffset: Vector2,
    prevScale: number,
    newScale: number,
  ): Vector2;
}

export declare const center =
  '\n  display: flex;\n  align-items: center;\n  justify-content: center;\n';

export declare const CustomMediaPlayer: React_2.ComponentType<
  CustomMediaPlayerProps & WithAnalyticsEventsProps
>;

declare interface CustomMediaPlayerProps
  extends WithPlaybackProps,
    WithShowControlMethodProp {
  readonly type: CustomMediaPlayerType;
  readonly src: string;
  readonly fileId?: string;
  readonly onHDToggleClick?: () => void;
  readonly isShortcutEnabled?: boolean;
  readonly lastWatchTimeConfig?: TimeSaverConfig;
  readonly onCanPlay?: () => void;
  readonly onError?: () => void;
  readonly onDownloadClick?: () => void;
  readonly onFirstPlay?: () => void;
  readonly onFullscreenChange?: (fullscreen: boolean) => void;
  readonly originalDimensions?: NumericalCardDimensions;
  readonly featureFlags?: MediaFeatureFlags;
  readonly poster?: string;
}

declare type CustomMediaPlayerType = 'audio' | 'video';

export declare function dataURItoFile(dataURI: string, filename?: string): File;

export declare const easeInOutCubic = 'cubic-bezier(0.645, 0.045, 0.355, 1)';

export declare const Ellipsify: ({
  text,
  lines,
  endLength,
  inline,
  testId,
}: EllipsifyProps) => JSX.Element;

export declare interface EllipsifyProps {
  text?: string;
  lines: number;
  endLength?: number;
  inline?: boolean;
  testId?: string;
}

export declare const ellipsis: (maxWidth?: string | number) => string;

export declare const errorIcon: JSX.Element;

export declare const ExifOrientation: {
  [key: string]: number;
};

export declare const fadeIn: string;

export declare type FileInfo = {
  file: File;
  src: string;
};

export declare function fileToArrayBuffer(file: File): Promise<Uint8Array>;

export declare function fileToDataURI(blob: Blob): Promise<string>;

export declare const findParentByClassname: (
  element: HTMLElement,
  className: string,
  maxParentElement?: HTMLElement,
) => HTMLElement | undefined;

export declare const formatDate: (timestamp: number, locale?: string) => string;

export declare const formatDuration: (seconds: number) => string;

export declare const getCssFromImageOrientation: (
  orientation: number,
) => string;

export declare function getFileInfo(
  file: File,
  src?: string,
): Promise<FileInfo>;

export declare function getFileInfoFromSrc(
  src: string,
  file?: File,
): Promise<FileInfo>;

export declare function getImageInfo(
  fileInfo: FileInfo,
): Promise<ImageInfo | null>;

export declare function getMetaTagNumericValue(
  tags: ImageMetaDataTags,
  key: string,
  defaultValue: number,
): number;

export declare function getMimeIcon(
  mimeType: string,
  fileName: string,
):
  | MimeTypesRepresentation
  | {
      label: string;
      icon: typeof SourceCodeIcon;
    }
  | undefined;

export declare function getOrientation(file: File): Promise<number>;

export declare function getScaleFactor(
  file: File,
  tags: ImageMetaDataTags | null,
): number;

export declare function getScaleFactorFromFile(file: File): number | null;

export declare const hideControlsClassName = 'mvng-hide-controls';

export declare type ImageInfo = {
  scaleFactor: number;
  width: number;
  height: number;
};

export declare type ImageMetaData = {
  type: string;
  width: number;
  height: number;
  naturalWidth: number;
  naturalHeight: number;
  tags: ImageMetaDataTags | null;
};

export declare type ImageMetaDataTags = {
  Orientation?: string;
  PixelPerUnitX?: number;
  PixelPerUnitY?: number;
  [key: string]: string | number | undefined;
};

/**
 * Hides all the child elements with `hideControlsClassName` classname when user is inactive,
 * which means they haven't moved mouse over the component for `mouseMovementDelay` ms.
 * Exception is if user holding mouse over one of the hideable elements (those that have specified classname).
 *
 */
export declare class InactivityDetector extends Component<
  InactivityDetectorProps,
  InactivityDetectorState
> {
  private checkActivityTimeout?;
  private contentWrapperElement;
  state: InactivityDetectorState;
  private clearTimeout;
  private hideControls;
  private checkMouseMovement;
  componentDidMount(): void;
  componentWillUnmount(): void;
  render(): JSX.Element;
}

declare interface InactivityDetectorProps {
  children: (triggerActivityCallback: () => void) => ReactElement;
}

declare interface InactivityDetectorState {
  controlsAreVisible: boolean;
}

declare type InlinePreloaderStyle =
  | 'on-left-with-skeleton'
  | 'on-right-without-skeleton';

export declare const isIntersectionObserverSupported: () => boolean;

/**
 * Returns true if image rotated 90 or 270 degrees (on it's side)
 */
export declare const isRotated: (orientation: number) => boolean;

export declare const keyCodes: {
  space: string;
  m: string;
  rightArrow: string;
  leftArrow: string;
};

export declare const languages: {
  zh: string;
  cs: string;
  da: string;
  nl: string;
  en: string;
  en_GB: string;
  et: string;
  fi: string;
  fr: string;
  de: string;
  hu: string;
  is: string;
  it: string;
  ja: string;
  ko: string;
  nb: string;
  pl: string;
  pt_BR: string;
  pt_PT: string;
  ro: string;
  ru: string;
  sk: string;
  es: string;
  sv: string;
};

export declare function loadImage(src: string): Promise<HTMLImageElement>;

export declare const locales: {
  [key: string]: any;
};

export declare function MediaButton({
  appearance,
  buttonRef,
  ...rest
}: Props): JSX.Element;

declare type MediaButtonAppearance = Appearance;

declare class MediaImage_2 extends Component<MediaImageProps, MediaImageState> {
  static defaultProps: Partial<MediaImageProps>;
  imageRef: React_2.RefObject<HTMLImageElement>;
  constructor(props: MediaImageProps);
  componentDidMount(): void;
  onImageLoad: (e: React_2.SyntheticEvent<HTMLImageElement>) => void;
  render(): JSX.Element;
}
export { MediaImage_2 as MediaImage };

export declare interface MediaImageProps {
  dataURI: string;
  alt?: string;
  crop?: boolean;
  stretch?: boolean;
  previewOrientation?: number;
  crossOrigin?: '' | 'anonymous' | 'use-credentials';
  onImageLoad?: (loadedImage: HTMLImageElement) => void;
  onImageError?: () => void;
  loading?: 'auto' | 'lazy' | 'eager';
  forceSyncDisplay?: boolean;
}

export declare interface MediaImageState {
  isImageLoaded: boolean;
  imgWidth: number;
  imgHeight: number;
  parentWidth: number;
  parentHeight: number;
}

export declare class MediaInlineCardErroredView extends React_2.Component<
  MediaInlineCardErroredViewProps
> {
  renderMessage: () => JSX.Element;
  render(): JSX.Element;
}

export declare interface MediaInlineCardErroredViewProps {
  /** The error message to display */
  message: string;
  /** The optional click handler */
  onClick?: React_2.EventHandler<React_2.MouseEvent | React_2.KeyboardEvent>;
  /** A flag that determines whether the card is selected in edit mode. */
  isSelected?: boolean;
  /** A `testId` prop is provided for specified elements, which is a unique string that appears as a data attribute `data-testid` in the rendered code, serving as a hook for automated tests */
  testId?: string;
  icon?: React_2.ReactNode;
}

export declare class MediaInlineCardLoadedView extends React_2.Component<
  MediaInlineCardLoadedViewProps
> {
  render(): JSX.Element;
}

export declare interface MediaInlineCardLoadedViewProps {
  /** The optional con of the service (e.g. Dropbox/Asana/Google/etc) to display */
  icon?: React_2.ReactNode;
  /** The name of the resource */
  title?: string;
  /** A flag that determines whether the card is selected in edit mode. */
  isSelected?: boolean;
  /** The optional click handler */
  onClick?: React_2.EventHandler<React_2.MouseEvent | React_2.KeyboardEvent>;
  /** A `testId` prop is provided for specified elements, which is a unique string that appears as a data attribute `data-testid` in the rendered code, serving as a hook for automated tests */
  testId?: string;
  /** The Emoji icon prefix that was added to the title text via Add emoji button */
  titlePrefix?: React_2.ReactNode;
}

export declare class MediaInlineCardLoadingView extends React_2.Component<
  MediaInlineCardLoadingViewProps
> {
  render(): JSX.Element;
}

export declare interface MediaInlineCardLoadingViewProps {
  /** The file name to display */
  message: string;
  inlinePreloaderStyle?: InlinePreloaderStyle;
  /** The optional click handler */
  onClick?: React_2.EventHandler<React_2.MouseEvent | React_2.KeyboardEvent>;
  /** A flag that determines whether the card is selected in edit mode. */
  isSelected?: boolean;
  /** A `testId` prop is provided for specified elements, which is a unique string that appears as a data attribute `data-testid` in the rendered code, serving as a hook for automated tests */
  testId?: string;
  withoutHover?: boolean;
}

declare type MediaTypeProps = {
  testId?: string;
  mediaType?: MediaType;
  mimeType?: string;
  name?: string;
  size?: 'small' | 'large';
};

export declare type MessageKey =
  | 'retry'
  | 'failed_to_load'
  | 'failed_to_upload'
  | 'recent_uploads'
  | 'upload_file'
  | 'drag_and_drop_your_files'
  | 'drag_and_drop_your_files_and_folders'
  | 'drop_your_files'
  | 'upload'
  | 'cancel'
  | 'search_all_gifs'
  | 'cant_retrieve_gifs'
  | 'cant_retrieve_files'
  | 'check_your_network'
  | 'try_again'
  | 'try_another_account'
  | 'no_gifs_found'
  | 'no_gifs_found_suggestion'
  | 'load_more_gifs'
  | 'add_account'
  | 'unlink_account'
  | 'upload_file_from'
  | 'connect_to'
  | 'connect_account_description'
  | 'connect_link_account'
  | 'connect_link_account_card'
  | 'connect_link_account_card_name'
  | 'connect_link_account_card_description'
  | 'invalid_permissions'
  | 'invalid_permissions_description'
  | 'upload_an_avatar'
  | 'loading'
  | 'loading_file'
  | 'save'
  | 'or'
  | 'upload_photo'
  | 'default_avatars'
  | 'drag_and_drop_images_here'
  | 'upload_image'
  | 'image_url_invalid_error'
  | 'image_format_invalid_error'
  | 'image_size_too_large_error'
  | 'something_went_wrong'
  | 'might_be_a_hiccup'
  | 'couldnt_generate_preview'
  | 'couldnt_generate_encrypted_entry_preview'
  | 'cant_preview_file_type'
  | 'item_not_found_in_list'
  | 'not_found_title'
  | 'not_found_description'
  | 'no_pdf_artifacts'
  | 'give_feedback'
  | 'try_downloading_file'
  | 'webgl_warning_description'
  | 'unable_to_annotate_image'
  | 'learn_more'
  | 'accounts'
  | 'actions'
  | 'error_hint_retry'
  | 'error_hint_critical'
  | 'close'
  | 'could_not_load_editor'
  | 'could_not_save_image'
  | 'could_not_load_link'
  | 'annotate'
  | 'annotate_tool_arrow'
  | 'annotate_tool_text'
  | 'annotate_tool_shape'
  | 'annotate_tool_brush'
  | 'annotate_tool_blur'
  | 'annotate_tool_line_thickness'
  | 'annotate_tool_color'
  | 'annotate_confirmation_close_anyway'
  | 'annotate_confirmation_heading'
  | 'annotate_confirmation_content'
  | 'drop_your_files_here'
  | 'share_files_instantly'
  | 'insert_files'
  | 'zoom_out'
  | 'zoom_in'
  | 'remove_image'
  | 'play'
  | 'pause'
  | 'disable_fullscreen'
  | 'enable_fullscreen'
  | 'error_loading_file'
  | 'error_generating_preview'
  | 'download'
  | 'unknown'
  | 'document'
  | 'audio'
  | 'video'
  | 'image'
  | 'archive'
  | 'email'
  | 'text'
  | 'displayThumbnail'
  | 'search'
  | 'view'
  | 'viewIn'
  | 'viewOriginal'
  | 'changeView'
  | 'playbackSpeed'
  | 'skipBackward'
  | 'skipForward'
  | 'playbackDefaultSpeed'
  | 'preview'
  | 'preview_unavailable'
  | 'preview_currently_unavailable'
  | 'creating_preview'
  | 'couldnt_load_file'
  | 'error_429'
  | 'close_and_reopen'
  | 'viewer_rateLimited'
  | 'zip_entry_load_fail'
  | RequestAccessMessageKey;

declare type Messages = {
  [K in MessageKey]: MessageDescriptor;
};

export declare const messages: Messages;

export declare const MimeTypeIcon: ({
  mediaType,
  mimeType,
  name,
  testId,
  size,
}: MediaTypeProps) => JSX.Element;

declare interface MimeTypesRepresentation {
  label: string;
  mimeTypes: string[];
  icon: any;
}

export declare const ModalSpinner: ({
  blankedColor,
  invertSpinnerColor,
}: Props_2) => JSX.Element;

declare type Props = WithMediaButtonAppearance<CustomThemeButtonProps> & {
  buttonRef?: RefObject<HTMLButtonElement>;
};

declare interface Props_2 {
  blankedColor?: string;
  invertSpinnerColor?: boolean;
}

export declare function readImageMetaData(
  fileInfo: FileInfo,
): Promise<ImageMetaData | null>;

export declare class Rectangle {
  readonly width: number;
  readonly height: number;
  constructor(width: number, height: number);
  get aspectRatio(): number;
  get center(): Vector2;
  scaled(scale: number): Rectangle;
  resized(width: number, height: number): Rectangle;
  flipped(): Rectangle;
  scaleToFit(containing: Rectangle): number;
  scaleToFitLargestSide(containing: Rectangle): number;
  scaleToFitSmallestSide(containing: Rectangle): number;
  clone(): Rectangle;
}

declare type RequestAccessMessageKey =
  | 'request_access_description'
  | 'click_to_join_description'
  | 'request_access_pending_description'
  | 'click_to_join'
  | 'request_access'
  | 'request_access_pending'
  | 'forbidden_description'
  | 'request_denied_description';

export declare class Shortcut extends Component<ShortcutProps, {}> {
  componentDidMount(): void;
  componentWillUnmount(): void;
  render(): null;
  private keyHandler;
  private init;
  private release;
}

export declare type ShortcutProps = {
  handler: () => void;
} & (WithKeyCode | WithCode);

export declare const size: (value?: string | number) => string;

export declare class TimeRange extends Component<
  TimeRangeProps,
  TimeRangeState
> {
  thumbElement: React_2.RefObject<HTMLDivElement>;
  wrapperElement: React_2.RefObject<HTMLDivElement>;
  wrapperElementWidth: number;
  state: TimeRangeState;
  static defaultProps: Partial<TimeRangeProps>;
  componentDidMount(): void;
  componentWillUnmount(): void;
  private setWrapperWidth;
  onMouseMove: (e: MouseEvent) => void;
  onMouseUp: () => void;
  onThumbMouseDown: (e: React_2.SyntheticEvent<HTMLDivElement>) => void;
  render(): JSX.Element;
}

export declare interface TimeRangeProps {
  currentTime: number;
  bufferedTime: number;
  duration: number;
  onChange: (newTime: number) => void;
  disableThumbTooltip: boolean;
  isAlwaysActive: boolean;
  onChanged?: () => void;
}

export declare interface TimeRangeState {
  isDragging: boolean;
  dragStartClientX: number;
}

declare interface TimeSaverConfig {
  contentId: string;
}

/**
 * Takes a media (file) size in bytes and returns a human readable string
 */
export declare function toHumanReadableMediaSize(size: number): string;

export declare const Truncate: React_2.FC<TruncateProps>;

export declare type TruncateProps = {
  text: string;
  fontSizePX?: number;
  startFixedChars?: number;
  endFixedChars?: number;
};

export declare class Vector2 {
  readonly x: number;
  readonly y: number;
  constructor(x: number, y: number);
  add({ x: thatX, y: thatY }: Vector2): Vector2;
  sub({ x: thatX, y: thatY }: Vector2): Vector2;
  scaled(scalar: number): Vector2;
  map(fn: (component: number) => number): Vector2;
  clone(): Vector2;
  rounded(): Vector2;
  toString(): string;
}

declare type WithCode = {
  code: string;
  keyCode?: never;
};

declare type WithKeyCode = {
  /** @deprecated use code: string instead */
  keyCode: number;
  code?: never;
};

declare type WithMediaButtonAppearance<T> = Omit<T, 'appearance'> & {
  appearance?: MediaButtonAppearance;
};

declare type WithPlaybackProps = {
  readonly isAutoPlay: boolean;
  readonly isHDAvailable?: boolean;
  readonly isHDActive?: boolean;
};

export declare interface WithShowControlMethodProp {
  showControls?: () => void;
}

export {};
```
