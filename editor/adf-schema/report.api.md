## API Report File for "@atlaskit/adf-schema"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { CellAttributes } from '@atlaskit/editor-tables/types';
import LinkifyIt from 'linkify-it';
import { Mark } from 'prosemirror-model';
import { MarkSpec } from 'prosemirror-model';
import { Node as Node_2 } from 'prosemirror-model';
import { NodeSpec } from 'prosemirror-model';
import { Schema } from 'prosemirror-model';

export declare function acNameToEmoji(
  acName: NameToEmoji,
): {
  id: string;
  shortName: string;
  text: string;
};

/**
 * Confluence glyphs ac:name of <ac:emoticon /> map to new emojis
 * {
 *   [ac:name] : ['emoji-id', 'emoji-shortName', 'emoji-fallback']
 *   ...
 * }
 * Glyphs that do not map to Fabric Emoji
 * will be mapped to Emoji Id '2b50' (:star:) with preserving ac:name as shortName attribute;
 */
declare const acNameToEmojiMap: {
  smile: string[];
  sad: string[];
  cheeky: string[];
  laugh: string[];
  wink: string[];
  information: string[];
  tick: string[];
  cross: string[];
  warning: string[];
  plus: string[];
  minus: string[];
  question: string[];
  'thumbs-up': string[];
  'thumbs-down': string[];
  'light-on': string[];
  'yellow-star': string[];
  'light-off': string[];
  'red-star': string[];
  'green-star': string[];
  'blue-star': string[];
  heart: string[];
  'broken-heart': string[];
};

export declare function acShortcutToEmoji(
  hipchatEmoticonShortName: string,
): {
  id: string;
  shortName: string;
  text: string;
};

export declare const alignment: MarkSpec;

export declare interface AlignmentAttributes {
  align: 'center' | 'end';
}

/**
 * @name alignment_mark
 */
export declare interface AlignmentMarkDefinition {
  type: 'alignment';
  attrs: AlignmentAttributes;
}

/** TODO: Flip these positions for RTL */
export declare const alignmentPositionMap: {
  [key: string]: string;
};

export declare const annotation: MarkSpec;

export declare type AnnotationDataAttributes = {
  'data-mark-type': string;
  'data-mark-annotation-type': AnnotationTypes;
  'data-id': AnnotationId;
  'data-mark-annotation-state'?: AnnotationMarkStates;
};

export declare type AnnotationId = string;

export declare interface AnnotationMarkAttributes {
  id: AnnotationId;
  annotationType: AnnotationTypes;
}

/**
 * @name annotation_mark
 */
export declare interface AnnotationMarkDefinition {
  type: 'annotation';
  attrs: AnnotationMarkAttributes;
}

export declare enum AnnotationMarkStates {
  RESOLVED = 'resolved',
  ACTIVE = 'active',
}

export declare enum AnnotationTypes {
  INLINE_COMMENT = 'inlineComment',
}

export declare const B100 = '#4C9AFF';

export declare const B400 = '#0052CC';

export declare const B50 = '#DEEBFF';

export declare const B500 = '#0747A6';

export declare const B75 = '#B3D4FF';

export declare const blockCard: NodeSpec;

/**
 * @name blockCard_node
 */
export declare interface BlockCardDefinition {
  type: 'blockCard';
  attrs: CardAttributes;
}

/**
 * @name block_content
 */
export declare type BlockContent =
  | PanelDefinition
  | ParagraphDefinition
  | ParagraphWithAlignmentDefinition
  | BlockQuoteDefinition
  | OrderedListDefinition
  | BulletListDefinition
  | RuleDefinition
  | HeadingDefinition
  | HeadingWithMarksDefinition
  | CodeBlockDefinition
  | MediaGroupDefinition
  | MediaSingleDefinition
  | DecisionListDefinition
  | TaskListDefinition
  | TableDefinition
  | ExpandDefinition
  | ExtensionDefinition
  | BodiedExtensionDefinition
  | BlockCardDefinition
  | EmbedCardDefinition;

export declare const blockquote: NodeSpec;

/**
 * @name blockquote_node
 */
export declare interface BlockQuoteDefinition {
  type: 'blockquote';
  /**
   * @minItems 1
   * @allowUnsupportedBlock true
   */
  content: Array<ParagraphDefinition>;
}

export declare const bodiedExtension: NodeSpec;

/**
 * @name bodiedExtension_node
 */
declare interface BodiedExtensionBaseDefinition {
  type: 'bodiedExtension';
  attrs: ExtensionAttributes;
  marks?: Array<any>;
  /**
   * @minItems 1
   * @allowUnsupportedBlock true
   */
  content: Array<NonNestableBlockContent>;
}

/**
 * @name bodiedExtension_with_marks_node
 */
export declare type BodiedExtensionDefinition = BodiedExtensionBaseDefinition &
  MarksObject<DataConsumerDefinition | FragmentDefinition>;

export declare const breakout: MarkSpec;

export declare type BreakoutMarkAttrs = {
  mode: 'wide' | 'full-width';
};

/**
 * @name breakout_mark
 */
export declare interface BreakoutMarkDefinition {
  type: 'breakout';
  attrs: BreakoutMarkAttrs;
}

export declare function buildAnnotationMarkDataAttributes({
  id,
  annotationType,
  state,
}: BuildDataAttributesProps): AnnotationDataAttributes;

declare type BuildDataAttributesProps = AnnotationMarkAttributes & {
  state?: AnnotationMarkStates | undefined | null;
};

export declare const bulletList: NodeSpec;

/**
 * @name bulletList_node
 */
export declare interface BulletListDefinition {
  type: 'bulletList';
  /**
   * @minItems 1
   */
  content: Array<ListItemDefinition>;
}

export declare const bulletListSelector = '.ak-ul';

export declare const caption: NodeSpec;

/**
 * @name caption_node
 */
export declare interface CaptionDefinition {
  type: 'caption';
  /**
   * @minItems 0
   */
  content: Array<
    | InlineFormattedText
    | InlineCode
    | HardBreakDefinition
    | MentionDefinition
    | EmojiDefinition
    | DateDefinition
    | PlaceholderDefinition
    | InlineCardDefinition
    | StatusDefinition
  >;
}

export declare type CardAttributes = UrlType | DataType;

export { CellAttributes };

export declare type CellDomAttrs = {
  colspan?: string;
  rowspan?: string;
  style?: string;
  colorname?: string;
  'data-colwidth'?: string;
  class?: string;
};

export declare const code: MarkSpec;

export declare const codeBlock: NodeSpec;

export declare type CodeBlockAttrs = {
  language?: string;
};

/**
 * @name codeBlock_node
 */
export declare type CodeBlockBaseDefinition = {
  type: 'codeBlock';
  /**
   * @allowUnsupportedInline true
   */
  content?: Array<TextDefinition & NoMark>;
  marks?: Array<any>;
  attrs?: CodeBlockAttrs;
};

/**
 * @name codeBlock_with_no_marks_node
 */
export declare type CodeBlockDefinition = CodeBlockBaseDefinition & NoMark;

export declare const codeBlockToJSON: (
  node: Node_2,
) => {
  attrs: Record<string, any>;
};

/**
 * @name codeBlock_with_marks_node
 */
export declare type CodeBlockWithMarksDefinition = CodeBlockBaseDefinition &
  MarksObject<BreakoutMarkDefinition>;

/**
 * @name code_mark
 */
export declare interface CodeDefinition {
  type: 'code';
}

export declare const colorPalette: Map<string, TextColorKey>;

export declare const colorPaletteExtended: Map<string, TextColorKey>;

export declare const confluenceInlineComment: MarkSpec;

export declare const confluenceJiraIssue: NodeSpec;

declare interface ConfluenceLinkMetadata {
  linkType: string;
  versionAtSave?: string | null;
  fileName?: string | null;
  spaceKey?: string | null;
  contentTitle?: string | null;
  isRenamedTitle?: boolean;
  anchorName?: string | null;
  contentId?: string | null;
  container?: ConfluenceLinkMetadata;
}

export declare const confluenceUnsupportedBlock: NodeSpec;

export declare const confluenceUnsupportedInline: NodeSpec;

export declare const copyPrivateMediaAttributes: (
  from: Record<string, any>,
  to: Record<string, any>,
  map?: ((str: string) => string) | undefined,
) => void;

/**
 * Creates a schema preserving order of marks and nodes.
 */
export declare function createSchema<
  N extends string = string,
  M extends string = string
>(config: SchemaConfig<N, M>): Schema<N, M>;

export declare const dataConsumer: MarkSpec;

export declare interface DataConsumerAttributes {
  /**
   * @minItems 1
   */
  sources: Array<DataConsumerSource>;
}

/**
 * @name dataConsumer_mark
 * @description This mark is used for metadata surrounding a node consuming data
 * from a given source node
 */
export declare interface DataConsumerDefinition {
  type: 'dataConsumer';
  attrs: DataConsumerAttributes;
}

/**
 * This annotation is purely for reference, & does _nothing_ given annotating
 * `minLength` on an array of strings is not supported with our schema+spec
 * generator.
 *
 * We're keeping it to signal that data consumer `sources` shouldn't be empty
 * strings
 *
 * // @minLength 1
 */
declare type DataConsumerSource = string;

/**
 * We want to ensure any "invalid ADF" doesn't get serialised, but the entire
 * mark itself is not valid without a non-empty `sources`.
 *
 * We _almost could_ simply return `null` if sources length is < 0 & would fit
 * the type signature of prosemirror-model's `fragment` but not `mark`'s toJSON.
 *
 * So we'll leave any extra transformation checks in
 * `editor-json-transformer`(?)
 */
export declare const dataConsumerToJSON: (
  mark: Mark,
) => {
  type: string;
  attrs: {
    [key: string]: any;
  };
};

export declare interface DataType {
  /**
   * @additionalProperties true
   */
  data: object;
}

export declare const date: NodeSpec;

/**
 * @name date_node
 */
export declare interface DateDefinition {
  type: 'date';
  attrs: {
    /**
     * @minLength 1
     */
    timestamp: string;
  };
}

export declare const decisionItem: NodeSpec;

/**
 * @name decisionItem_node
 */
export declare interface DecisionItemDefinition {
  type: 'decisionItem';
  /**
   * @allowUnsupportedInline true
   */
  content?: Array<Inline>;
  attrs: {
    localId: string;
    state: string;
  };
}

export declare const decisionList: NodeSpec;

/**
 * @name decisionList_node
 */
export declare interface DecisionListDefinition {
  type: 'decisionList';
  /**
   * @minItems 1
   * @allowUnsupportedBlock true
   */
  content: Array<DecisionItemDefinition>;
  attrs: {
    localId: string;
  };
}

export declare const decisionListSelector: string;

export declare const doc: NodeSpec;

/**
 * @name doc_node
 */
export declare interface DocNode {
  version: 1;
  type: 'doc';
  /**
   * @allowUnsupportedBlock true
   */
  content: Array<
    | BlockContent
    | LayoutSectionDefinition
    | CodeBlockWithMarksDefinition
    | ExpandWithBreakoutDefinition
    | ParagraphWithIndentationDefinition
  >;
}

export declare const em: MarkSpec;

export declare const embedCard: NodeSpec;

export declare interface EmbedCardAttributes extends RichMediaAttributes {
  originalWidth?: number;
  originalHeight?: number;
  /**
   * @validatorFn safeUrl
   */
  url: string;
}

/**
 * @name embedCard_node
 */
export declare interface EmbedCardDefinition {
  type: 'embedCard';
  attrs: EmbedCardAttributes;
}

/**
 * @name em_mark
 */
export declare interface EmDefinition {
  type: 'em';
}

export declare const emoji: NodeSpec;

export declare interface EmojiAttributes {
  id?: string;
  shortName: string;
  text?: string;
}

/**
 * @name emoji_node
 */
export declare interface EmojiDefinition {
  type: 'emoji';
  attrs: EmojiAttributes;
}

export declare function emojiIdToAcName(emojiId: string): never;

export declare const expand: NodeSpec;

/**
 * @name expand_node
 */
declare interface ExpandBaseDefinition {
  type: 'expand';
  attrs: {
    title?: string;
  };
  /**
   * @minItems 1
   * @allowUnsupportedBlock true
   */
  content: Array<NonNestableBlockContent>;
  marks?: Array<any>;
}

/**
 * @name expand_with_no_mark_node
 */
export declare type ExpandDefinition = ExpandBaseDefinition & NoMark;

export declare const expandToJSON: (
  node: Node_2,
) => {
  attrs: {
    [key: string]: any;
  };
};

/**
 * @name expand_with_breakout_mark_node
 */
declare type ExpandWithBreakoutDefinition = ExpandBaseDefinition &
  MarksObject<BreakoutMarkDefinition>;

export declare const extension: NodeSpec;

declare interface ExtensionAttributes {
  /**
   * @minLength 1
   */
  extensionKey: string;
  /**
   * @minLength 1
   */
  extensionType: string;
  parameters?: object;
  text?: string;
  layout?: ExtensionLayout;
  /**
   * @minLength 1
   */
  localId?: string;
}

/**
 * @name extension_node
 */
declare interface ExtensionBaseDefinition {
  type: 'extension';
  attrs: ExtensionAttributes;
  marks?: Array<any>;
}

/**
 * @name extension_with_marks_node
 */
export declare type ExtensionDefinition = ExtensionBaseDefinition &
  MarksObject<DataConsumerDefinition | FragmentDefinition>;

export declare type ExtensionLayout = 'default' | 'wide' | 'full-width';

export declare interface ExternalMediaAttributes {
  type: 'external';
  url: string;
  alt?: string;
  width?: number;
  height?: number;
  __external?: boolean;
}

export declare const fragment: MarkSpec;

export declare interface FragmentAttributes {
  /**
   * @minLength 1
   */
  localId: LocalId;
  name?: string;
}

/**
 * @name fragment_mark
 * @description Indicates that the elements decorated with this mark belong to a "fragment" entity, which represents a collection of ADF nodes.
 * This entity can be referred to later by its `localId` attribute.
 */
export declare interface FragmentDefinition {
  type: 'fragment';
  attrs: FragmentAttributes;
}

export declare const fragmentToJSON: (
  mark: Mark,
) => {
  type: string;
  attrs: {
    name?: any;
    localId: any;
  };
};

export declare const G200 = '#57D9A3';

export declare const G300 = '#36B37E';

export declare const G400 = '#00875A';

export declare const G50 = '#E3FCEF';

export declare const G500 = '#006644';

export declare const G75 = '#ABF5D1';

export declare const generateUuid: () => string;

export declare const getCellAttrs: (
  dom: HTMLElement,
  defaultValues?: CellAttributes,
) => {
  colspan: number;
  rowspan: number;
  colwidth: number[] | null;
  background: string | null;
};

/**
 * gets cell dom attributes based on node attributes
 * @returns CellDomAttrs
 */
export declare const getCellDomAttrs: (node: Node_2) => CellDomAttrs;

export declare function getEmojiAcName({
  id,
  shortName,
}: {
  id: string;
  shortName: string;
}): string;

export declare function getLinkMatch(str?: string): Match | null;

export declare const hardBreak: NodeSpec;

/**
 * @name hardBreak_node
 */
export declare interface HardBreakDefinition {
  type: 'hardBreak';
  attrs?: {
    text?: '\n';
  };
}

export declare const heading: NodeSpec;

/**
 * @name heading_node
 */
export declare interface HeadingBaseDefinition {
  type: 'heading';
  /**
   * @allowUnsupportedInline true
   */
  content?: Array<Inline>;
  marks?: Array<any>;
  attrs: {
    /**
     * @minimum 1
     * @maximum 6
     */
    level: number;
  };
}

/**
 * @name heading_with_no_marks_node
 */
export declare type HeadingDefinition = HeadingBaseDefinition & NoMark;

/**
 * @name heading_with_alignment_node
 */
export declare type HeadingWithAlignmentDefinition = HeadingBaseDefinition &
  MarksObject<AlignmentMarkDefinition>;

/**
 * @name heading_with_indentation_node
 */
export declare type HeadingWithIndentationDefinition = HeadingBaseDefinition &
  MarksObject<IndentationMarkDefinition>;

export declare type HeadingWithMarksDefinition =
  | HeadingWithAlignmentDefinition
  | HeadingWithIndentationDefinition;

/**
 * Converts hex color format to rgb.
 * Works well with full hex color format and shortcut as well.
 *
 * @param hex - hex color string (#xxx, or #xxxxxx)
 */
export declare function hexToRgb(color: string): string | null;

/**
 * Converts hex color format to rgba.
 *
 * @param hex - hex color string (#xxx, or #xxxxxx)
 */
export declare function hexToRgba(
  rawColor: string,
  alpha: number,
): string | null;

export declare const image: NodeSpec;

export declare const indentation: MarkSpec;

export declare interface IndentationMarkAttributes {
  /**
   * @minimum 1
   * @maximum 6
   */
  level: number;
}

/**
 * @name indentation_mark
 */
export declare interface IndentationMarkDefinition {
  type: 'indentation';
  attrs: IndentationMarkAttributes;
}

/**
 * @name inline_node
 */
export declare type Inline = InlineFormattedText | InlineCode | InlineAtomic;

/**
 * @name atomic_inline_node
 */
export declare type InlineAtomic =
  | HardBreakDefinition
  | MentionDefinition
  | EmojiDefinition
  | InlineExtensionDefinition
  | DateDefinition
  | PlaceholderDefinition
  | InlineCardDefinition
  | StatusDefinition
  | MediaInlineDefinition;

export declare const inlineCard: NodeSpec;

/**
 * @name inlineCard_node
 */
export declare interface InlineCardDefinition {
  type: 'inlineCard';
  attrs: CardAttributes;
}

/**
 * @name code_inline_node
 */
export declare type InlineCode = TextDefinition &
  MarksObject<CodeDefinition | LinkDefinition | AnnotationMarkDefinition>;

export declare const inlineExtension: NodeSpec;

declare interface InlineExtensionAttributes {
  /**
   * @minLength 1
   */
  extensionKey: string;
  /**
   * @minLength 1
   */
  extensionType: string;
  parameters?: object;
  text?: string;
  /**
   * @minLength 1
   */
  localId?: string;
}

/**
 * @name inlineExtension_node
 */
declare interface InlineExtensionBaseDefinition {
  type: 'inlineExtension';
  attrs: InlineExtensionAttributes;
  marks?: Array<any>;
}

/**
 * @name inlineExtension_with_marks_node
 */
export declare type InlineExtensionDefinition = InlineExtensionBaseDefinition &
  MarksObject<DataConsumerDefinition | FragmentDefinition>;

/**
 * @name formatted_text_inline_node
 */
export declare type InlineFormattedText = TextDefinition &
  MarksObject<
    | LinkDefinition
    | EmDefinition
    | StrongDefinition
    | StrikeDefinition
    | SubSupDefinition
    | UnderlineDefinition
    | TextColorDefinition
    | AnnotationMarkDefinition
  >;

/**
 * @name link_text_inline_node
 */
export declare type InlineLinkText = TextDefinition &
  MarksObject<LinkDefinition>;

export declare const inlineNodes: Set<string>;

export declare function isHex(color: string): boolean;

export declare function isRgb(color: string): boolean;

/**
 * Please notify the Editor Mobile team (Slack: #help-mobilekit) if the logic for this changes.
 */
export declare const isSafeUrl: (url: string) => boolean;

export declare const layoutColumn: NodeSpec;

/**
 * @name layoutColumn_node
 */
export declare interface LayoutColumnDefinition {
  type: 'layoutColumn';
  attrs: {
    /**
     * @minimum 0
     * @maximum 100
     */
    width: number;
  };
  /**
   * @minItems 1
   * @allowUnsupportedBlock true
   */
  content: Array<BlockContent>;
}

export declare const layoutSection: NodeSpec;

/**
 * @name layoutSection_node
 */
declare type LayoutSectionBaseDefinition = {
  type: 'layoutSection';
  marks?: Array<BreakoutMarkDefinition>;
  content: Array<LayoutColumnDefinition>;
};

export declare type LayoutSectionDefinition =
  | LayoutSectionFullDefinition
  | LayoutSectionWithSingleColumnDefinition;

/**
 * Need duplicate `type` and `marks` to make both validator and json-schema satisfied
 */
/**
 * @name layoutSection_full_node
 */
export declare type LayoutSectionFullDefinition = LayoutSectionBaseDefinition & {
  type: 'layoutSection';
  marks?: Array<BreakoutMarkDefinition>;
  /**
   * @minItems 2
   * @maxItems 3
   * @allowUnsupportedBlock true
   */
  content: Array<LayoutColumnDefinition>;
};

/**
 * @stage 0
 * @name layoutSection_with_single_column_node
 */
export declare type LayoutSectionWithSingleColumnDefinition = LayoutSectionBaseDefinition & {
  type: 'layoutSection';
  marks?: Array<BreakoutMarkDefinition>;
  /**
   * @minItems 1
   * @maxItems 3
   * @allowUnsupportedBlock true
   */
  content: Array<LayoutColumnDefinition>;
};

export declare const link: MarkSpec;

export declare interface LinkAttributes {
  /**
   * @validatorFn safeUrl
   */
  href: string;
  title?: string;
  id?: string;
  collection?: string;
  occurrenceKey?: string;
  __confluenceMetadata?: ConfluenceLinkMetadata;
}

/**
 * @name link_mark
 */
export declare interface LinkDefinition {
  type: 'link';
  attrs: LinkAttributes;
}

export declare const linkify: LinkifyIt.LinkifyIt;

export declare const linkifyMatch: (text: string) => Match[];

export declare const linkToJSON: (
  mark: Mark,
) => {
  type: string;
  attrs: Record<string, string>;
};

export declare const listItem: NodeSpec;

export declare interface ListItemArray
  extends Array<
    | ParagraphDefinition
    | OrderedListDefinition
    | BulletListDefinition
    | MediaSingleDefinition
    | CodeBlockDefinition
  > {
  0: ParagraphDefinition | MediaSingleDefinition | CodeBlockDefinition;
}

/**
 * @name listItem_node
 */
export declare interface ListItemDefinition {
  type: 'listItem';
  /**
   * @minItems 1
   */
  content: ListItemArray;
}

declare type LocalId = string;

/**
 * @additionalProperties true
 */
export declare interface MarksObject<T> {
  marks?: Array<T>;
}

export declare interface Match {
  schema: any;
  index: number;
  lastIndex: number;
  raw: string;
  text: string;
  url: string;
  length?: number;
  input?: string;
}

export declare const media: NodeSpec;

export declare type MediaADFAttrs = MediaAttributes | ExternalMediaAttributes;

export declare interface MediaAttributes extends MediaBaseAttributes {
  type: 'file' | 'link';
}

export declare interface MediaBaseAttributes {
  /**
   * @minLength 1
   */
  id: string;
  collection: string;
  height?: number;
  width?: number;
  /**
   * @minLength 1
   */
  occurrenceKey?: string;
  alt?: string;
  __fileName?: string | null;
  __fileSize?: number | null;
  __fileMimeType?: string | null;
  __displayType?: MediaDisplayType | null;
  __contextId?: string | null;
  __external?: boolean;
}

/**
 * @additionalProperties true
 */
declare interface MediaCaptionContent {
  /**
   * @minItems 1
   * @maxItems 2
   * @allowUnsupportedBlock true
   */
  content: [MediaDefinition, CaptionDefinition?];
}

/**
 * @name media_node
 */
export declare interface MediaDefinition {
  type: 'media';
  /**
   * @minItems 1
   */
  attrs: MediaADFAttrs;
  marks?: Array<LinkDefinition>;
}

export declare type MediaDisplayType = 'file' | 'thumbnail';

export declare const mediaGroup: NodeSpec;

/**
 * @name mediaGroup_node
 */
export declare interface MediaGroupDefinition {
  type: 'mediaGroup';
  /**
   * @minItems 1
   *  @allowUnsupportedBlock true
   */
  content: Array<MediaDefinition>;
}

export declare const mediaInline: NodeSpec;

export declare interface MediaInlineAttributes extends MediaBaseAttributes {
  data?: object;
  type?: 'file' | 'link';
}

/**
 * @name mediaInline_node
 */
export declare interface MediaInlineDefinition {
  type: 'mediaInline';
  attrs: MediaInlineAttributes;
  marks?: Array<LinkDefinition>;
}

export declare const mediaSingle: NodeSpec;

/**
 * @name mediaSingle_node
 * @additionalProperties true
 */
declare interface MediaSingleBaseDefinition {
  type: 'mediaSingle';
  attrs?: RichMediaAttributes;
  marks?: Array<LinkDefinition>;
}

export declare type MediaSingleDefinition =
  | MediaSingleFullDefinition
  | MediaSingleWithCaptionDefinition;

/**
 * @additionalProperties true
 */
declare interface MediaSingleFullContent {
  /**
   * @minItems 1
   * @maxItems 1
   * @allowUnsupportedBlock true
   */
  content: Array<MediaDefinition>;
}

/**
 * @name mediaSingle_full_node
 */
declare type MediaSingleFullDefinition = MediaSingleBaseDefinition &
  MediaSingleFullContent;

export declare const mediaSingleToJSON: (
  node: Node_2,
) => {
  attrs: any;
};

export declare const mediaSingleWithCaption: NodeSpec;

/**
 * @name mediaSingle_caption_node
 */
declare type MediaSingleWithCaptionDefinition = MediaSingleBaseDefinition &
  MediaCaptionContent;

export declare const mediaToJSON: (
  node: Node_2,
) => {
  attrs: Record<string, any>;
};

export declare type MediaType = 'file' | 'link' | 'external';

export declare const mention: NodeSpec;

export declare interface MentionAttributes {
  id: string;
  text?: string;
  userType?: MentionUserType;
  accessLevel?: string;
}

/**
 * @name mention_node
 */
export declare interface MentionDefinition {
  type: 'mention';
  attrs: MentionAttributes;
}

export declare const mentionToJSON: (
  node: Node_2,
) => {
  attrs: {
    [key: string]: any;
  };
};

export declare type MentionUserType = keyof typeof USER_TYPES;

export declare const N0 = '#FFFFFF';

export declare const N20 = '#F4F5F7';

export declare const N200 = '#6B778C';

export declare const N30 = '#EBECF0';

export declare const N300 = '#5E6C84';

export declare const N40 = '#DFE1E6';

export declare const N50 = '#C1C7D0';

export declare const N500 = '#42526E';

export declare const N60 = '#B3BAC5';

export declare const N80 = '#97A0AF';

export declare const N800 = '#172B4D';

export declare const N90 = '#8993A4';

export declare type NameToEmoji = keyof typeof acNameToEmojiMap;

export declare const nestedExpand: NodeSpec;

/**
 * @name nestedExpand_node
 */
declare interface NestedExpandBaseDefinition {
  type: 'nestedExpand';
  attrs: {
    title?: string;
  };
  content: NestedExpandContent;
}

/**
 * @name nestedExpand_content
 * @minItems 1
 * @allowUnsupportedBlock true
 */
export declare type NestedExpandContent = Array<
  | ParagraphDefinition
  | HeadingDefinition
  | MediaSingleDefinition
  | MediaGroupDefinition
>;

/**
 * @name nestedExpand_with_no_marks_node
 */
export declare type NestedExpandDefinition = NestedExpandBaseDefinition &
  NoMark;

/**
 * @additionalProperties true
 */
export declare interface NoMark {
  /**
   * @maxItems 0
   */
  marks?: Array<any>;
}

/**
 * @name non_nestable_block_content
 */
export declare type NonNestableBlockContent =
  | PanelDefinition
  | ParagraphDefinition
  | BlockQuoteDefinition
  | OrderedListDefinition
  | BulletListDefinition
  | RuleDefinition
  | HeadingDefinition
  | CodeBlockDefinition
  | MediaGroupDefinition
  | MediaSingleDefinition
  | DecisionListDefinition
  | TaskListDefinition
  | TableDefinition
  | ExtensionDefinition
  | BlockCardDefinition
  | EmbedCardDefinition;

/**
 * @return String with HEX-coded color
 */
export declare function normalizeHexColor(
  color: string | null,
  defaultColor?: string,
): string | null;

/**
 * Adds protocol to url if needed.
 */
export declare function normalizeUrl(url?: string): string;

export declare const orderedList: NodeSpec;

/**
 * @name orderedList_node
 */
export declare interface OrderedListDefinition {
  type: 'orderedList';
  /**
   * @minItems 1
   */
  content: Array<ListItemDefinition>;
  attrs?: {
    /**
     * @minimum 1
     */
    order: number;
  };
}

export declare const orderedListSelector = '.ak-ol';

export declare const P100 = '#998DD9';

export declare const P300 = '#6554C0';

export declare const P400 = '#5243AA';

export declare const P50 = '#EAE6FF';

export declare const P500 = '#403294';

export declare const P75 = '#C0B6F2';

export declare const panel: (allowCustomPanel: boolean) => NodeSpec;

export declare interface PanelAttributes {
  panelType: PanelType;
  panelIcon?: string;
  panelIconId?: string;
  panelIconText?: string;
  panelColor?: string;
}

/**
 * @name panel_node
 */
export declare interface PanelDefinition {
  type: 'panel';
  attrs: PanelAttributes;
  /**
   * @minItems 1
   * @allowUnsupportedBlock true
   */
  content: Array<
    | ParagraphDefinition
    | HeadingDefinition
    | OrderedListDefinition
    | BulletListDefinition
    | BlockCardDefinition
  >;
}

export declare enum PanelType {
  INFO = 'info',
  NOTE = 'note',
  TIP = 'tip',
  WARNING = 'warning',
  ERROR = 'error',
  SUCCESS = 'success',
  CUSTOM = 'custom',
}

export declare const paragraph: NodeSpec;

/**
 * @name paragraph_node
 */
export declare interface ParagraphBaseDefinition {
  type: 'paragraph';
  /**
   * @allowUnsupportedInline true
   */
  content?: Array<Inline>;
  marks?: Array<any>;
}

/**
 * @name paragraph_with_no_marks_node
 */
export declare type ParagraphDefinition = ParagraphBaseDefinition & NoMark;

/**
 * NOTE: Need this because TS is too smart and inline everything.
 * So we need to give them separate identity.
 * Probably there's a way to solve it but that will need time and exploration.
 * // http://bit.ly/2raXFX5
 * type T1 = X | Y
 * type T2 = A | T1 | B // T2 = A | X | Y | B
 */
/**
 * @name paragraph_with_alignment_node
 */
export declare type ParagraphWithAlignmentDefinition = ParagraphBaseDefinition &
  MarksObject<AlignmentMarkDefinition>;

/**
 * @name paragraph_with_indentation_node
 */
export declare type ParagraphWithIndentationDefinition = ParagraphBaseDefinition &
  MarksObject<IndentationMarkDefinition>;

export declare type ParagraphWithMarksDefinition =
  | ParagraphWithAlignmentDefinition
  | ParagraphWithIndentationDefinition;

export declare const placeholder: NodeSpec;

/**
 * @name placeholder_node
 */
export declare interface PlaceholderDefinition {
  type: 'placeholder';
  attrs: {
    text: string;
  };
}

export declare const R100 = '#FF8F73';

export declare const R300 = '#FF5630';

export declare const R400 = '#DE350B';

/**
 * We're avoding importing these colors from @atlaskit/theme since we
 * do not want to have react as a dependency of this package.
 * TODO: Refactor this once tokenization by Core team is ready
 * https://product-fabric.atlassian.net/browse/CS-908
 */
export declare const R50 = '#FFEBE6';

export declare const R500 = '#BF2600';

export declare const R75 = '#FFBDAD';

export declare function rgbToHex(value: string): string | null;

export declare interface RichMediaAttributes {
  /**
   * @minimum 0
   * @maximum 100
   */
  width?: number;
  layout: RichMediaLayout;
}

export declare type RichMediaLayout =
  | 'wrap-right'
  | 'center'
  | 'wrap-left'
  | 'wide'
  | 'full-width'
  | 'align-end'
  | 'align-start';

export declare const rule: NodeSpec;

/**
 * @name rule_node
 */
export declare interface RuleDefinition {
  type: 'rule';
}

export declare function sanitizeNodes(
  nodes: {
    [key: string]: NodeSpec;
  },
  supportedMarks: {
    [key: string]: MarkSpec;
  },
): {
  [key: string]: NodeSpec;
};

declare interface SchemaConfig<N = string, M = string> {
  nodes: N[];
  customNodeSpecs?: SchemaCustomNodeSpecs;
  marks?: M[];
  customMarkSpecs?: SchemaCustomMarkSpecs;
}

declare interface SchemaCustomMarkSpecs {
  [name: string]: MarkSpec;
}

declare interface SchemaCustomNodeSpecs {
  [name: string]: NodeSpec;
}

declare const status_2: NodeSpec;
export { status_2 as status };

/**
 * @name status_node
 */
export declare interface StatusDefinition {
  type: 'status';
  attrs: {
    /**
     * @minLength 1
     */
    text: string;
    color: 'neutral' | 'purple' | 'blue' | 'red' | 'yellow' | 'green';
    localId?: string;
    /**
     * Supported values are bold and subtle
     */
    style?: string;
  };
}

export declare const strike: MarkSpec;

/**
 * @name strike_mark
 */
export declare interface StrikeDefinition {
  type: 'strike';
}

export declare const strong: MarkSpec;

/**
 * @name strong_mark
 */
export declare interface StrongDefinition {
  type: 'strong';
}

export declare const subsup: MarkSpec;

export declare interface SubSupAttributes {
  type: 'sub' | 'sup';
}

/**
 * @name subsup_mark
 */
export declare interface SubSupDefinition {
  type: 'subsup';
  attrs: SubSupAttributes;
}

export declare const T100 = '#79E2F2';

export declare const T300 = '#00B8D9';

export declare const T50 = '#E6FCFF';

export declare const T500 = '#008DA6';

export declare const T75 = '#B3F5FF';

export declare const table: NodeSpec;

export declare interface TableAttributes {
  isNumberColumnEnabled?: boolean;
  layout?: TableLayout;
  __autoSize?: boolean;
  /**
   * @minLength 1
   */
  localId?: string;
}

export declare const tableBackgroundBorderColor: string;

export declare const tableBackgroundColorNames: Map<string, string>;

export declare const tableBackgroundColorPalette: Map<string, string>;

export declare const tableCell: NodeSpec;

/**
 * @name table_cell_content
 * @minItems 1
 * @allowUnsupportedBlock true
 */
declare type TableCellContent = Array<
  | PanelDefinition
  | ParagraphDefinition
  | ParagraphWithAlignmentDefinition
  | BlockQuoteDefinition
  | OrderedListDefinition
  | BulletListDefinition
  | RuleDefinition
  | HeadingDefinition
  | HeadingWithMarksDefinition
  | CodeBlockDefinition
  | MediaGroupDefinition
  | MediaSingleDefinition
  | DecisionListDefinition
  | TaskListDefinition
  | ExtensionDefinition
  | BlockCardDefinition
  | NestedExpandDefinition
  | EmbedCardDefinition
>;

export declare const tableCellContentDomSelector: string;

export declare const tableCellContentWrapperSelector: string;

/**
 * @name table_cell_node
 */
export declare interface TableCellDefinition {
  type: 'tableCell';
  attrs?: CellAttributes;
  content: TableCellContent;
}

export declare const tableCellSelector: string;

/**
 * @name table_node
 */
export declare interface TableDefinition {
  type: 'table';
  attrs?: TableAttributes;
  /**
   * @minItems 1
   */
  content: Array<TableRowDefinition>;
  marks?: Array<FragmentDefinition>;
}

export declare const tableHeader: NodeSpec;

/**
 * @name table_header_node
 */
export declare interface TableHeaderDefinition {
  type: 'tableHeader';
  attrs?: CellAttributes;
  content: TableCellContent;
}

export declare const tableHeaderSelector: string;

export declare type TableLayout = 'default' | 'full-width' | 'wide';

export declare const tablePrefixSelector = 'pm-table';

export declare const tableRow: NodeSpec;

/**
 * @name table_row_node
 */
export declare interface TableRowDefinition {
  type: 'tableRow';
  content: Array<TableHeaderDefinition | TableCellDefinition>;
}

export declare const tableToJSON: (
  node: Node_2,
) => {
  attrs: {
    [key: string]: any;
  };
};

export declare const taskItem: NodeSpec;

/**
 * @name taskItem_node
 */
export declare interface TaskItemDefinition {
  type: 'taskItem';
  /**
   * @allowUnsupportedInline true
   */
  content?: Array<Inline>;
  attrs: {
    localId: string;
    state: 'TODO' | 'DONE';
  };
}

export declare const taskList: NodeSpec;

export declare interface TaskListContent
  extends Array<TaskItemDefinition | TaskListDefinition> {
  0: TaskItemDefinition;
}

/**
 * @name taskList_node
 */
export declare interface TaskListDefinition {
  type: 'taskList';
  /**
   * @minItems 1
   * @allowUnsupportedBlock true
   */
  content: TaskListContent;
  attrs: {
    localId: string;
  };
}

export declare const taskListSelector: string;

export declare const text: NodeSpec & {
  toDebugString?: () => string;
};

export declare const textColor: MarkSpec;

export declare interface TextColorAttributes {
  /**
   * @pattern "^#[0-9a-fA-F]{6}$"
   */
  color: string;
}

/**
 * @name textColor_mark
 */
export declare interface TextColorDefinition {
  type: 'textColor';
  attrs: TextColorAttributes;
}

declare type TextColorKey =
  | 'Light gray'
  | 'Purple'
  | 'Teal'
  | 'Green'
  | 'Red'
  | 'Orange'
  | 'Dark gray'
  | 'Blue'
  | 'Yellow'
  | 'Dark blue'
  | 'Dark teal'
  | 'Dark green'
  | 'Dark red'
  | 'Dark purple'
  | 'White'
  | 'Light blue'
  | 'Light teal'
  | 'Light green'
  | 'Light yellow'
  | 'Light red'
  | 'Light purple';

/**
 * @name text_node
 */
export declare interface TextDefinition {
  type: 'text';
  /**
   * @minLength 1
   */
  text: string;
  marks?: Array<any>;
}

export declare const toJSONTableCell: (
  node: Node_2,
) => {
  attrs: Record<string, any>;
};

export declare const toJSONTableHeader: (
  node: Node_2,
) => {
  attrs: Record<string, any>;
};

export declare const typeAheadQuery: MarkSpec;

export declare const underline: MarkSpec;

/**
 * @name underline_mark
 */
export declare interface UnderlineDefinition {
  type: 'underline';
}

export declare const unknownBlock: NodeSpec;

export declare const unsupportedBlock: NodeSpec;

export declare const unsupportedInline: NodeSpec;

export declare const unsupportedMark: MarkSpec;

export declare const unsupportedNodeAttribute: MarkSpec;

export declare const unsupportedNodeTypesForMediaCards: Set<string>;

export declare interface UrlType {
  /**
   * @validatorFn safeUrl
   */
  url: string;
}

declare enum USER_TYPES {
  DEFAULT = 'DEFAULT',
  SPECIAL = 'SPECIAL',
  APP = 'APP',
}

export declare const uuid: {
  setStatic(value: string | false): void;
  generate(): string;
};

export declare const Y200 = '#FFC400';

export declare const Y400 = '#FF991F';

export declare const Y50 = '#FFFAE6';

export declare const Y500 = '#FF8B00';

export declare const Y75 = '#FFF0B3';

export {};
```
