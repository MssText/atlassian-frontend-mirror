## API Report File for "@atlaskit/email-renderer".

> Do not edit this file. This report is auto-generated by [API Extractor](https://api-extractor.com/).

[Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

```ts
import { Fragment } from 'prosemirror-model';
import { Mark } from 'prosemirror-model';
import { Node as Node_2 } from 'prosemirror-model';
import { Schema } from 'prosemirror-model';

export declare type Attrs = {
  [key: string]: string;
};

export declare const commonStyle: {
  'font-family': string;
  'font-size': string;
  'font-weight': number;
  'line-height': string;
};

export declare const createClassName: (name: string) => string;

export declare const CS_CONTENT_PREFIX = 'csg';

/**
 * EmailSerializer allows to disable/mock images via isImageStubEnabled flag.
 * The reason behind this is that in emails, images are embedded separately as inline attachemnts
 * and referenced via CID. However, when rendered in browser, this does not work and breaks the experience
 * when rendered in demo page, so we instead inline the image data.
 */
declare class EmailSerializer implements SerializerWithImages<string> {
  private schema;
  readonly opts: EmailSerializerOpts;
  private static readonly defaultOpts;
  constructor(schema?: Schema, opts?: Partial<EmailSerializerOpts>);
  serializeFragmentWithImages: (
    fragment: Fragment,
    context?: MetaDataContext | undefined,
  ) => SerializeFragmentWithAttachmentsResult;
  serializeFragment: (...args: any) => string;
  static fromSchema(
    schema?: Schema,
    opts?: Partial<EmailSerializerOpts>,
  ): EmailSerializer;
}
export { EmailSerializer };
export default EmailSerializer;

export declare interface EmailSerializerOpts {
  isImageStubEnabled: boolean;
  isInlineCSSEnabled: boolean;
}

export declare type MarkSerializer = (opts: MarkSerializerOpts) => string;

export declare interface MarkSerializerOpts {
  mark: Mark;
  text: string;
}

export declare const MEDIA_PREVIEW_IMAGE_HEIGHT = 108;

export declare const MEDIA_PREVIEW_IMAGE_WIDTH = 162;

declare type MediaImageBase64 = {
  contentId: string;
  contentType: string;
  data: string;
};

export declare interface MediaMetaDataContextItem {
  name: string;
  mediaType: MediaType;
  mimeType: string;
  size: number;
}

export declare type MediaType =
  | 'image'
  | 'doc'
  | 'video'
  | 'audio'
  | 'archive'
  | 'unknown';

export declare interface MetaDataContext {
  conversion?: {
    inlineCardConversion?: {
      [key: string]: string;
    };
  };
  hydration?: {
    mediaMetaData?: {
      [key: string]: MediaMetaDataContextItem;
    };
  };
}

export declare type NodeSerializer = (opts: NodeSerializerOpts) => string;

export declare interface NodeSerializerOpts {
  node: Node_2;
  attrs: {
    [key: string]: any;
  };
  marks: Mark[];
  text?: string | null;
  parent?: Node_2;
  context?: MetaDataContext;
}

declare interface ScData {
  '@type': string;
  generator: {
    '@type': string;
    name: string;
  };
  name: string;
  url: string;
  summary: string;
}

declare interface SerializeFragmentWithAttachmentsResult {
  result: string | null;
  embeddedImages: MediaImageBase64[];
}

declare interface Serializer<T> {
  serializeFragment(
    fragment: Fragment,
    props?: any,
    target?: any,
    key?: string,
  ): T | null;
}

declare interface SerializerWithImages<T> extends Serializer<T> {
  serializeFragmentWithImages(
    fragment: Fragment,
    props?: any,
    target?: any,
    key?: string,
  ): SerializeFragmentWithAttachmentsResult | null;
}

export declare interface SmartCardWithDataAttributes {
  data: ScData;
}

export declare interface SmartCardWithUrlAttributes {
  url: string;
}

export declare type Style = {
  [key: string]: string | number | undefined;
};

export {};
```
