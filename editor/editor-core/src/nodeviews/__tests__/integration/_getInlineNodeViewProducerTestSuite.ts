import { BrowserTestCase } from '@atlaskit/webdriver-runner/runner';
import { BrowserObject } from '@atlaskit/webdriver-runner/wd-wrapper';
import {
  goToEditorTestingWDExample,
  mountEditor,
} from '../../../__tests__/__helpers/testing-example-helpers';

import {
  fullpage,
  expectToMatchSelection,
  setProseMirrorTextSelection,
  SelectionMatch,
} from '../../../__tests__/integration/_helpers';
import { WebDriverPage } from '../../../__tests__/__helpers/page-objects/_types';

import {
  keyboardSelectLineFromLineEnd,
  clickAndDragSelectLineFromLineEnd,
  buildAdf,
  keyboardSelectLineFromLineStart,
} from '../__helpers/_getInlineNodeViewProducer';
import { DocBuilder } from '@atlaskit/editor-test-helpers/doc-builder';

export async function runInlineNodeViewTestSuite({
  nodeName,
  editorOptions,
  node,
  multiLineNode,
}: {
  nodeName: string;
  editorOptions?: { [key: string]: any };
  node: DocBuilder;
  multiLineNode: boolean;
}) {
  describe(`NodeView Producer test suite [${nodeName}]: `, () => {
    // The ADF is generated by the test suite to enforce a structure
    // where we have three of the same inline node view within a paragraph.
    // Tests that use the LAST_NODE_SELECTOR also wait
    // for the selector to be ready before proceeding.
    const LAST_NODE_SELECTOR = `.ProseMirror p:nth-child(1) .${nodeName}View-content-wrap:nth-child(3)`;

    const initEditor = async ({
      client,
      selection,
      trailingSpaces,
      multiLineNode = false,
    }: {
      client: BrowserObject;
      selection: { anchor: number; head: number };
      trailingSpaces: boolean;
      multiLineNode?: boolean;
    }): Promise<WebDriverPage> => {
      const page = await goToEditorTestingWDExample(client);
      const adf = await buildAdf({ node, trailingSpaces, multiLineNode });
      // Allow tables here for multiline nodes tests that use a table
      // cell to force the node to break across lines
      const props = {
        appearance: fullpage.appearance,
        defaultValue: adf,
        allowTables: true,
        allowAdvancedTables: true,
        ...editorOptions,
      };

      await mountEditor(page, props, undefined, { clickInEditor: false });
      // clicking paragraphs to set selection was causing flaky results
      await setProseMirrorTextSelection(page, selection);
      // clear any modifier keys in chrome
      if (page.isBrowser('chrome')) {
        await page.keys(['NULL']);
      }

      return page;
    };

    describe(`[${nodeName}] with trailing spaces`, () => {
      BrowserTestCase(
        `Extend a selection to the start of the current line from the current position`,
        {},
        async (client: BrowserObject) => {
          const page = await initEditor({
            client,
            selection: { anchor: 7, head: 7 },
            trailingSpaces: true,
          });
          await page.waitForSelector(LAST_NODE_SELECTOR);
          await keyboardSelectLineFromLineEnd(page);
          await expectToMatchSelection(page, {
            type: 'text',
            anchor: 7,
            head: 1,
          });
        },
      );
      BrowserTestCase(
        `Extend a selection to the end of the current line from the current position`,
        {},
        async (client: BrowserObject) => {
          const page = await initEditor({
            client,
            selection: { anchor: 1, head: 1 },
            trailingSpaces: true,
          });
          await page.waitForSelector(LAST_NODE_SELECTOR);
          await keyboardSelectLineFromLineStart(page);
          await expectToMatchSelection(page, {
            type: 'text',
            anchor: 1,
            head: 7,
          });
        },
      );
      BrowserTestCase(
        `Can click and drag to extend a selection to the start of the current line from the current position`,
        {},
        async (client: BrowserObject) => {
          const page = await initEditor({
            client,
            selection: { anchor: 7, head: 7 },
            trailingSpaces: true,
          });
          await page.waitForSelector(LAST_NODE_SELECTOR);
          await clickAndDragSelectLineFromLineEnd({
            page,
            selector: LAST_NODE_SELECTOR,
          });
          await expectToMatchSelection(page, {
            type: 'text',
            anchor: 7,
            head: 1,
          });
        },
      );
      BrowserTestCase(
        `Can select [${nodeName}] nodes with the left arrow key and move across them`,
        {},
        async (client: BrowserObject) => {
          const page = await initEditor({
            client,
            selection: { anchor: 7, head: 7 },
            trailingSpaces: true,
          });
          const expectedSelections: SelectionMatch[] = [
            { type: 'text', from: 6 },
            { type: 'node', from: 5 },
            { type: 'text', from: 5 },
            { type: 'text', from: 4 },
            { type: 'node', from: 3 },
            { type: 'text', from: 3 },
            { type: 'text', from: 2 },
            { type: 'node', from: 1 },
            { type: 'text', from: 1 },
          ];
          for (const selection of expectedSelections) {
            await page.keys(['ArrowLeft']);
            await expectToMatchSelection(page, selection);
          }
        },
      );
      BrowserTestCase(
        `Can select [${nodeName}] nodes with the right arrow key and move across them`,
        {},
        async (client: BrowserObject) => {
          const page = await initEditor({
            client,
            selection: { anchor: 1, head: 1 },
            trailingSpaces: true,
          });
          const expectedSelections: SelectionMatch[] = [
            { type: 'node', from: 1 },
            { type: 'text', from: 2 },
            { type: 'text', from: 3 },
            { type: 'node', from: 3 },
            { type: 'text', from: 4 },
            { type: 'text', from: 5 },
            { type: 'node', from: 5 },
            { type: 'text', from: 6 },
          ];
          for (const selection of expectedSelections) {
            await page.keys(['ArrowRight']);
            await expectToMatchSelection(page, selection);
          }
        },
      );
    });

    describe(`[${nodeName}] with no trailing spaces`, () => {
      BrowserTestCase(
        `No trailing spaces: Extend a selection to the start of the current line from the current position`,
        {},
        async (client: BrowserObject) => {
          const page = await initEditor({
            client,
            selection: { anchor: 4, head: 4 },
            trailingSpaces: false,
          });
          await page.waitForSelector(LAST_NODE_SELECTOR);

          await keyboardSelectLineFromLineEnd(page);

          await expectToMatchSelection(page, {
            type: 'text',
            anchor: 4,
            head: 1,
          });
        },
      );

      BrowserTestCase(
        `No trailing spaces: Extend a selection to the end of the current line from the current position`,
        {},
        async (client: BrowserObject) => {
          const page = await initEditor({
            client,
            selection: { anchor: 1, head: 1 },
            trailingSpaces: false,
          });
          await page.waitForSelector(LAST_NODE_SELECTOR);

          await keyboardSelectLineFromLineStart(page);

          await expectToMatchSelection(page, {
            type: 'text',
            anchor: 1,
            head: 4,
          });
        },
      );

      //TODO Fix this test for Chrome
      // Click and drag via the test is currently not working as expected for
      // multiline nodes in Chrome however click and drag works when manually
      // testing in the browser. This test also fails for multiline nodes
      // that have not been created via getInlineNodeViewProducer()
      BrowserTestCase(
        `No trailing spaces: Can click and drag to extend a selection to the start of the current line from the current position`,
        { skip: multiLineNode ? ['chrome'] : [] },
        async (client: BrowserObject) => {
          const page = await initEditor({
            client,
            selection: { anchor: 4, head: 4 },
            trailingSpaces: false,
          });
          await page.waitForSelector(LAST_NODE_SELECTOR);

          await clickAndDragSelectLineFromLineEnd({
            page,
            selector: LAST_NODE_SELECTOR,
          });

          await expectToMatchSelection(page, {
            type: 'text',
            anchor: 4,
            head: 1,
          });
        },
      );

      BrowserTestCase(
        `No trailing spaces: Can select [${nodeName}] nodes with the left arrow key and move across them`,
        {},
        async (client: BrowserObject) => {
          const page = await initEditor({
            client,
            selection: { anchor: 4, head: 4 },
            trailingSpaces: false,
          });

          const expectedSelections: SelectionMatch[] = [
            { type: 'node', from: 3 },
            { type: 'text', from: 3 },
            { type: 'node', from: 2 },
            { type: 'text', from: 2 },
            { type: 'node', from: 1 },
            { type: 'text', from: 1 },
          ];

          for (const selection of expectedSelections) {
            await page.keys(['ArrowLeft']);
            await expectToMatchSelection(page, selection);
          }
        },
      );

      BrowserTestCase(
        `No trailing spaces: Can select [${nodeName}] nodes with the right arrow key and move across them`,
        {},
        async (client: BrowserObject) => {
          const page = await initEditor({
            client,
            selection: { anchor: 1, head: 1 },
            trailingSpaces: false,
          });

          const expectedSelections: SelectionMatch[] = [
            { type: 'node', from: 1 },
            { type: 'text', from: 2 },
            { type: 'node', from: 2 },
            { type: 'text', from: 3 },
            { type: 'node', from: 3 },
            { type: 'text', from: 4 },
          ];

          for (const selection of expectedSelections) {
            await page.keys(['ArrowRight']);
            await expectToMatchSelection(page, selection);
          }
        },
      );

      BrowserTestCase(
        `No trailing spaces: Can insert text directly after the last node view in the same paragraph`,
        {},
        async (client: BrowserObject) => {
          const page = await initEditor({
            client,
            selection: { anchor: 4, head: 4 },
            trailingSpaces: false,
          });
          await page.waitForSelector(LAST_NODE_SELECTOR);

          await page.keyboard.type('test', []);

          // See https://product-fabric.atlassian.net/browse/ED-12003
          await expectToMatchSelection(page, {
            type: 'text',
            anchor: 8,
            head: 8,
          });
        },
      );
    });

    if (multiLineNode) {
      describe(`Multiline ${nodeName} with no trailing spaces`, () => {
        const LAST_NODE_SELECTOR = `p .${nodeName}View-content-wrap:nth-child(3)`;

        BrowserTestCase(
          `Multiline node no trailing spaces: Extend a selection to the start of the current line from the current position`,
          {},
          async (client: BrowserObject) => {
            const page = await initEditor({
              client,
              selection: { anchor: 7, head: 7 },
              trailingSpaces: false,
              multiLineNode: true,
            });
            await page.waitForSelector(LAST_NODE_SELECTOR);

            await keyboardSelectLineFromLineEnd(page);

            // Currently, the behaviour for multiline inline node views is to
            // select the last node. This needs to be fixed eventually
            // but for now we just want to test that all multiline inline
            // node views have the same behaviour.
            await expectToMatchSelection(page, {
              type: 'text',
              anchor: 7,
              head: 6,
            });
          },
        );

        BrowserTestCase(
          `Multiline node no trailing spaces: Can insert text directly after the last node view in the same paragraph`,
          {},
          async (client: BrowserObject) => {
            const page = await initEditor({
              client,
              selection: { anchor: 7, head: 7 },
              trailingSpaces: false,
              multiLineNode: true,
            });
            await page.waitForSelector(LAST_NODE_SELECTOR);

            await page.keyboard.type('test', []);

            await expectToMatchSelection(page, {
              type: 'text',
              anchor: 11,
              head: 11,
            });
          },
        );
      });
    }
  });
}
