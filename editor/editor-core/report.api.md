## API Report File for "@atlaskit/editor-core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

````ts
/// <reference types="node" />
/// <reference types="react" />

import { AbstractMentionResource } from '@atlaskit/mention/resource';
import { ActivityProvider } from '@atlaskit/activity-provider';
import type { ADFEntityMark } from '@atlaskit/adf-utils/types';
import { AnalyticsEventPayload as AnalyticsEventPayload_2 } from '@atlaskit/analytics-next/AnalyticsEvent';
import { AnnotationTypes } from '@atlaskit/adf-schema';
import { CardOptions } from '@atlaskit/editor-common/card';
import { CardProvider } from '@atlaskit/editor-common/provider-factory';
import { CollabEditProvider } from '@atlaskit/editor-common/collab';
import { Color } from '@atlaskit/status/element';
import type { ContextIdentifierProvider } from '@atlaskit/editor-common/provider-factory';
import { CreateUIAnalyticsEvent } from '@atlaskit/analytics-next';
import { CreateUIAnalyticsEvent as CreateUIAnalyticsEvent_2 } from '@atlaskit/analytics-next/types';
import { DecorationSet } from 'prosemirror-view';
import { DirectEditorProps } from 'prosemirror-view';
import { EditorState } from 'prosemirror-state';
import { EditorView } from 'prosemirror-view';
import { EmojiId } from '@atlaskit/emoji/types';
import { EmojiResource } from '@atlaskit/emoji/resource';
import { ErrorReporter } from '@atlaskit/editor-common/utils';
import type { ErrorReportingHandler } from '@atlaskit/editor-common/utils';
import { EventEmitter } from 'events';
import { ExperienceStore } from '@atlaskit/editor-common/ufo';
import type { ExtensionHandlers } from '@atlaskit/editor-common/extensions';
import { ExtensionLayout } from '@atlaskit/adf-schema';
import type { ExtensionProvider } from '@atlaskit/editor-common/extensions';
import { ExtensionType } from '@atlaskit/editor-common/provider-factory';
import { Fragment } from 'prosemirror-model';
import { IntlShape } from 'react-intl-next';
import { JSONDocNode } from '@atlaskit/editor-json-transformer';
import { jsx } from '@emotion/react';
import { MacroAttributes } from '@atlaskit/editor-common/provider-factory';
import { MacroProvider } from '@atlaskit/editor-common/provider-factory';
import { Mapping } from 'prosemirror-transform';
import { MarkSpec } from 'prosemirror-model';
import { MediaClientConfig } from '@atlaskit/media-core';
import { MediaFeatureFlags } from '@atlaskit/media-common';
import { MediaFeatureFlags as MediaFeatureFlags_2 } from '@atlaskit/media-common/mediaFeatureFlags';
import { MediaFile } from '@atlaskit/media-picker/types';
import { MediaProvider as MediaProvider_2 } from '@atlaskit/editor-common/provider-factory';
import { MemoizedFn } from 'memoize-one';
import { MentionDescription } from '@atlaskit/mention';
import { MentionProvider } from '@atlaskit/mention/resource';
import { MentionProvider as MentionProvider_2 } from '@atlaskit/mention';
import { MentionResource } from '@atlaskit/mention/resource';
import { MessageDescriptor } from 'react-intl-next';
import { NewCollabSyncUpErrorAttributes } from '@atlaskit/editor-common/types';
import { Node as Node_2 } from 'prosemirror-model';
import { NodeSpec } from 'prosemirror-model';
import { NodeType } from 'prosemirror-model';
import { NodeView } from 'prosemirror-view';
import { PanelType } from '@atlaskit/adf-schema';
import { PluginKey } from 'prosemirror-state';
import { Position } from '@atlaskit/editor-common/src/ui/Popup/utils';
import { PositionType } from '@atlaskit/tooltip/types';
import { PresenceProvider } from '@atlaskit/mention/resource';
import { PresenceResource } from '@atlaskit/mention/resource';
import { PropsDifference } from '@atlaskit/editor-common/utils';
import PropTypes from 'prop-types';
import { ProviderFactory } from '@atlaskit/editor-common/provider-factory';
import { Providers } from '@atlaskit/editor-common/provider-factory';
import { PureComponent } from 'react';
import { QuickInsertActionInsert } from '@atlaskit/editor-common/provider-factory';
import { QuickInsertItem } from '@atlaskit/editor-common/provider-factory';
import { QuickInsertItemId } from '@atlaskit/editor-common/provider-factory';
import { QuickInsertProvider } from '@atlaskit/editor-common/provider-factory';
import { default as React_2 } from 'react';
import { ReactElement } from 'react';
import { RefObject } from 'react';
import { ResolvedEditorState } from '@atlaskit/editor-common/collab';
import { ResolvedPos } from 'prosemirror-model';
import { RichMediaLayout } from '@atlaskit/adf-schema';
import { SafePlugin } from '@atlaskit/editor-common/safe-plugin';
import { Schema } from 'prosemirror-model';
import type { SearchProvider } from '@atlaskit/editor-common/provider-factory';
import { Selection as Selection_2 } from 'prosemirror-state';
import { SelectItemMode } from '@atlaskit/editor-common/type-ahead';
import { SEVERITY } from '@atlaskit/editor-common/utils';
import { ShallowPropsDifference } from '@atlaskit/editor-common/utils';
import { Slice } from 'prosemirror-model';
import { TableLayout } from '@atlaskit/adf-schema';
import { TableSortOrder } from '@atlaskit/adf-schema/steps';
import { TaskDecisionProvider } from '@atlaskit/task-decision';
import { TeamMentionProvider } from '@atlaskit/mention/resource';
import { TeamMentionResource } from '@atlaskit/mention/team-resource';
import type { ThemeModes } from '@atlaskit/theme/types';
import { Transaction } from 'prosemirror-state';
import { Transformer as Transformer_2 } from '@atlaskit/editor-common/types';
import { TypeAheadAvailableNodes } from '@atlaskit/editor-common/type-ahead';
import type { TypeAheadItem } from '@atlaskit/editor-common/provider-factory';
import { UIAnalyticsEventHandler } from '@atlaskit/analytics-next';
import type { UnsupportedContentPayload } from '@atlaskit/editor-common/utils';
import type { UnsupportedContentTooltipPayload } from '@atlaskit/editor-common/utils';
import { UploadEndEventPayload } from '@atlaskit/media-picker/types';
import { UploadErrorEventPayload } from '@atlaskit/media-picker/types';
import { UploadParams } from '@atlaskit/media-picker/types';
import { UploadPreviewUpdateEventPayload } from '@atlaskit/media-picker/types';
import type { UserBrowserExtensionResults } from '@atlaskit/editor-common/utils';
import { WithIntlProps } from 'react-intl-next';
import { WrappedComponentProps } from 'react-intl-next';

export { AbstractMentionResource };

export declare enum ACTION {
  ACTIVATED = 'activated',
  ADDED = 'added',
  BROWSER_FREEZE = 'browserFreeze',
  CHANGED_BACKGROUND_COLOR = 'changedBackgroundColor',
  CHANGED_ICON = 'changedIcon',
  CHANGED_FULL_WIDTH_MODE = 'changedFullWidthMode',
  CHANGED_LAYOUT = 'changedLayout',
  CHANGED_REPLACEMENT_TEXT = 'changedReplacementText',
  CHANGED_TYPE = 'changedType',
  CHANGED_URL = 'changedUrl',
  CLEARED = 'cleared',
  CLICKED = 'clicked',
  CLOSED = 'closed',
  COMMITTED = 'committed',
  CONVERTED = 'converted',
  COPIED = 'copied',
  CUT = 'cut',
  DEACTIVATED = 'deactivated',
  DECREMENTED = 'decremented',
  DELETED = 'deleted',
  DISCARDED_INVALID_STEPS_FROM_TRANSACTION = 'discardedInvalidStepsFromTransaction',
  DISMISSED = 'dismissed',
  DISPATCHED_INVALID_TRANSACTION = 'dispatchedInvalidTransaction',
  DISPATCHED_VALID_TRANSACTION = 'dispatchedValidTransaction',
  EDITED = 'edited',
  EDITOR_CRASHED = 'unhandledErrorCaught',
  EDITOR_CRASHED_ADDITIONAL_INFORMATION = 'unhandledErrorCaughtAdditionalInfo',
  EDITOR_MOUNTED = 'mounted',
  EDITOR_TTI = 'tti',
  EDITOR_CONTENT_RETRIEVAL_PERFORMED = 'contentRetrievalPerformed',
  RE_RENDERED = 'reRendered',
  ENTERED = 'entered',
  ERRORED = 'errored',
  EXPOSED = 'exposed',
  FAILED_TO_UNMOUNT = 'failedToUnmount',
  FIND_NEXT_PERFORMED = 'findNextPerformed',
  FIND_PERFORMED = 'findPerformed',
  FIND_PREV_PERFORMED = 'findPrevPerformed',
  FORMATTED = 'formatted',
  HELP_OPENED = 'helpOpened',
  HIGHLIGHTED = 'highlighted',
  INCREMENTED = 'incremented',
  INDENTED = 'indented',
  INITIALISED = 'initialised',
  INPUT_PERF_SAMPLING = 'inputPerfSampling',
  INPUT_PERF_SAMPLING_AVG = 'inputPerfSamplingAvg',
  INSERTED = 'inserted',
  INVALID_DOCUMENT_ENCOUNTERED = 'invalidDocumentEncountered',
  INVOKED = 'invoked',
  LANGUAGE_SELECTED = 'languageSelected',
  LIST_ITEM_JOINED = 'listItemJoined',
  MATCHED = 'matched',
  MEDIA_LINK_TRANSFORMED = 'mediaLinkTransformed',
  NODE_CONTENT_SANITIZED = 'nodeContentSanitized',
  OPENED = 'opened',
  OUTDENTED = 'outdented',
  PASTED = 'pasted',
  PASTED_AS_PLAIN = 'pastedAsPlain',
  PASTED_TIMED = 'pastedTimed',
  PROSEMIRROR_RENDERED = 'proseMirrorRendered',
  REACT_NODEVIEW_RENDERED = 'reactNodeViewRendered',
  REPLACED_ALL = 'replacedAll',
  REPLACED_ONE = 'replacedOne',
  RESOLVED = 'resolved',
  SELECTED = 'selected',
  SHOWN = 'shown',
  SLOW_INPUT = 'slowInput',
  STARTED = 'started',
  STOPPED = 'stopped',
  SUBSTITUTED = 'autoSubstituted',
  SYNCHRONY_DISCONNECTED = 'synchronyDisconnected',
  SYNCHRONY_ENTITY_ERROR = 'synchronyEntityError',
  SYNCHRONY_ERROR = 'synchronyError',
  TEXT_LINK_MARK_TRANSFORMED = 'textLinkMarkTransformed',
  DEDUPE_MARKS_TRANSFORMED = 'dedupeMarksTransformed',
  NODES_MISSING_CONTENT_TRANSFORMED = 'nodesMissingContentTransformed',
  INDENTATION_MARKS_TRANSFORMED = 'indentationMarksTransformed',
  TOGGLE_EXPAND = 'toggleExpand',
  TRANSACTION_DISPATCHED = 'transactionDispatched',
  TRANSACTION_MUTATED_AFTER_DISPATCH = 'transactionMutatedAfterDispatched',
  TYPING_FINISHED = 'typingFinished',
  TYPING_STARTED = 'typingStarted',
  UNLINK = 'unlinked',
  UNSUPPORTED_CONTENT_ENCOUNTERED = 'unsupportedContentEncountered',
  UPDATED = 'updated',
  UPLOAD_EXTERNAL_FAIL = 'uploadExternalFailed',
  VIEWED = 'viewed',
  VISITED = 'visited',
  WITH_PLUGIN_STATE_CALLED = 'withPluginStateCalled',
  RENDERED = 'rendered',
  ON_EDITOR_READY_CALLBACK = 'onEditorReadyCallback',
  ON_CHANGE_CALLBACK = 'onChangeCalled',
  NEW_COLLAB_SYNC_UP_ERROR_NO_STEPS = 'newCollabSyncUpErrorNoSteps',
  REMOVE_ICON = 'removedIcon',
  UFO_SESSION_COMPLETE = 'ufoSessionComplete',
  INVALID_PROSEMIRROR_DOCUMENT = 'invalidProsemirrorDocument',
  DOCUMENT_PROCESSING_ERROR = 'documentProcessingError',
}

export declare enum ACTION_SUBJECT {
  TOOLBAR_BUTTON = 'toolbarButton',
  BUTTON = 'button',
  CONFIG_PANEL = 'configPanel',
  CONTENT_COMPONENT = 'contentComponent',
  DATE = 'date',
  DATE_SEGMENT = 'dateSegment',
  DOCUMENT = 'document',
  EDITOR = 'editor',
  ELEMENT_BROWSER = 'elementBrowser',
  EMBEDS = 'embeds',
  EXPAND = 'expand',
  EXTENSION = 'extension',
  FEATURE = 'feature',
  FEEDBACK_DIALOG = 'feedbackDialog',
  FIND_REPLACE_DIALOG = 'findReplaceDialog',
  FLOATING_CONTEXTUAL_BUTTON = 'floatingContextualButton',
  FLOATING_TOOLBAR_PLUGIN = 'floatingToolbarPlugin',
  HELP = 'help',
  LAYOUT = 'layout',
  LIST = 'list',
  MEDIA = 'media',
  MEDIA_SINGLE = 'mediaSingle',
  NESTED_EXPAND = 'nestedExpand',
  PANEL = 'panel',
  PICKER = 'picker',
  PLUS_MENU = 'plusMenu',
  PLUGIN_SLOT = 'pluginSlot',
  REACT_NODE_VIEW = 'reactNodeView',
  SELECTION = 'selection',
  SMART_LINK = 'smartLink',
  HYPERLINK = 'hyperlink',
  TABLE = 'table',
  TABLES_PLUGIN = 'tablesPlugin',
  TEXT = 'text',
  TOOLBAR = 'toolbar',
  TYPEAHEAD = 'typeAhead',
  TYPEAHEAD_ITEM = 'typeAheadItem',
  ANNOTATION = 'annotation',
  SEARCH_RESULT = 'searchResult',
  CREATE_LINK_INLINE_DIALOG = 'createLinkInlineDialog',
  CODE_BLOCK = 'codeBlock',
  REACT_EDITOR_VIEW = 'reactEditorView',
}

export declare enum ACTION_SUBJECT_ID {
  ACTION = 'action',
  ALL = 'all',
  ALT_TEXT = 'altText',
  ANNOTATE_BUTTON = 'annotateButton',
  AVATAR_GROUP_PLUGIN = 'AvatarGroupInPlugin',
  BLOCK_QUOTE = 'blockQuote',
  BUTTON_FEEDBACK = 'feedbackButton',
  BUTTON_HELP = 'helpButton',
  BUTTON_CATEGORY = 'categoryButton',
  CANCEL = 'cancel',
  CARD_BLOCK = 'blockCard',
  CAPTION = 'caption',
  CARD_INLINE = 'inlineCard',
  CELL = 'cell',
  CODE_BLOCK = 'codeBlock',
  DATE = 'date',
  DATE_DAY = 'day',
  DATE_MONTH = 'month',
  DATE_YEAR = 'year',
  DECISION = 'decision',
  DIVIDER = 'divider',
  EMOJI = 'emoji',
  EXPAND = 'expand',
  EXTENSION = 'extension',
  EXTENSION_API = 'extensionApi',
  EXTENSION_BLOCK = 'extension',
  EXTENSION_BODIED = 'bodiedExtension',
  EXTENSION_INLINE = 'inlineExtension',
  FORMAT_BLOCK_QUOTE = 'blockQuote',
  FORMAT_CLEAR = 'clearFormatting',
  FORMAT_CODE = 'code',
  FORMAT_COLOR = 'color',
  FORMAT_HEADING = 'heading',
  FORMAT_INDENT = 'indentation',
  FORMAT_ITALIC = 'italic',
  FORMAT_LIST_BULLET = 'bulletedList',
  FORMAT_LIST_NUMBER = 'numberedList',
  FORMAT_STRIKE = 'strike',
  FORMAT_STRONG = 'strong',
  FORMAT_SUB = 'subscript',
  FORMAT_SUPER = 'superscript',
  FORMAT_UNDERLINE = 'underline',
  HELP_QUICK_INSERT = 'helpQuickInsert',
  INLINE_COMMENT = 'inlineComment',
  LAYOUT = 'layout',
  RICH_MEDIA_LAYOUT = 'richMediaLayout',
  LINE_BREAK = 'lineBreak',
  LINK = 'link',
  LINK_PREVIEW = 'linkPreview',
  MEDIA = 'media',
  MEDIA_GROUP = 'mediaGroup',
  MEDIA_INLINE = 'mediaInline',
  MEDIA_SINGLE = 'mediaSingle',
  MEDIA_LINK = 'mediaLink',
  MENTION = 'mention',
  NESTED_EXPAND = 'nestedExpand',
  NODE = 'node',
  PANEL = 'panel',
  PASTE_BLOCK_CARD = 'blockCard',
  PASTE_BLOCKQUOTE = 'blockQuote',
  PASTE_BODIED_EXTENSION = 'bodiedExtension',
  PASTE_BULLET_LIST = 'bulletList',
  PASTE_CODE_BLOCK = 'codeBlock',
  PASTE_DECISION_LIST = 'decisionList',
  PASTE_EXPAND = 'expand',
  PASTE_EXTENSION = 'extension',
  PASTE_HEADING = 'heading',
  PASTE_MEDIA_GROUP = 'mediaGroup',
  PASTE_MEDIA_SINGLE = 'mediaSingle',
  PASTE_NESTED_EXPAND = 'nestedExpand',
  PASTE_ORDERED_LIST = 'orderedList',
  PASTE_PANEL = 'panel',
  PASTE_PARAGRAPH = 'paragraph',
  PASTE_RULE = 'rule',
  PASTE_TABLE = 'table',
  PASTE_TABLE_CELL = 'tableCell',
  PASTE_TABLE_HEADER = 'tableHeader',
  PASTE_TABLE_ROW = 'tableRow',
  PASTE_TASK_LIST = 'taskList',
  PICKER_COLOR = 'colorPicker',
  PICKER_CLOUD = 'cloudPicker',
  PICKER_EMOJI = 'emojiPicker',
  PRODUCT_NAME = 'productName',
  PLACEHOLDER_TEXT = 'placeholderText',
  PUNC = 'punctuation',
  RANGE = 'range',
  REACT_NODE_VIEW = 'reactNodeView',
  RESIZED = 'resized',
  SAVE = 'save',
  SECTION = 'section',
  SMART_LINK = 'smartLink',
  STATUS = 'status',
  SYMBOL = 'symbol',
  TABLE = 'table',
  TEXT = 'text',
  TYPEAHEAD_EMOJI = 'emojiTypeAhead',
  TYPEAHEAD_LINK = 'linkTypeAhead',
  TYPEAHEAD_MENTION = 'mentionTypeAhead',
  TYPEAHEAD_QUICK_INSERT = 'quickInsertTypeAhead',
  UNSUPPORTED_BLOCK = 'unsupportedBlock',
  UNSUPPORTED_INLINE = 'unsupportedInline',
  UNSUPPORTED_MARK = 'unsupportedMark',
  UNKNOWN_NODE = 'unknownNode',
  RECENT_ACTIVITIES = 'recentActivities',
  QUICK_SEARCH = 'quickSearch',
  LINK_SEARCH_INPUT = 'linkSearchInput',
  PRE_QUERY_SEARCH_RESULTS = 'preQuerySearchResults',
  POST_QUERY_SEARCH_RESULTS = 'postQuerySearchResults',
  EDIT_LINK = 'editLink',
  UNLINK = 'unlink',
  OPEN_LINK = 'openLink',
  EMBEDS = 'embeds',
  HYPERLINK = 'hyperlink',
}

declare type ActivateAEP = UIAEP<
  ACTION.ACTIVATED,
  ACTION_SUBJECT.FIND_REPLACE_DIALOG,
  undefined,
  {
    inputMethod: INPUT_METHOD.KEYBOARD | INPUT_METHOD.PREFILL;
    triggerMethod: TRIGGER_METHOD.SHORTCUT | TRIGGER_METHOD.TOOLBAR;
  },
  undefined
>;

declare type AddItemTransactionCreator = (opts: {
  state: EditorState;
  tr: Transaction;
  list: NodeType;
  item: NodeType;
  listLocalId: string;
  itemLocalId: string;
}) => Transaction | null;

declare type AEP<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes,
  NonPrivacySafeAttributes,
  EventType,
  ImplicitAttributes extends {} = {}
> = {
  action: Action;
  actionSubject: ActionSubject;
  actionSubjectId?: ActionSubjectID;
  attributes?: Attributes &
    {
      [key in keyof ImplicitAttributes]?: ImplicitAttributes[key];
    };
  eventType: EventType;
  nonPrivacySafeAttributes?: NonPrivacySafeAttributes;
};

declare type AlignType = 'left' | 'center' | 'right';

declare type AllCellInfo = TotalRowAndColCount &
  HorizontalAndVerticalCells & {
    totalCells: number;
  };

declare type AllowedBlockTypes =
  | 'heading'
  | 'blockquote'
  | 'hardBreak'
  | 'codeBlock';

declare interface AllSelectionData {
  type: 'all';
}

export declare type AnalyticsEventPayload<T = void> =
  | AvatarEventPayload
  | GeneralEventPayload<T>
  | FormatEventPayload
  | SubstituteEventPayload
  | InsertEventPayload
  | NodeEventPayload
  | MediaEventPayload
  | TableEventPayload
  | PasteEventPayload
  | CutCopyEventPayload
  | ErrorEventPayload
  | ExperimentalEventPayload
  | FindReplaceEventPayload
  | DateEventPayload
  | SelectionEventPayload
  | ListEventPayload
  | ConfigPanelEventPayload
  | ElementBrowserEventPayload
  | CreateLinkInlineDialogEventPayload
  | UnsupportedContentPayload
  | ExtensionEventPayload
  | TransactionEventPayload
  | TypeAheadPayload
  | UnlinkToolbarAEP
  | EditLinkToolbarAEP
  | CustomPanelEventPayload
  | FeatureExposureAEP
  | NewCollabSyncUpErrorAEP
  | UnsupportedContentTooltipPayload;

declare type AnalyticsEventPayloadWithChannel = {
  channel: string;
  payload: AnalyticsEventPayload;
};

declare type AnnotateButtonAEP = UIAEP<
  ACTION.CLICKED,
  ACTION_SUBJECT.MEDIA,
  ACTION_SUBJECT_ID.ANNOTATE_BUTTON,
  undefined,
  undefined
>;

declare type AnnotationActionType =
  | ACTION.INSERTED
  | ACTION.CLOSED
  | ACTION.EDITED
  | ACTION.DELETED
  | ACTION.OPENED
  | ACTION.RESOLVED
  | ACTION.VIEWED;

declare type AnnotationAEP = TrackAEP<
  AnnotationActionType,
  ACTION_SUBJECT.ANNOTATION,
  ACTION_SUBJECT_ID.INLINE_COMMENT,
  AnnotationAEPAttributes,
  undefined
>;

declare type AnnotationAEPAttributes =
  | undefined
  | {}
  | AnnotationDraftAEPAttributes
  | AnnotationResolvedAEPAttributes;

declare type AnnotationComponentProps = {
  /**
   * Selected text (can be used when creating a comment)
   */
  textSelection?: string;
  /**
   * DOM element around selected text (for positioning)
   */
  dom?: HTMLElement;
  /**
   * Indicates that a draft comment was discarded/cancelled
   */
  onClose?: () => void;
};

declare type AnnotationDraftAEPAttributes = {
  inputMethod: INPUT_METHOD.TOOLBAR | INPUT_METHOD.SHORTCUT;
  overlap: number;
};

export declare type AnnotationInfo = {
  id: string;
  type: AnnotationTypes.INLINE_COMMENT;
};

export declare interface AnnotationProviders {
  inlineComment: InlineCommentAnnotationProvider;
}

declare type AnnotationResolvedAEPAttributes = {
  method: RESOLVE_METHOD;
};

export declare interface AnnotationState<Type, State> {
  annotationType: Type;
  id: string;
  state: State;
}

export declare interface AnnotationTypeProvider<Type, State> {
  getState: (
    annotationIds: string[],
  ) => Promise<AnnotationState<Type, State>[]>;
  updateSubscriber?: AnnotationUpdateEmitter;
  disallowOnWhitespace?: boolean;
}

export declare class AnnotationUpdateEmitter extends EventEmitter {
  on(event: VisibilityEvent, listener: (isVisible: boolean) => void): this;
  on(event: UpdateEvent, listener: (annotationId: string) => void): this;
}

declare type AttemptedResizeInfo = {
  type: string;
  position: string;
  duration: number;
  delta: number;
};

declare type AvatarButtonViewedAEP = UIAEP<
  ACTION.VIEWED,
  ACTION_SUBJECT.BUTTON,
  ACTION_SUBJECT_ID.AVATAR_GROUP_PLUGIN,
  {},
  undefined
>;

declare type AvatarEventPayload = AvatarButtonViewedAEP;

declare interface BasePluginOptions {
  allowScrollGutter?: ScrollGutterPluginOptions;
  allowInlineCursorTarget?: boolean;
  inputTracking?: InputTracking;
  browserFreezeTracking?: BrowserFreezetracking;
  ufo?: boolean;
}

declare type BasePortalProviderProps = {
  render: (
    portalProviderAPI: PortalProviderAPI,
  ) => React_2.ReactChild | JSX.Element | null;
  onAnalyticsEvent?: FireAnalyticsCallback;
  useAnalyticsContext?: boolean;
  themeMode?: ThemeModes;
} & WrappedComponentProps;

export declare class BaseReactEditorView<T = {}> extends React_2.Component<
  EditorViewProps & WrappedComponentProps & T,
  {},
  EditorReactContext
> {
  view?: EditorView;
  eventDispatcher: EventDispatcher;
  contentTransformer?: Transformer_2<string>;
  config: EditorConfig;
  editorState: EditorState;
  errorReporter: ErrorReporter;
  dispatch: Dispatch;
  proseMirrorRenderedSeverity?: SEVERITY;
  transactionTracker: TransactionTracker;
  validTransactionCount: number;
  experienceStore?: ExperienceStore;
  static contextTypes: {
    getAtlaskitAnalyticsEventHandlers: PropTypes.Requireable<
      (...args: any[]) => any
    >;
  };
  private canDispatchTransactions;
  private focusTimeoutId?;
  private reliabilityInterval?;
  private pluginPerformanceObserver;
  private featureFlags;
  private onPluginObservation;
  get transactionTracking(): TransactionTracking;
  private getPluginNames;
  private countNodes;
  constructor(
    props: EditorViewProps & WrappedComponentProps & T,
    context: EditorReactContext,
  );
  UNSAFE_componentWillReceiveProps(nextProps: EditorViewProps): void;
  formatFullWidthAppearance: (
    appearance: EditorAppearance | undefined,
  ) => FULL_WIDTH_MODE;
  resetEditorState: ({
    doc,
    shouldScrollToBottom,
  }: {
    doc: string;
    shouldScrollToBottom: boolean;
  }) => void;
  blur: () => void;
  reconfigureState: (props: EditorViewProps) => void;
  handleAnalyticsEvent: FireAnalyticsCallback;
  componentDidMount(): void;
  /**
   * Clean up any non-PM resources when the editor is unmounted
   */
  componentWillUnmount(): void;
  getPlugins(
    editorProps: EditorProps,
    prevEditorProps?: EditorProps,
    createAnalyticsEvent?: CreateUIAnalyticsEvent,
  ): EditorPlugin[];
  createEditorState: (options: {
    props: EditorViewProps;
    context: EditorReactContext;
    doc?: string | Object | Node_2<any> | undefined;
    resetting?: boolean | undefined;
    selectionAtStart?: boolean | undefined;
  }) => EditorState<any>;
  private onEditorViewStateUpdated;
  private trackValidTransactions;
  private dispatchTransaction;
  getDirectEditorProps: (
    state?: EditorState<any> | undefined,
  ) => DirectEditorProps;
  private createEditorView;
  handleEditorViewRef: (node: HTMLDivElement) => void;
  dispatchAnalyticsEvent: (payload: AnalyticsEventPayload) => void;
  private editor;
  render(): JSX.Element;
}

declare type BeforeAndAfterToolbarComponents = {
  before: ReactComponents;
  after: ReactComponents;
};

export declare const blockPluginStateKey: PluginKey<BlockTypeState, any>;

declare interface BlockType {
  name: string;
  title: MessageDescriptor_2;
  nodeName: string;
  tagName?: string;
  level?: HeadingLevelsAndNormalText;
}

export declare type BlockTypeInputMethod =
  | INPUT_METHOD.TOOLBAR
  | INPUT_METHOD.INSERT_MENU
  | INPUT_METHOD.SHORTCUT
  | INPUT_METHOD.FORMATTING
  | INPUT_METHOD.KEYBOARD;

declare interface BlockTypePluginOptions {
  lastNodeMustBeParagraph?: boolean;
  allowBlockType?: {
    exclude?: Array<AllowedBlockTypes>;
  };
  isUndoRedoButtonsEnabled?: boolean;
}

export declare type BlockTypeState = {
  currentBlockType: BlockType;
  blockTypesDisabled: boolean;
  availableBlockTypes: BlockType[];
  availableWrapperBlockTypes: BlockType[];
};

declare enum BROWSER_FREEZE_INTERACTION_TYPE {
  LOADING = 'loading',
  TYPING = 'typing',
  CLICKING = 'clicking',
  PASTING = 'pasting',
}

declare type BrowserFreezePayload = OperationalAEPWithObjectId<
  ACTION.BROWSER_FREEZE,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    freezeTime: number;
    nodeSize: number;
    participants: number;
    nodeCount?: Record<string, number>;
    interactionType?: BROWSER_FREEZE_INTERACTION_TYPE;
    severity?: SEVERITY;
  },
  undefined
>;

declare type BrowserFreezetracking = {
  enabled?: boolean;
  /**
   * @description Control whether browser freeze interaction type is tracked. When this is false the interaction type is not recorded.
   * @default false
   */
  trackInteractionType?: boolean;
  /**
   * @description Control whether browser freeze severity is tracked. When this is false the severity is not recorded.
   * @default false
   */
  trackSeverity?: boolean;
  /**
   * @description Control for calculating severity level (NORMAL/DEGRADED/BLOCKING). Depends on severityTracking being true.
   * @default 2000
   */
  severityNormalThreshold?: number;
  /**
   * @description Control for calculating severity level (NORMAL/DEGRADED/BLOCKING). Depends on severityTracking being true.
   * @default 3000
   */
  severityDegradedThreshold?: number;
};

declare type ButtonAEP<ActionSubjectID, Attributes> = UIAEP<
  ACTION.CLICKED,
  ACTION_SUBJECT.BUTTON,
  ActionSubjectID,
  Attributes,
  undefined
>;

declare type ButtonAppearance = 'subtle' | 'danger';

declare type ButtonFeedbackAEP = ButtonAEP<
  ACTION_SUBJECT_ID.BUTTON_FEEDBACK,
  undefined
>;

declare type ButtonHelpAEP = ButtonAEP<
  ACTION_SUBJECT_ID.BUTTON_HELP,
  {
    inputMethod: INPUT_METHOD.SHORTCUT | INPUT_METHOD.TOOLBAR;
  }
>;

declare type CaptionTrackAction = TrackAEP<
  MediaCaptionActionType,
  ACTION_SUBJECT.MEDIA_SINGLE,
  ACTION_SUBJECT_ID.CAPTION,
  any,
  undefined
>;

export { CardProvider };

declare type CatchAllTracking = {
  /**
   * @description Control whether a second operational event with a rough performance measurement is sent for every regular analytics event
   * @default false
   */
  enabled: boolean;
};

declare interface CellSelectionData {
  type: 'cell';
  anchor: number;
  head: number;
}

export declare const changeColor: (color: string) => Command;

declare type ChangedLayoutAEP = TrackAEP<
  ACTION.CHANGED_LAYOUT,
  ACTION_SUBJECT.LAYOUT,
  undefined,
  {
    previousLayout: LAYOUT_TYPE;
    newLayout: LAYOUT_TYPE;
  },
  undefined
>;

declare type ChangeMediaAEP = TrackAEP<
  ACTION.CHANGED_TYPE,
  ACTION_SUBJECT.MEDIA,
  undefined,
  {
    newType: MediaSwitchType;
    previousType: MediaSwitchType;
  },
  undefined
>;

declare type ChangePanelAEP = TrackAEP<
  ACTION.CHANGED_TYPE,
  ACTION_SUBJECT.PANEL,
  undefined,
  {
    newType: PanelType;
    previousType: PanelType;
  },
  undefined
>;

declare type ChangeSmartLinkAEP = TrackAEP<
  ACTION.CHANGED_TYPE,
  ACTION_SUBJECT.SMART_LINK,
  undefined,
  {
    newType: SMART_LINK_TYPE;
    previousType: SMART_LINK_TYPE;
  },
  undefined
>;

export declare const clearEditorContent: Command;

declare type ClickedElementBrowserCategory = TrackAEP<
  ACTION.CLICKED,
  ACTION_SUBJECT.BUTTON,
  ACTION_SUBJECT_ID.BUTTON_CATEGORY,
  any,
  undefined
>;

declare type CloseAEP = UIAEP<
  ACTION.CLOSED,
  ACTION_SUBJECT.CONFIG_PANEL,
  undefined,
  {},
  undefined
>;

declare type CloseAEP_2 = UIAEP<
  ACTION.CLOSED,
  ACTION_SUBJECT.ELEMENT_BROWSER,
  undefined,
  {
    mode: 'full' | 'inline';
  },
  undefined
>;

declare type CloseOptions = {
  insertCurrentQueryAsRawText: boolean;
  attachCommand?: Command;
};

declare type CodeBlockLanguageSelectedAEP = TrackAEP<
  ACTION.LANGUAGE_SELECTED,
  ACTION_SUBJECT.CODE_BLOCK,
  undefined,
  {
    language: string;
  },
  undefined
>;

declare interface CodeBlockOptions extends LongPressSelectionPluginOptions {
  allowCopyToClipboard?: boolean;
  allowCompositionInputOverride?: boolean;
  appearance?: EditorAppearance | undefined;
}

declare interface CollabAnalyticsProps {
  /**
   * @description Control wether Synchrony entity error events are tracked
   */
  EXPERIMENTAL_allowInternalErrorAnalytics?: boolean;
}

declare type CollabEditOptions = {
  provider?: Providers['collabEditProvider'];
  userId?: string;
  useNativePlugin?: boolean;
} & CollabInviteToEditProps &
  CollabAnalyticsProps;

export { CollabEditProvider };

declare interface CollabInviteToEditProps {
  inviteToEditHandler?: (event: React.MouseEvent<HTMLElement>) => void;
  isInviteToEditButtonSelected?: boolean;
  inviteToEditComponent?: React.ComponentType<InviteToEditComponentProps>;
}

export declare class CollapsedEditor extends React_2.Component<Props, State_2> {
  editorComponent?: Editor;
  shouldTriggerExpandEvent?: boolean;
  UNSAFE_componentWillReceiveProps(nextProps: Props): void;
  componentDidUpdate(): void;
  handleEditorRef: (
    editorRef?: Editor | undefined,
    editorRefCallback?: any,
  ) => void;
  render(): JSX.Element;
}

declare type ColorPickerAEP = TrackAEP<
  ACTION.UPDATED,
  ACTION_SUBJECT.PICKER,
  ACTION_SUBJECT_ID.PICKER_COLOR,
  {
    color: string;
    label?: string;
    placement: string;
  },
  undefined
>;

export declare type Command = (
  state: EditorState,
  dispatch?: CommandDispatch,
  view?: EditorView,
) => boolean;

export declare type CommandDispatch = (tr: Transaction) => void;

declare type CommitDateAEP = TrackAEP<
  ACTION.COMMITTED,
  ACTION_SUBJECT.DATE,
  undefined,
  {
    commitMethod:
      | INPUT_METHOD.PICKER
      | INPUT_METHOD.BLUR
      | INPUT_METHOD.KEYBOARD;
    isValid: true | false;
    isToday: true | false;
  },
  undefined
>;

export declare const commitStatusPicker: () => (editorView: EditorView) => void;

declare type CommonListAnalyticsAttributes = {
  itemIndexAtSelectionStart: number;
  itemIndexAtSelectionEnd: number;
  indentLevelAtSelectionStart: number;
  indentLevelAtSelectionEnd: number;
  itemsInSelection: number;
};

declare type ComponentCrashAdditionalInfoErrorAEP = OperationalAEP<
  ACTION.EDITOR_CRASHED_ADDITIONAL_INFORMATION,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    errorStack: string;
    errorId: string;
  },
  undefined
>;

declare type ComponentCrashErrorAEP = OperationalAEP<
  ACTION.EDITOR_CRASHED,
  | ACTION_SUBJECT.FLOATING_CONTEXTUAL_BUTTON
  | ACTION_SUBJECT.PLUGIN_SLOT
  | ACTION_SUBJECT.REACT_NODE_VIEW
  | ACTION_SUBJECT.TABLES_PLUGIN
  | ACTION_SUBJECT.FLOATING_TOOLBAR_PLUGIN
  | ACTION_SUBJECT.EDITOR,
  ACTION_SUBJECT_ID | FLOATING_CONTROLS_TITLE,
  ErrorEventAttributes,
  undefined
>;

declare type ConfigPanelCrashedAEP = UIAEP<
  ACTION.ERRORED,
  ACTION_SUBJECT.CONFIG_PANEL,
  undefined,
  {
    product: string;
    browserInfo: string;
    extensionKey: string;
    fields: string;
    error: string;
    errorInfo?: {
      componentStack: string;
    };
    errorStack?: string;
  },
  undefined
>;

declare type ConfigPanelEventPayload =
  | OpenAEP
  | CloseAEP
  | ConfigPanelCrashedAEP;

declare type ConfigWithNodeInfo = {
  config: FloatingToolbarConfig | undefined;
  pos: number;
  node: Node_2;
};

declare interface ConfirmDialogOptions {
  title?: string;
  message: string;
  okButtonLabel?: string;
  cancelButtonLabel?: string;
}

declare enum CONTENT_COMPONENT {
  INLINE_COMMENT = 'inlineComment',
  FLOATING_CONTEXTUAL_BUTTON = 'floatingContextualButton',
  FLOATING_INSERT_BUTTON = 'floatingInsertButton',
  FLOATING_TOOLBAR = 'floatingToolbar',
}

declare type ContentComponentErrorAEP = OperationalAEP<
  ACTION.ERRORED,
  ACTION_SUBJECT.CONTENT_COMPONENT,
  undefined,
  {
    component: CONTENT_COMPONENT;
    error: string;
    errorStack?: string;
    selection: {
      [key: string]: string;
    };
    position: number;
    docSize: number;
  },
  undefined
>;

declare type ContentRetrievalTracking = {
  /**
   * @description Control whether editor content retrieval success and failure events are dispatched.
   * When this is false no events are sampled or sent.
   * @default false
   */
  enabled: boolean;
  /**
   * @description Control how frequently/at what rate successful editor content retrieval events are dispatched.
   * @default 100
   */
  successSamplingRate?: number;
  /**
   * @description Control how frequently/at what rate failed editor content retrieval events are dispatched.
   * @default 100
   */
  failureSamplingRate?: number;
  /**
   * @description Control whether the failed editor content retrieval event includes the error stack trace.
   * @default false
   */
  reportErrorStack?: boolean;
};

declare type Context = {
  editorActions?: EditorActions;
  intl: IntlShape;
};

declare type Context_2 = {
  editorActions?: EditorActions;
  editorSharedConfig?: EditorSharedConfig;
};

export declare class ContextPanel extends React_2.Component<Props_4> {
  render(): jsx.JSX.Element;
}

declare type ContextPanelHandler = (state: EditorState) => React_2.ReactNode;

declare type ContextUpdateHandler = (
  editorView: EditorView,
  eventDispatcher: EventDispatcher,
) => void;

declare type CopyAEP = TrackAEP<
  ACTION.COPIED,
  ACTION_SUBJECT.DOCUMENT,
  undefined,
  {
    content: string[];
  },
  undefined
>;

declare type CreateLinkInlineDialogEventPayload =
  | QuickSearchPerfAEP
  | RecentActivitiesPerfAEP
  | ViewedCreateLinkInlineDialogAEP
  | EnteredTextLinkSearchInputAEP
  | ShownPreQuerySearchResultsAEP
  | ShownPostQuerySearchResultsAEP
  | HighlightedSearchResultsAEP
  | SelectedSearchResultsAEP
  | DismissedCreateLinkInlineDialogAEP;

export declare const createQuickInsertTools: (
  editorView: EditorView,
) => {
  getItems: (
    query: string,
    options?: QuickInsertPluginOptions | undefined,
  ) => QuickInsertItem[];
};

export declare const createTable: () => Command;

export declare const createTypeAheadTools: (
  editorView: EditorView,
) => {
  isOpen: () => TypeAheadHandler | false;
  currentQuery: () => string;
  close: (options?: CloseOptions) => boolean;
  openMention: (inputMethod: TypeAheadInputMethod) => boolean;
  searchMention: (
    query?: string,
  ) => {
    type: (appendValue: string) => Promise<TypeAheadItem[]> | undefined;
    result: () => Promise<TypeAheadItem[] | undefined>;
    close: (options?: CloseOptions) => boolean;
    insert: ({
      index,
      mode,
    }: {
      index: number;
      mode?: SelectItemMode | undefined;
    }) => Promise<void>;
  };
  openQuickInsert: (inputMethod: TypeAheadInputMethod) => boolean;
  searchQuickInsert: (
    query?: string,
  ) => {
    type: (appendValue: string) => Promise<TypeAheadItem[]> | undefined;
    result: () => Promise<TypeAheadItem[] | undefined>;
    close: (options?: CloseOptions) => boolean;
    insert: ({
      index,
      mode,
    }: {
      index: number;
      mode?: SelectItemMode | undefined;
    }) => Promise<void>;
  };
  openEmoji: (inputMethod: TypeAheadInputMethod) => boolean;
  searchEmoji: (
    query?: string,
  ) => {
    type: (appendValue: string) => Promise<TypeAheadItem[]> | undefined;
    result: () => Promise<TypeAheadItem[] | undefined>;
    close: (options?: CloseOptions) => boolean;
    insert: ({
      index,
      mode,
    }: {
      index: number;
      mode?: SelectItemMode | undefined;
    }) => Promise<void>;
  };
  insertItemMention: ({
    contentItem,
    query,
    sourceListItem,
  }: InsertItemProps) => boolean;
  insertItemEmoji: ({
    contentItem,
    query,
    sourceListItem,
  }: InsertItemProps) => boolean;
  insertItemQuickInsert: ({
    contentItem,
    query,
    sourceListItem,
  }: InsertItemProps) => boolean;
};

export declare interface CustomMediaPicker {
  on(event: string, cb: Listener): void;
  removeAllListeners(event: any): void;
  emit(event: string, data: any): void;
  destroy(): void;
  setUploadParams(uploadParams: UploadParams): void;
}

declare type CustomPanelEventPayload = TrackAEP<
  ACTION.CHANGED_BACKGROUND_COLOR | ACTION.CHANGED_ICON | ACTION.REMOVE_ICON,
  ACTION_SUBJECT.PANEL,
  ACTION_SUBJECT_ID.PANEL,
  | {
      previousColor: string;
      newColor: string;
    }
  | {
      previousIcon: string;
      newIcon: string;
    }
  | {
      icon: string;
    },
  undefined
>;

declare type CutAEP = TrackAEP<
  ACTION.CUT,
  ACTION_SUBJECT.DOCUMENT,
  undefined,
  {
    content: string[];
  },
  undefined
>;

declare type CutCopyEventPayload = CutAEP | CopyAEP;

export declare const darkModeStatusColorPalette: PaletteColor[];

declare type DateEventPayload =
  | TypeDateStartedAEP
  | TypeDateFinishedAEP
  | IncrementDateSegmentAEP
  | DecrementDateSegmentAEP
  | CommitDateAEP;

export declare const dateMessages: {
  editText: {
    id: string;
    defaultMessage: string;
    description: string;
  };
};

export declare const datePluginKey: PluginKey<DatePluginState, any>;

export declare type DatePluginState = {
  isQuickInsertAction?: boolean;
  isNew: boolean;
  showDatePickerAt: number | null;
  isDateEmpty: boolean;
  focusDateInput: boolean;
};

/**
 * Convert a JavaScript Date to an editor DateType
 * @param date JavaScript Date object
 * @returns Editor DateType
 */
export declare function dateToDateType(date: Date): DateType;

declare type DateType = {
  year: number;
  month: number;
  day?: number;
};

declare type DeactivateAEP = UIAEP<
  ACTION.DEACTIVATED,
  ACTION_SUBJECT.FIND_REPLACE_DIALOG,
  undefined,
  {
    triggerMethod:
      | TRIGGER_METHOD.KEYBOARD
      | TRIGGER_METHOD.TOOLBAR
      | TRIGGER_METHOD.BUTTON;
  },
  undefined
>;

declare type DecrementDateSegmentAEP = TrackAEP<
  ACTION.DECREMENTED,
  ACTION_SUBJECT.DATE_SEGMENT,
  undefined,
  {
    dateSegment:
      | ACTION_SUBJECT_ID.DATE_DAY
      | ACTION_SUBJECT_ID.DATE_MONTH
      | ACTION_SUBJECT_ID.DATE_YEAR;
  },
  undefined
>;

export declare function dedupe<T>(
  list?: T[],
  iteratee?: (p: T) => T[keyof T] | T,
): T[];

declare type DedupeMarksTransformedAEP = OperationalAEP<
  ACTION.DEDUPE_MARKS_TRANSFORMED,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    discardedMarks: ADFEntityMark[];
  },
  undefined
>;

export declare const DEFAULT_BORDER_COLOR: string;

declare type DefaultPresetPluginOptions = {
  paste: PastePluginOptions;
  base?: BasePluginOptions;
  blockType?: BlockTypePluginOptions;
  placeholder?: PlaceholderPluginOptions;
  textFormatting?: TextFormattingOptions;
  submitEditor?: EditorProps_2['onSave'];
  annotationProviders?: AnnotationProviders;
  quickInsert?: QuickInsertPluginOptions;
  codeBlock?: CodeBlockOptions;
  selection?: SelectionPluginOptions;
  cardOptions?: CardOptions;
  createAnalyticsEvent?: CreateUIAnalyticsEvent;
  typeAhead?: TypeAheadPluginOptions;
};

declare enum DELETE_DIRECTION {
  BACKWARD = 'backward',
  FORWARD = 'forward',
}

/** Delete the date and close the datepicker */
export declare const deleteDate: () => Command;

declare type DeletedExpandAEP = TrackAEP<
  ACTION.DELETED,
  ACTION_SUBJECT.EXPAND | ACTION_SUBJECT.NESTED_EXPAND,
  undefined,
  {
    inputMethod: INPUT_METHOD.TOOLBAR;
  },
  undefined
>;

declare type DeletedLayoutAEP = TrackAEP<
  ACTION.DELETED,
  ACTION_SUBJECT.LAYOUT,
  undefined,
  {
    layout: LAYOUT_TYPE;
  },
  undefined
>;

declare type DeletedSmartLink = TrackAEP<
  ACTION.DELETED,
  ACTION_SUBJECT.SMART_LINK,
  ACTION_SUBJECT_ID.CARD_BLOCK | ACTION_SUBJECT_ID.CARD_INLINE,
  {
    inputMethod: INPUT_METHOD.TOOLBAR | INPUT_METHOD.CARD;
    displayMode: ACTION_SUBJECT_ID.CARD_BLOCK | ACTION_SUBJECT_ID.CARD_INLINE;
  },
  undefined
>;

declare type DeletePanelAEP = TrackAEP<
  ACTION.DELETED,
  ACTION_SUBJECT.PANEL,
  undefined,
  {
    inputMethod: INPUT_METHOD.TOOLBAR;
  },
  undefined
>;

declare type DismissedCreateLinkInlineDialogAEP = UIAEP<
  ACTION.DISMISSED,
  ACTION_SUBJECT.CREATE_LINK_INLINE_DIALOG,
  undefined,
  {
    source: string;
    searchSessionId: string;
    trigger: string;
  },
  undefined
>;

declare type Dispatch<T = any> = (
  eventName: PluginKey | string,
  data: T,
) => void;

declare type DispatchAnalyticsEvent = (payload: AnalyticsEventPayload) => void;

declare type DispatchedTransactionAEP = OperationalAEP<
  ACTION.TRANSACTION_DISPATCHED,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    report: PluginPerformanceReportData;
    participants: number;
  },
  undefined
>;

declare type DispatchedValidTransactionAEP = OperationalAEP<
  ACTION.DISPATCHED_VALID_TRANSACTION,
  ACTION_SUBJECT.EDITOR,
  undefined,
  undefined,
  undefined
>;

declare type DocumentProcessingErrorAEP = OperationalAEP<
  ACTION.DOCUMENT_PROCESSING_ERROR,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    errorStack?: string;
  },
  undefined
>;

declare type DropdownOptions<T> =
  | Array<DropdownOptionT<T>>
  | {
      render: (
        props: RenderOptionsPropsT<T>,
      ) => React_2.ReactElement<any> | null;
      height: number;
      width: number;
    };

export declare interface DropdownOptionT<T> {
  id?: string;
  title: string;
  onClick: T;
  selected?: boolean;
  disabled?: boolean;
  hidden?: boolean;
  testId?: string;
  tooltip?: string;
}

declare type EditInsertedState = {
  type: HyperlinkInsertStatus.EDIT_INSERTED_TOOLBAR;
  node: Node_2;
  pos: number;
};

declare type EditLinkToolbarAEP = UIAEP<
  ACTION.CLICKED,
  ACTION_SUBJECT.SMART_LINK | ACTION_SUBJECT.HYPERLINK,
  ACTION_SUBJECT_ID.EDIT_LINK,
  {},
  undefined
>;

export declare class Editor extends React_2.Component<EditorProps, State> {
  static defaultProps: EditorProps;
  static propTypes: {
    minHeight: ({ appearance, minHeight }: EditorProps) => Error | null;
  };
  static contextTypes: {
    editorActions: PropTypes.Requireable<object>;
  };
  private providerFactory;
  private editorActions;
  private createAnalyticsEvent?;
  private editorSessionId;
  private experienceStore?;
  private startTime?;
  constructor(props: EditorProps, context: Context);
  componentDidMount(): void;
  componentDidUpdate(prevProps: EditorProps): void;
  componentWillUnmount(): void;
  trackEditorActions(
    editorActions: EditorActions & {
      _contentRetrievalTracking?: {
        getValueTracked: boolean;
        samplingCounters: {
          success: number;
          failure: number;
        };
      };
    },
    props: EditorProps,
  ): EditorActions<any> & {
    _contentRetrievalTracking?:
      | {
          getValueTracked: boolean;
          samplingCounters: {
            success: number;
            failure: number;
          };
        }
      | undefined;
  };
  prepareExtensionProvider: MemoizedFn<
    (
      extensionProviders?: ExtensionProvidersProp | undefined,
    ) => ExtensionProvider<any> | undefined
  >;
  prepareQuickInsertProvider: (
    extensionProvider?: ExtensionProvider<any> | undefined,
    quickInsert?: QuickInsertOptions | undefined,
  ) => Promise<QuickInsertProvider> | undefined;
  onEditorCreated(instance: {
    view: EditorView;
    eventDispatcher: EventDispatcher;
    transformer?: Transformer_2<string>;
  }): void;
  private sendDurationAnalytics;
  private deprecationWarnings;
  onEditorDestroyed(_instance: {
    view: EditorView;
    transformer?: Transformer_2<string>;
  }): void;
  private registerEditorForActions;
  private unregisterEditorFromActions;
  private handleProviders;
  private getBaseFontSize;
  handleSave: (view: EditorView) => void;
  handleAnalyticsEvent: FireAnalyticsCallback;
  render(): jsx.JSX.Element;
}

export declare class EditorActions<T = any> implements EditorActionsOptions<T> {
  private editorView?;
  private contentTransformer?;
  private contentEncode?;
  private eventDispatcher?;
  private listeners;
  static from<T>(
    view: EditorView,
    eventDispatcher: EventDispatcher,
    transformer?: Transformer_2<T>,
  ): EditorActions<T>;
  _privateGetEditorView(): EditorView | undefined;
  _privateGetEventDispatcher(): EventDispatcher | undefined;
  _privateRegisterEditor(
    editorView: EditorView,
    eventDispatcher: EventDispatcher,
    contentTransformer?: Transformer_2<T>,
  ): void;
  _privateUnregisterEditor(): void;
  _privateSubscribe(cb: ContextUpdateHandler): void;
  _privateUnsubscribe(cb: ContextUpdateHandler): void;
  focus(): boolean;
  blur(): boolean;
  clear(): boolean;
  __temporaryFixForConfigPanel(): Promise<void>;
  getValue(): Promise<JSONDocNode | T | undefined>;
  getNodeByLocalId(id: string): Node_2 | undefined;
  /**
   * This method will return the currently selected `Node` if the selection is a `Node`.
   * Otherwise, if the selection is textual or a non-selectable `Node` within another selectable `Node`, the closest selectable parent `Node` will be returned.
   */
  getSelectedNode(): Node_2 | undefined;
  isDocumentEmpty(): boolean;
  replaceDocument(
    rawValue: any,
    shouldScrollToBottom?: boolean,
    /** @deprecated [ED-14158] shouldAddToHistory is not being used in this function */
    shouldAddToHistory?: boolean,
  ): boolean;
  replaceSelection(
    rawValue: Node_2 | Object | string,
    tryToReplace?: boolean,
  ): boolean;
  appendText(text: string): boolean;
  dispatchAnalyticsEvent: (payload: AnalyticsEventPayload_2) => void;
  /**
   * If editor is using new collab service,
   * we want editor to call the collab provider to
   * retrieve the final acknowledged state of the
   * editor. The final acknowledged editor state
   * refers to the latest state of editor with confirmed
   * steps.
   */
  getResolvedEditorState: () => Promise<ResolvedEditorState | undefined>;
}

declare interface EditorActionsOptions<T> {
  focus(): boolean;
  blur(): boolean;
  clear(): boolean;
  getValue(): Promise<T | JSONDocNode | undefined>;
  getNodeByLocalId(id: string): Node_2 | undefined;
  getSelectedNode(): Node_2 | undefined;
  replaceDocument(rawValue: any): boolean;
  replaceSelection(rawValue: Node_2 | Object | string): boolean;
  appendText(text: string): boolean;
  isDocumentEmpty(): boolean;
  getResolvedEditorState(): Promise<ResolvedEditorState | undefined>;
}

declare type EditorAppearance =
  | 'comment'
  | 'full-page'
  | 'full-width'
  | 'chromeless'
  | 'mobile';

declare interface EditorAppearanceComponentProps {
  appearance?: EditorAppearance;
  onSave?: (editorView: EditorView) => void;
  onCancel?: (editorView: EditorView) => void;
  providerFactory: ProviderFactory;
  editorActions?: EditorActions;
  editorDOMElement: JSX.Element;
  editorView?: EditorView;
  eventDispatcher?: EventDispatcher;
  dispatchAnalyticsEvent?: DispatchAnalyticsEvent;
  maxHeight?: number;
  minHeight?: number;
  contentComponents?: UIComponentFactory[];
  primaryToolbarComponents?: ToolbarUIComponentFactory[];
  primaryToolbarIconBefore?: ReactElement;
  secondaryToolbarComponents?: UIComponentFactory[];
  customContentComponents?: ReactComponents;
  customPrimaryToolbarComponents?: PrimaryToolbarComponents;
  customSecondaryToolbarComponents?: ReactComponents;
  insertMenuItems?: MenuItem[];
  contextPanel?: ReactComponents;
  popupsMountPoint?: HTMLElement;
  popupsBoundariesElement?: HTMLElement;
  popupsScrollableElement?: HTMLElement;
  extensionHandlers?: ExtensionHandlers;
  disabled?: boolean;
  collabEdit?: CollabEditOptions;
  persistScrollGutter?: boolean;
  enableToolbarMinWidth?: boolean;
  featureFlags?: EditorFeatureFlags;
  useStickyToolbar?: boolean | RefObject<HTMLElement>;
}

declare interface EditorConfig {
  nodes: NodeConfig[];
  marks: MarkConfig[];
  pmPlugins: Array<PMPlugin>;
  contentComponents: UIComponentFactory[];
  primaryToolbarComponents: ToolbarUIComponentFactory[];
  secondaryToolbarComponents: UIComponentFactory[];
  onEditorViewStateUpdatedCallbacks: Array<{
    pluginName: string;
    callback: (props: EditorViewStateUpdatedCallbackProps_2) => void;
  }>;
}

declare type EditorContentRetrievalPerformedAEP = OperationalAEP<
  ACTION.EDITOR_CONTENT_RETRIEVAL_PERFORMED,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    success: boolean;
    errorInfo?: string;
    errorStack?: string;
  },
  undefined
>;

export declare class EditorContext extends React_2.Component<
  EditorContextProps,
  {}
> {
  static childContextTypes: {
    editorActions: PropTypes.Requireable<object>;
  };
  private editorActions;
  constructor(props: EditorContextProps);
  getChildContext(): {
    editorActions: EditorActions<any>;
  };
  render(): JSX.Element;
}

declare type EditorContextProps = {
  editorActions?: EditorActions;
};

/**
 * Feature Flags for experimental features/behaviours.
 *
 * This feature flags are not meant to be used as plugin configuration and are only for temporary flags that will eventually be enabled be default or removed.
 * If your plugin requires permanent configuration options it's better to keep them in plugin options.
 *
 * # ADDING NEW FEATURE FLAG
 *
 * – Every feature flag must have a description explaining what it's meant to be doing.
 * – Every feature flag must have an associated ticket and a DUE DATE when this flag will be removed and an owner who will remove it.
 *
 * ## TEMPLATE
 *
 * When adding a new feature flag use the following template:
 *
 * ```
 * @description
 * What this feature flag is doing. Do not lead with "Feature flag to".
 *
 * @see https://product-fabric.atlassian.net/browse/ED-1
 * @default false
 * ```
 *
 * ## NAMING
 * – Name feature flags without `allow`.
 * – A name should read as "Feature flag to enable ...".
 *
 * Example: name = "newInsertionBehaviour" -> "Enable new insertion behaviour"
 */
export declare type EditorFeatureFlags = {
  /**
   * @description Enable single layout option
   *
   * @see https://hello.atlassian.net/browse/LOVE-187
   * @default false
   */
  singleLayout?: boolean;
  /**
   * @description Enable new insertion behaviour
   *
   * @see https://product-fabric.atlassian.net/l/c/JYoSEu00
   * @default false
   */
  newInsertionBehaviour?: boolean;
  /**
   * @description Allows to toggle expand open state
   * @default true
   */
  interactiveExpand?: boolean;
  /**
   * @description
   * Whether a placeholder bracket hint was provided (`string => boolean`)
   * Placeholder text to be displayed when a bracket '{' is typed and the line is empty e.g. 'Did you mean to use '/' to insert content?'
   * This is used to aid migration for TinyMCE power users to the new Fabric editor power user shortcuts.
   *
   * @see https://product-fabric.atlassian.net/l/c/4JLjusAP
   * @default true
   */
  placeholderBracketHint?: boolean;
  /**
   * @description
   * Whether placeholder hints were provided (`string[] => boolean`)
   * Placeholder text values to display on new empty lines.
   *
   * @see https://product-fabric.atlassian.net/l/c/GG1Yv9cK
   * @default false
   */
  placeholderHints?: boolean;
  /**
   * @description
   * Enable additional text colours within the colour palette.
   *
   * @see https://product-fabric.atlassian.net/l/c/YhyvfWqg
   * @default false
   */
  moreTextColors?: boolean;
  /**
   * @description
   * Enable find/replace functionality within the editor
   *
   * @see https://product-fabric.atlassian.net/browse/ED-3504
   * @default false
   */
  findReplace?: boolean;
  /**
   * @description
   * Enable case matching functionality in find/replace feature within the editor
   *
   * @see https://product-fabric.atlassian.net/browse/ED-9684
   * @default false
   */
  findReplaceMatchCase?: boolean;
  /**
   * @description
   * Enable `localId` generation for extensions.
   *
   * @see https://product-fabric.atlassian.net/l/c/2m0i9jLX
   * @default false
   */
  extensionLocalIdGeneration?: boolean;
  /**
   * @description
   * Enable date picker which has a textbox for internationalised keyboard date
   * input.
   *
   * @see https://product-fabric.atlassian.net/browse/ED-8928
   * @default false
   */
  keyboardAccessibleDatepicker?: boolean;
  /**
   * @description
   * Enable add column custom step
   *
   * @see https://product-fabric.atlassian.net/browse/ED-8856
   * @default false
   */
  addColumnWithCustomStep?: boolean;
  /**
   * @description
   * Enable undo/redo buttons and functionality within the editor
   *
   * @see https://product-fabric.atlassian.net/browse/ED-9537
   * @default false
   */
  undoRedoButtons?: boolean;
  /**
   * @description
   * Measure render performance for all tracked analytics events
   *
   * @default false
   */
  catchAllTracking?: boolean;
  /**
   * @description
   * Enables performance optimization for sticky headers in tables
   *
   * @see https://product-fabric.atlassian.net/browse/ED-11807
   * @default false
   */
  stickyHeadersOptimization?: boolean;
  /**
   * @description
   * Enables performance optimization for initial table render
   *
   * @see https://product-fabric.atlassian.net/browse/ED-11647
   * @default false
   */
  initialRenderOptimization?: boolean;
  /**
   * @description
   * Enables performance optimization for mousemove inside table
   *
   * @see https://product-fabric.atlassian.net/browse/ED-11577
   * @default false
   */
  mouseMoveOptimization?: boolean;
  /**
   * @description
   * Enables performance optimization for table rendering on keypress
   *
   * @see https://product-fabric.atlassian.net/browse/ED-11640
   * @default false
   */
  tableRenderOptimization?: boolean;
  /**
   * @description
   * Enables performance optimization for table rendering on keypress
   *
   * @see https://product-fabric.atlassian.net/browse/ED-11781
   * @default false
   */
  tableOverflowShadowsOptimization?: boolean;
  /**
   * @decsription
   * Enables optional code syntax highlighting for code-block nodes
   *
   * @see https://product-fabric.atlassian.net/browse/ED-10368
   * @default false
   */
  codeBlockSyntaxHighlighting?: boolean;
  /**
   * @description
   * Disables decorating code snippets with bidi character warnings
   * when they are used in inline code and code blocks.
   *
   * @see https://product-fabric.atlassian.net/browse/ED-13860
   * @default true
   */
  codeBidiWarnings?: boolean;
  /**
   * @description
   * Yield to user interaction work before sending analytics
   *
   * @see https://product-fabric.atlassian.net/browse/ED-10584
   * @default false
   */
  queueAnalytics?: boolean;
  /**
   * Enable extend floating toolbars
   * @see https://product-fabric.atlassian.net/browse/ED-11963
   * @default false
   */
  extendFloatingToolbar?: boolean;
  /**
   * Set editor to use the input rule with unpredictable undo results
   * @see https://product-fabric.atlassian.net/browse/ED-12676
   * @default true
   */
  useUnpredictableInputRule?: boolean;
  /**
   * Show the avatar group as a plugin
   * @see https://product-fabric.atlassian.net/browse/CERN-747
   * @default false
   */
  showAvatarGroupAsPlugin?: boolean;
  /**
   * @description
   * Enables docStructure for unhandleErrorEvents
   *
   * @see https://product-fabric.atlassian.net/browse/ED-12998
   * @default false
   */
  errorBoundaryDocStructure?: boolean;
  /**
   * @description
   * Enables docStructure for synchronyError
   *
   * @see https://product-fabric.atlassian.net/browse/ED-12998
   * @default false
   */
  synchronyErrorDocStructure?: boolean;
  /**
   * @decsription
   * Enables the view update subscription plugin
   *
   * @default false
   */
  enableViewUpdateSubscription?: boolean;
  /**
   * @description
   * Enable scroll-to-telepointer for collab avatars
   *
   * @see https://product-fabric.atlassian.net/browse/ED-12460
   * @default false
   */
  collabAvatarScroll?: boolean;
  /**
   * @description
   * Enable UFO experiences
   *
   * @see https://product-fabric.atlassian.net/browse/ED-13059
   * @default false
   */
  ufo?: boolean;
  /**
   * Split editor toolbar to two lines when viewport is small
   * @see https://product-fabric.atlassian.net/browse/CERN-1124
   * @default false
   */
  twoLineEditorToolbar?: boolean;
  /**
   * Prevent transactions from being mutated (e.g. apply, filterTransaction,
   * appendTransaction) after being dispatched
   * @see https://product-fabric.atlassian.net/wiki/spaces/E/pages/3131836958/Editor+DACI+013+Avoid+content+loss+with+bad+transactions+Ghost+Steps
   * @see https://product-fabric.atlassian.net/browse/ED-14002
   * @default false
   */
  saferDispatchedTransactions?: boolean;
  /**
   * Disable Spellchecking for chrome version below the max unsafe number
   * @see https://ops.internal.atlassian.com/jira/browse/HOT-97409
   * @default null
   */
  maxUnsafeChromeSpellcheckingVersion?: number;
  /**
   * Create non-smart hyperlinks on plain text paste (Cmd/Ctrl+Shift+v)
   * @see https://product-fabric.atlassian.net/browse/EDM-2492
   * @default false
   */
  plainTextPasteLinkification?: boolean;
  /**
   * @description
   * Enable new collab service
   * @see https://product-fabric.atlassian.net/browse/ED-14097
   * @default false
   */
  useNativeCollabPlugin?: boolean;
  /**
   * Enable custom up/down key handler when cursor below/above an inline media
   * @see https://product-fabric.atlassian.net/browse/ED-13066
   * Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1227468
   * @default undefined
   */
  chromeCursorHandlerFixedVersion?: number;
  /**
   * Number to distinguish between which different toolbar is being displayed
   * as part of the smart link view changing experiment run by the Linking Platform.
   * @see https://product-fabric.atlassian.net/browse/EDM-2640
   * @default null
   */
  viewChangingExperimentToolbarStyle?: string;
  /**
   * @description
   * Enable display of a prewiew modal on mouse over of inline smart card
   *
   * @see https://product-fabric.atlassian.net/browse/EDM-2860
   * @default false
   */
  showHoverPreview?: boolean;
};

export declare interface EditorInstance {
  editorView: EditorView;
  eventDispatcher: EventDispatcher;
  contentComponents: UIComponentFactory[];
  primaryToolbarComponents: ToolbarUIComponentFactory[];
  secondaryToolbarComponents: UIComponentFactory[];
  onEditorViewStateUpdatedCallbacks: {
    pluginName: string;
    callback: OnEditorViewStateUpdated;
  }[];
  contentTransformer?: Transformer<string>;
  insertMenuItems?: MenuItem[];
}

declare type EditorOnChangeHandler = (
  editorView: EditorView,
  meta: {
    source: 'local' | 'remote';
  },
) => void;

declare type EditorPerfAEP = OperationalAEPWithObjectId<
  | ACTION.EDITOR_MOUNTED
  | ACTION.PROSEMIRROR_RENDERED
  | ACTION.ON_EDITOR_READY_CALLBACK
  | ACTION.ON_CHANGE_CALLBACK,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    duration: number;
    startTime: number;
    nodes?: Record<string, number>;
    ttfb?: number;
    severity?: SEVERITY;
  },
  undefined
>;

export declare interface EditorPlugin {
  /**
   * Name of a plugin, that other plugins can use to provide options to it or exclude via a preset.
   */
  name: string;
  /**
   * Options that will be passed to a plugin with a corresponding name if it exists and enabled.
   */
  pluginsOptions?: PluginsOptions;
  /**
   * List of ProseMirror-plugins. This is where we define which plugins will be added to EditorView (main-plugin, keybindings, input-rules, etc.).
   */
  pmPlugins?: (pluginOptions?: any) => Array<PMPlugin>;
  /**
   * List of Nodes to add to the schema.
   */
  nodes?: () => NodeConfig[];
  /**
   * List of Marks to add to the schema.
   */
  marks?: () => MarkConfig[];
  /**
   * Optional UI-component that lives inside the actual content-area (like mention-picker, floating toolbar for links, etc.)
   */
  contentComponent?: UIComponentFactory;
  /**
   * Optional UI-component that will be added to the toolbar at the top of the editor (doesn't exist in the compact-editor).
   */
  primaryToolbarComponent?: ToolbarUIComponentFactory;
  /**
   * Optional UI-component that will be added to the toolbar at the bottom right of the editor. (doesn't exist in the full-page editor)
   * In compact mode this toolbar lives on the right-hand side of the editor.
   */
  secondaryToolbarComponent?: UIComponentFactory;
  onEditorViewStateUpdated?: (
    props: EditorViewStateUpdatedCallbackProps,
  ) => void;
}

declare interface EditorPresetProps {
  excludes?: Set<string>;
  experimental?: Array<string>;
  featureFlags?: EditorFeatureFlags;
}

declare type EditorProduct =
  | 'bitbucket'
  | 'jira'
  | 'confluence'
  | 'stride'
  | undefined;

export declare interface EditorProps {
  appearance?: EditorAppearance;
  contentComponents?: ReactComponents;
  primaryToolbarComponents?: PrimaryToolbarComponents;
  primaryToolbarIconBefore?: ReactElement;
  secondaryToolbarComponents?: ReactComponents;
  allowAnalyticsGASV3?: boolean;
  allowBlockType?: BlockTypePluginOptions['allowBlockType'];
  allowTasksAndDecisions?: boolean;
  allowBreakout?: boolean;
  allowRule?: boolean;
  allowTextColor?: boolean | TextColorPluginConfig;
  allowTables?: boolean | PluginConfig;
  allowHelpDialog?: boolean;
  feedbackInfo?: FeedbackInfo;
  allowJiraIssue?: boolean;
  allowPanel?: boolean | PanelPluginConfig;
  allowExtension?: boolean | ExtensionConfig;
  allowConfluenceInlineComment?: boolean;
  allowTemplatePlaceholders?: boolean | PlaceholderTextOptions;
  allowDate?: boolean;
  allowLayouts?: boolean | LayoutPluginOptions;
  allowStatus?:
    | boolean
    | {
        menuDisabled: boolean;
      };
  /**
   * @deprecated [ED-14507] This feature has been turned off since 2020
   * and is no longer affecting any behaviour
   */
  allowDynamicTextSizing?: boolean;
  allowTextAlignment?: boolean;
  allowIndentation?: boolean;
  /**
   * This enables new insertion behaviour only for horizontal rule and media single in certain conditions.
   * The idea of this new behaviour is to have a consistent outcome regardless of the insertion method.
   **/
  allowNewInsertionBehaviour?: boolean;
  /**
   * Set this to false to opt out of the default behaviour of auto scrolling into view
   * whenever the document is changed
   */
  autoScrollIntoView?: boolean;
  allowFindReplace?: boolean | FindReplaceOptions;
  persistScrollGutter?: boolean;
  quickInsert?: QuickInsertOptions;
  /** @deprecated Use smartLinks instead. */
  UNSAFE_cards?: CardOptions;
  smartLinks?: CardOptions;
  allowExpand?:
    | boolean
    | {
        allowInsertion?: boolean;
        allowInteractiveExpand?: boolean;
      };
  saveOnEnter?: boolean;
  shouldFocus?: boolean;
  disabled?: boolean;
  contextPanel?: ReactComponents;
  errorReporterHandler?: ErrorReportingHandler;
  uploadErrorHandler?: (state: MediaState) => void;
  activityProvider?: Promise<ActivityProvider>;
  searchProvider?: Promise<SearchProvider>;
  annotationProviders?: AnnotationProviders;
  collabEditProvider?: Providers['collabEditProvider'];
  presenceProvider?: Promise<any>;
  emojiProvider?: Providers['emojiProvider'];
  taskDecisionProvider?: Promise<TaskDecisionProvider>;
  allowNestedTasks?: boolean;
  contextIdentifierProvider?: Promise<ContextIdentifierProvider>;
  legacyImageUploadProvider?: Providers['imageUploadProvider'];
  mentionProvider?: Promise<MentionProvider>;
  mention?: MentionPluginConfig;
  autoformattingProvider?: Providers['autoformattingProvider'];
  macroProvider?: Providers['macroProvider'];
  waitForMediaUpload?: boolean;
  contentTransformerProvider?: (schema: Schema) => Transformer_2<string>;
  media?: MediaOptions;
  collabEdit?: CollabEditOptions;
  textFormatting?: TextFormattingOptions;
  maxHeight?: number;
  minHeight?: number;
  maxContentSize?: number;
  placeholder?: string;
  placeholderHints?: string[];
  placeholderBracketHint?: string;
  allowKeyboardAccessibleDatepicker?: boolean;
  defaultValue?: Node_2 | string | Object;
  popupsMountPoint?: HTMLElement;
  popupsBoundariesElement?: HTMLElement;
  popupsScrollableElement?: HTMLElement;
  insertMenuItems?: MenuItem[];
  editorActions?: EditorActions;
  onEditorReady?: (editorActions: EditorActions) => void;
  onDestroy?: () => void;
  onChange?: EditorOnChangeHandler;
  onSave?: (editorView: EditorView) => void;
  onCancel?: (editorView: EditorView) => void;
  extensionHandlers?: ExtensionHandlers;
  sanitizePrivateContent?: boolean;
  /**
   * flag to indicate display name instead of nick name should be inserted for mentions
   * default: false, which inserts the nick name
   * @deprecated Use mention.mentionInsertDisplayName instead
   */
  mentionInsertDisplayName?: boolean;
  /**
   * @description The nth keystroke after which an input time taken event is sent, 0 to disable it
   * @default 100
   * @deprecated Use performanceTracking.inputSampling instead https://product-fabric.atlassian.net/browse/ED-10260
   */
  inputSamplingLimit?: number;
  extensionProviders?: ExtensionProvidersProp;
  UNSAFE_useAnalyticsContext?: boolean;
  /**
   * @description Control performance metric measurements and tracking
   */
  performanceTracking?: PerformanceTracking;
  elementBrowser?: {
    showModal?: boolean;
    replacePlusMenu?: boolean;
    helpUrl?: string;
    emptyStateHandler?: EmptyStateHandler;
  };
  codeBlock?: CodeBlockOptions;
  UNSAFE_allowUndoRedoButtons?: boolean;
  /**
   * @default undefined
   * @description Enables valid transaction events to be tracked in analytics (at a sampled rate)
   */
  trackValidTransactions?:
    | {
        samplingRate: number;
      }
    | boolean;
  /**
   * @default undefined
   * @description
   * Enables the sticky toolbar in the comment/standard editor.
   * If a boolean is specified and it's `true`, the sticky toolbar will be enabled, sticking to the top of the scroll parent.
   * Instead a reference can be specified to an existing sticky toolbar on the page that the editor toolbar should stay below (experimental).
   */
  useStickyToolbar?: boolean | RefObject<HTMLElement>;
  /**
   * @default undefined
   * @description
   * Short lived feature flags for experiments and gradual rollouts
   * Flags are expected to follow these rules or they are filtered out
   *
   * 1. cased in kebab-case (match [a-z-])
   * 2. have boolean values
   *
   * @example
   * ```tsx
   * (<Editor featureFlags={{ 'my-feature': true }} />);
   * getFeatureFlags()?.myFeature === true;
   * ```
   *
   * @example
   * ```tsx
   * (<Editor featureFlags={{ 'my-feature': 'thing' }} />);
   * getFeatureFlags()?.myFeature === undefined;
   * ```
   *
   * @example
   * ```tsx
   * (<Editor featureFlags={{ 'product.my-feature': false }} />);
   * getFeatureFlags()?.myFeature === undefined;
   * getFeatureFlags()?.productMyFeature === undefined;
   * ```
   */
  featureFlags?: {
    [featureFlag: string]: string | boolean;
  };
  /**
   * Enable support for the "fragment" mark.
   * Refer to ADF Change proposal #60 for more details.
   */
  allowFragmentMark?: boolean;
  /**
   * @deprecated Do not use outside of Editor team.
   * This has subtle side effects - you __WILL__ break functionality without implementer knowledge of editor-core internals
   */
  dangerouslyAppendPlugins?: {
    /**
     * @deprecated Do not use outside of Editor team.
     */
    __plugins: EditorPlugin[];
  };
}

declare type EditorProps_2 = {
  plugins?: Array<EditorPlugin>;
  transformer?: (schema: Schema) => Transformer_2<any>;
  children?: React.ReactChild;
  defaultValue?: string | object;
  popupsMountPoint?: HTMLElement;
  popupsBoundariesElement?: HTMLElement;
  popupsScrollableElement?: HTMLElement;
  disabled?: boolean;
  placeholder?: string;
  onAnalyticsEvent?: FireAnalyticsCallback;
  onChange?: (
    value: any,
    meta: {
      source: 'remote' | 'local';
    },
  ) => void;
  onSave?: (value: any) => void;
  onCancel?: (value: any) => void;
  onMount?: (actions: EditorActions) => void;
  onDestroy?: () => void;
};

declare type EditorReactContext = {
  getAtlaskitAnalyticsEventHandlers: () => UIAnalyticsEventHandler[];
  intl: IntlShape;
};

declare type EditorRenderedAEP<T> = OperationalAEP<
  ACTION.RE_RENDERED,
  ACTION_SUBJECT.EDITOR | ACTION_SUBJECT.REACT_EDITOR_VIEW,
  undefined,
  {
    propsDifference: PropsDifference<T> | ShallowPropsDifference<T>;
    count: number;
  },
  undefined
>;

/**
 * Provides access to most commonly used configurations and instances of classes,
 * that most editor components rely on.
 */
declare type EditorSharedConfig = {
  editorView: EditorView;
  eventDispatcher: EventDispatcher;
  dispatch: Dispatch;
  transformer?: Transformer_2<any>;
  dispatchAnalyticsEvent?: FireAnalyticsCallback;
  primaryToolbarComponents: EditorAppearanceComponentProps['primaryToolbarComponents'];
  contentComponents: EditorAppearanceComponentProps['contentComponents'];
  popupsMountPoint: EditorProps_2['popupsMountPoint'];
  popupsBoundariesElement: EditorProps_2['popupsBoundariesElement'];
  popupsScrollableElement: EditorProps_2['popupsScrollableElement'];
  providerFactory: EditorAppearanceComponentProps['providerFactory'];
  editorActions: EditorActions;
  onChange?: EditorProps_2['onChange'];
  onDestroy?: EditorProps_2['onDestroy'];
  onMount?: EditorProps_2['onMount'];
};

declare type EditorStartAEP = UIAEP<
  ACTION.STARTED,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    platform: PLATFORMS.NATIVE | PLATFORMS.HYBRID | PLATFORMS.WEB;
    featureFlags: FeatureFlagKey[];
  },
  undefined
>;

declare type EditorStopAEP = UIAEP<
  ACTION.STOPPED,
  ACTION_SUBJECT.EDITOR,
  ACTION_SUBJECT_ID.SAVE | ACTION_SUBJECT_ID.CANCEL,
  {
    inputMethod: INPUT_METHOD.TOOLBAR | INPUT_METHOD.SHORTCUT;
    documentSize: number;
    nodeCount?: {
      tables: number;
      headings: number;
      lists: number;
      mediaSingles: number;
      mediaGroups: number;
      panels: number;
      extensions: number;
      decisions: number;
      actions: number;
      codeBlocks: number;
    };
  },
  undefined
>;

declare type EditorTTIAEP = OperationalAEP<
  ACTION.EDITOR_TTI,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    tti: number;
    ttiFromInvocation: number;
    canceled: boolean;
    ttiSeverity?: SEVERITY;
    ttiFromInvocationSeverity?: SEVERITY;
  },
  undefined
>;

declare interface EditorViewProps {
  editorProps: EditorProps;
  createAnalyticsEvent?: CreateUIAnalyticsEvent;
  providerFactory: ProviderFactory;
  portalProviderAPI: PortalProviderAPI;
  allowAnalyticsGASV3?: boolean;
  disabled?: boolean;
  experienceStore?: ExperienceStore;
  render?: (props: {
    editor: JSX.Element;
    view?: EditorView;
    config: EditorConfig;
    eventDispatcher: EventDispatcher;
    transformer?: Transformer_2<string>;
    dispatchAnalyticsEvent: DispatchAnalyticsEvent;
  }) => JSX.Element;
  onEditorCreated: (instance: {
    view: EditorView;
    config: EditorConfig;
    eventDispatcher: EventDispatcher;
    transformer?: Transformer_2<string>;
  }) => void;
  onEditorDestroyed: (instance: {
    view: EditorView;
    config: EditorConfig;
    eventDispatcher: EventDispatcher;
    transformer?: Transformer_2<string>;
  }) => void;
}

declare type EditorViewStateUpdatedCallbackProps = {
  readonly originalTransaction: Readonly<Transaction>;
  readonly transactions: Transaction[];
  readonly oldEditorState: Readonly<EditorState>;
  readonly newEditorState: Readonly<EditorState>;
};

declare type EditorViewStateUpdatedCallbackProps_2 = {
  readonly originalTransaction: Readonly<Transaction>;
  readonly transactions: Transaction[];
  readonly oldEditorState: Readonly<EditorState>;
  readonly newEditorState: Readonly<EditorState>;
};

declare type EditState = {
  type: HyperlinkInsertStatus.EDIT_LINK_TOOLBAR;
  node: Node_2;
  pos: number;
};

declare type ElementBrowserEventPayload =
  | OpenAEP_2
  | CloseAEP_2
  | ClickedElementBrowserCategory;

export { EmojiResource };

declare type EmptyStateHandler = (
  params: EmptyStateHandlerParams,
) => React.ReactElement<any> | null;

declare type EmptyStateHandlerParams = {
  mode: string;
  selectedCategory?: string;
  searchTerm?: string;
};

declare type EnteredTextLinkSearchInputAEP = UIAEP<
  ACTION.ENTERED,
  ACTION_SUBJECT.TEXT,
  ACTION_SUBJECT_ID.LINK_SEARCH_INPUT,
  {
    queryLength: number;
    queryVersion: number;
    queryHash: string;
    searchSessionId: string;
    wordCount: number;
    source: string;
  },
  {
    query: string;
  }
>;

declare type ErrorEventAttributes = {
  error: Error;
  errorInfo: React.ErrorInfo;
  product?: string;
  browserInfo?: string;
  errorId?: string;
  docStructure?: string | SimplifiedNode;
  browserExtensions?: UserBrowserExtensionResults;
};

declare type ErrorEventPayload =
  | InvalidTransactionErrorAEP
  | InvalidTransactionStepErrorAEP
  | FailedToUnmountErrorAEP
  | SynchronyErrorAEP
  | InvalidDocumentEncounteredAEP
  | SynchronyEntityErrorAEP
  | ContentComponentErrorAEP
  | ComponentCrashErrorAEP
  | ComponentCrashAdditionalInfoErrorAEP
  | SmartLinkErrorAEP;

export declare enum EVENT_TYPE {
  OPERATIONAL = 'operational',
  SCREEN = 'screen',
  TRACK = 'track',
  UI = 'ui',
}

export declare class EventDispatcher<T = any> {
  private listeners;
  on(event: string, cb: Listener_2<T>): void;
  has(event: string, cb: Listener_2<T>): boolean;
  off(event: string, cb: Listener_2<T>): void;
  emit(event: string, data: T): void;
  destroy(): void;
}

declare type ExpandToggleAEP = TrackAEP<
  ACTION.TOGGLE_EXPAND,
  ACTION_SUBJECT.EXPAND | ACTION_SUBJECT.NESTED_EXPAND,
  undefined,
  {
    platform: PLATFORMS;
    mode: MODE;
    expanded: boolean;
  },
  undefined
>;

declare type ExperimentalAEP<
  Action,
  ActionSubject,
  ActionSubjectId,
  Attributes
> = TrackAEP<
  Action,
  ActionSubject,
  ActionSubjectId,
  Attributes & {
    experiment: string;
    experimentGroup: string;
  },
  undefined
>;

declare type ExperimentalEventPayload =
  | TextColorSelectedAEP
  | TextColorShowPaletteToggleAEP;

declare type ExtensionAPICalledPayload = TrackAEP<
  ACTION.INVOKED,
  ACTION_SUBJECT.EXTENSION,
  ACTION_SUBJECT_ID.EXTENSION_API,
  {
    functionName: string;
  },
  INPUT_METHOD.EXTENSION_API
>;

declare interface ExtensionConfig {
  stickToolbarToBottom?: boolean;
  allowBreakout?: boolean;
  allowAutoSave?: boolean;
  allowExtendFloatingToolbars?: boolean;
}

declare type ExtensionEventPayload =
  | ExtensionUpdateAEP
  | ExtensionAPICalledPayload;

declare type ExtensionProviders = (
  | ExtensionProvider
  | Promise<ExtensionProvider>
)[];

declare type ExtensionProvidersProp =
  | ExtensionProviders
  | ExtensionProvidersWithEditorAction;

declare type ExtensionProvidersWithEditorAction = (
  editorActions?: EditorActions,
) => ExtensionProviders;

export { ExtensionType };

declare type ExtensionType_2 =
  | ACTION_SUBJECT_ID.EXTENSION_BLOCK
  | ACTION_SUBJECT_ID.EXTENSION_BODIED
  | ACTION_SUBJECT_ID.EXTENSION_INLINE;

declare type ExtensionUpdateAEP = TrackAEP<
  ACTION.UPDATED | ACTION.ERRORED,
  ACTION_SUBJECT.EXTENSION,
  ExtensionType_2,
  {
    extensionType: string;
    /**
     * extensionkey follows this format:
     * `${manifest.key}:${manifest.modules.nodes.name}`
     * e.g: 'awesome:item', 'awesome:default', 'awesome:list'
     */
    extensionKey: string;
    layout?: ExtensionLayout;
    localId?: string;
    selection: SelectionJson;
    targetSelectionSource: TARGET_SELECTION_SOURCE;
  },
  INPUT_METHOD.MACRO_BROWSER | INPUT_METHOD.CONFIG_PANEL | INPUT_METHOD.TOOLBAR
>;

declare type FailedToUnmountErrorAEP = OperationalAEP<
  ACTION.FAILED_TO_UNMOUNT,
  ACTION_SUBJECT.EDITOR,
  ACTION_SUBJECT_ID.REACT_NODE_VIEW,
  {
    error: Error;
    domNodes: {
      container?: string;
      child?: string;
    };
  },
  undefined
>;

declare type FeatureExposureAEP = OperationalExposureAEP<
  ACTION.EXPOSED,
  ACTION_SUBJECT.FEATURE,
  undefined,
  {
    flagKey: string;
    value: string | boolean;
  }
>;

declare type FeatureFlagKey = keyof EditorFeatureFlags;

declare type FeedbackAEP = UIAEP<
  ACTION.OPENED,
  ACTION_SUBJECT.FEEDBACK_DIALOG,
  undefined,
  {
    inputMethod: INPUT_METHOD.QUICK_INSERT;
  },
  undefined
>;

declare type FeedbackInfo = {
  product?: string;
  packageVersion?: string;
  packageName?: string;
  labels?: Array<string>;
  sessionId?: string;
  contentId?: string;
  tabId?: string;
};

declare type FindAEP = TrackAEP<
  ACTION.FIND_PERFORMED,
  ACTION_SUBJECT.TEXT,
  undefined,
  undefined,
  undefined
>;

declare type FindNextAEP = TrackAEP<
  ACTION.FIND_NEXT_PERFORMED,
  ACTION_SUBJECT.TEXT,
  undefined,
  {
    triggerMethod: TRIGGER_METHOD.KEYBOARD | TRIGGER_METHOD.BUTTON;
  },
  undefined
>;

declare type FindPrevAEP = TrackAEP<
  ACTION.FIND_PREV_PERFORMED,
  ACTION_SUBJECT.TEXT,
  undefined,
  {
    triggerMethod: TRIGGER_METHOD.KEYBOARD | TRIGGER_METHOD.BUTTON;
  },
  undefined
>;

declare type FindReplaceEventPayload =
  | ActivateAEP
  | DeactivateAEP
  | FindAEP
  | FindNextAEP
  | FindPrevAEP
  | ReplaceTextChangeAEP
  | ReplaceOneAEP
  | ReplaceAllAEP;

declare type FindReplaceOptions = {
  allowMatchCase?: boolean;
};

declare type FireAnalyticsCallback = <T>(
  payload: FireAnalyticsEventPayload<T>,
) => void | undefined;

declare type FireAnalyticsEventPayload<T = void> = {
  payload: AnalyticsEventPayload<T>;
  channel?: string;
};

declare enum FLOATING_CONTROLS_TITLE {
  CODE_BLOCK = 'codeBlockFloatingControls',
  EXTENSION = 'extensionFloatingControls',
  HYPERLINK = 'hyperlinkFloatingControls',
  MEDIA = 'mediaFloatingControls',
  PANEL = 'panelFloatingControls',
  TABLE = 'tableFloatingControls',
  EXPAND = 'expandToolbar',
}

export declare type FloatingToolbarButton<T> = {
  id?: string;
  type: 'button';
  title: string;
  onClick: T;
  showTitle?: boolean;
  onMouseEnter?: T;
  onMouseLeave?: T;
  onFocus?: T;
  onBlur?: T;
  icon?: Icon;
  selected?: boolean;
  disabled?: boolean;
  hidden?: boolean;
  appearance?: ButtonAppearance;
  href?: string;
  target?: string;
  className?: string;
  tooltipContent?: React_2.ReactNode;
  testId?: string;
  hideTooltipOnClick?: boolean;
  confirmDialog?: ConfirmDialogOptions;
  metadata?: {
    [key: string]: string;
  };
  ariaHasPopup?:
    | boolean
    | 'dialog'
    | 'menu'
    | 'listbox'
    | 'tree'
    | 'grid'
    | undefined;
  tabIndex?: number | null | undefined;
};

export declare type FloatingToolbarColorPicker<T> = FloatingToolbarSelectBase<
  T,
  PaletteColor
> & {
  selectType: 'color';
};

export declare interface FloatingToolbarConfig {
  title: string;
  /**
   * Override the DOM reference used to apply as the target for the
   * floating toolbar, if the config matches.
   *
   * By default, it will find the DOM reference of the node from the
   * head of the current selection.
   */
  getDomRef?: (view: EditorView) => HTMLElement | undefined;
  visible?: boolean;
  nodeType: NodeType | NodeType[];
  items:
    | Array<FloatingToolbarItem<Command>>
    | ((node: Node_2) => Array<FloatingToolbarItem<Command>>);
  align?: AlignType;
  className?: string;
  height?: number;
  width?: number;
  offset?: [number, number];
  forcePlacement?: boolean;
  onPositionCalculated?: (
    editorView: EditorView,
    nextPos: Position,
  ) => Position;
}

declare type FloatingToolbarCustom<T> = {
  type: 'custom';
  fallback: Array<FloatingToolbarFallbackItem<T>>;
  render: (
    view?: EditorView,
    idx?: number,
    dispatchAnalyticsEvent?: DispatchAnalyticsEvent,
  ) => React_2.ComponentClass | React_2.SFC | React_2.ReactElement<any> | null;
  hidden?: boolean;
};

export declare type FloatingToolbarDatePicker<T> = FloatingToolbarSelectBase<
  T,
  number
> & {
  selectType: 'date';
  options: never[];
};

export declare type FloatingToolbarDropdown<T> = {
  id?: string;
  type: 'dropdown';
  title: string;
  icon?: Icon;
  options: DropdownOptions<T>;
  hidden?: boolean;
  hideExpandIcon?: boolean;
  disabled?: boolean;
  tooltip?: string;
};

export declare type FloatingToolbarEmojiPicker<T> = FloatingToolbarSelectBase<
  T,
  EmojiId
> & {
  selectType: 'emoji';
  selected?: boolean;
  options: never[];
};

declare type FloatingToolbarExtensionsPlaceholder = {
  type: 'extensions-placeholder';
  hidden?: boolean;
  separator?: 'start' | 'end' | 'both';
};

/**
 * This additional type is introduced in order to prevent infinite loop due to
 * `extract-react-types-loader`. The issue occurs when custom type `fallback` field
 * is an array of FloatingToolbarItem. Since FloatingToolbarItem is a FloatingToolbarCustom
 * type, it stucks in an infinite loop. Custom - Item -> Custom .... go on.
 *
 * This type is restricted with the items that can be used for fallback.
 * Make sure that this type is not a FloatingToolbarCustom type.
 */
declare type FloatingToolbarFallbackItem<T> =
  | FloatingToolbarButton<T>
  | FloatingToolbarDropdown<T>
  | FloatingToolbarSelect<T>
  | FloatingToolbarInput<T>
  | FloatingToolbarSeparator;

declare type FloatingToolbarHandler = (
  state: EditorState,
  intl: IntlShape,
  providerFactory: ProviderFactory,
  cardOptions?: CardOptions,
) => FloatingToolbarConfig | undefined;

export declare type FloatingToolbarInput<T> = {
  id: string;
  type: 'input';
  title?: string;
  description?: string;
  onSubmit: (...args: any[]) => T;
  onBlur: (...args: any[]) => T;
  defaultValue?: string;
  placeholder?: string;
  hidden?: boolean;
};

export declare type FloatingToolbarItem<T> =
  | FloatingToolbarButton<T>
  | FloatingToolbarDropdown<T>
  | FloatingToolbarSelect<T>
  | FloatingToolbarInput<T>
  | FloatingToolbarCustom<T>
  | FloatingToolbarSeparator
  | FloatingToolbarExtensionsPlaceholder;

export declare type FloatingToolbarListPicker<T> = FloatingToolbarSelectBase<
  T
> & {
  selectType: 'list';
};

/**
 *
 * ProseMirror Plugin
 *
 */
export declare const floatingToolbarPluginKey: PluginKey<
  FloatingToolbarPluginState,
  any
>;

export declare type FloatingToolbarPluginState = Record<
  'getConfigWithNodeInfo',
  (state: EditorState) => ConfigWithNodeInfo | null | undefined
>;

export declare type FloatingToolbarSelect<T> =
  | FloatingToolbarEmojiPicker<T>
  | FloatingToolbarColorPicker<T>
  | FloatingToolbarListPicker<T>
  | FloatingToolbarDatePicker<T>;

declare type FloatingToolbarSelectBase<T, V = SelectOption> = {
  id: string;
  type: 'select';
  selectType: 'list' | 'emoji' | 'date' | 'color';
  title?: string;
  options: V[];
  hidden?: boolean;
  hideExpandIcon?: boolean;
  defaultValue?: V | null;
  placeholder?: string;
  onChange: (selected: V) => T;
  filterOption?: ((option: V, rawInput: string) => boolean) | null;
};

declare type FloatingToolbarSeparator = {
  type: 'separator';
  hidden?: boolean;
};

declare type FormatAEP<ActionSubjectID, Attributes> = TrackAEP<
  ACTION.FORMATTED,
  ACTION_SUBJECT.TEXT,
  ActionSubjectID,
  Attributes,
  undefined
>;

declare type FormatBasicAEP = FormatAEP<
  | ACTION_SUBJECT_ID.FORMAT_STRONG
  | ACTION_SUBJECT_ID.FORMAT_ITALIC
  | ACTION_SUBJECT_ID.FORMAT_UNDERLINE
  | ACTION_SUBJECT_ID.FORMAT_CODE
  | ACTION_SUBJECT_ID.FORMAT_STRIKE,
  {
    inputMethod:
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.SHORTCUT
      | INPUT_METHOD.FORMATTING
      | INPUT_METHOD.FLOATING_TB;
  }
>;

declare type FormatBlockQuoteAEP = FormatAEP<
  ACTION_SUBJECT_ID.FORMAT_BLOCK_QUOTE,
  {
    inputMethod:
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU
      | INPUT_METHOD.KEYBOARD
      | INPUT_METHOD.FORMATTING
      | INPUT_METHOD.SHORTCUT
      | INPUT_METHOD.QUICK_INSERT;
  }
>;

declare type FormatClearAEP = FormatAEP<
  ACTION_SUBJECT_ID.FORMAT_CLEAR,
  {
    inputMethod: INPUT_METHOD.TOOLBAR | INPUT_METHOD.SHORTCUT;
    formattingCleared: string[];
  }
>;

declare type FormatColorAEP = FormatAEP<
  ACTION_SUBJECT_ID.FORMAT_COLOR,
  {
    newColor: string;
    previousColor: string;
  }
>;

declare type FormatEventPayload =
  | FormatBasicAEP
  | FormatSuperSubAEP
  | FormatIndentationAEP
  | FormatHeadingAEP
  | FormatBlockQuoteAEP
  | FormatClearAEP
  | FormatColorAEP
  | FormatListAEP;

declare type FormatHeadingAEP = FormatAEP<
  ACTION_SUBJECT_ID.FORMAT_HEADING,
  {
    inputMethod:
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU
      | INPUT_METHOD.KEYBOARD
      | INPUT_METHOD.FORMATTING
      | INPUT_METHOD.SHORTCUT
      | INPUT_METHOD.QUICK_INSERT;
    newHeadingLevel: HeadingLevelsAndNormalText;
    previousHeadingLevel?: HeadingLevelsAndNormalText;
  }
>;

declare type FormatIndentationAEP = FormatAEP<
  ACTION_SUBJECT_ID.FORMAT_INDENT,
  {
    inputMethod: INPUT_METHOD.TOOLBAR | INPUT_METHOD.KEYBOARD;
    direction: INDENT_DIRECTION.INDENT | INDENT_DIRECTION.OUTDENT;
    previousIndentationLevel: number;
    newIndentLevel: number;
    indentType:
      | INDENT_TYPE.PARAGRAPH
      | INDENT_TYPE.LIST
      | INDENT_TYPE.HEADING
      | INDENT_TYPE.CODE_BLOCK
      | INDENT_TYPE.TASK_LIST;
  }
>;

declare type FormatListAEP = FormatAEP<
  ACTION_SUBJECT_ID.FORMAT_LIST_NUMBER | ACTION_SUBJECT_ID.FORMAT_LIST_BULLET,
  {
    inputMethod:
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.KEYBOARD
      | INPUT_METHOD.FORMATTING
      | INPUT_METHOD.QUICK_INSERT;
  }
>;

declare type FormatSuperSubAEP = FormatAEP<
  ACTION_SUBJECT_ID.FORMAT_SUPER | ACTION_SUBJECT_ID.FORMAT_SUB,
  {
    inputMethod:
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.SHORTCUT
      | INPUT_METHOD.FORMATTING;
  }
>;

declare enum FULL_WIDTH_MODE {
  FIXED_WIDTH = 'fixedWidth',
  FULL_WIDTH = 'fullWidth',
}

declare type FullWidthModeAEP = TrackAEP<
  ACTION.CHANGED_FULL_WIDTH_MODE,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    previousMode: FULL_WIDTH_MODE;
    newMode: FULL_WIDTH_MODE;
  },
  undefined
>;

declare enum GAP_CURSOR_POSITION {
  LEFT = 'left',
  RIGHT = 'right',
}

declare class GapBookmark {
  private readonly pos;
  constructor(pos: number);
  map(mapping: any): GapBookmark;
  resolve(doc: Node_2): GapCursorSelection | Selection_2;
}

export declare class GapCursorSelection extends Selection_2 {
  readonly side: GapCursorSide;
  readonly visible: boolean;
  /**
   * Construct a GapCursorSelection
   * @param {ResolvedPos} $pos resolved position
   * @param {Side} side side where the gap cursor is drawn
   */
  constructor($pos: ResolvedPos, side?: GapCursorSide);
  static valid($pos: ResolvedPos): boolean;
  static findFrom(
    $pos: ResolvedPos,
    dir: number,
    mustMove?: boolean,
  ): GapCursorSelection | null;
  static fromJSON(
    doc: Node_2,
    json: {
      pos: number;
      type: string;
      side: GapCursorSide;
    },
  ): GapCursorSelection;
  map(doc: Node_2, mapping: Mapping): Selection_2;
  eq(other: Selection_2): boolean;
  content(): Slice<any>;
  getBookmark(): GapBookmark;
  toJSON(): {
    pos: number;
    type: string;
    side: GapCursorSide;
  };
}

export declare enum GapCursorSide {
  LEFT = 'left',
  RIGHT = 'right',
}

declare interface GapSelectionData {
  type: 'gapcursor';
  pos: number;
}

declare type GeneralEventPayload<T = void> =
  | AnnotateButtonAEP
  | AnnotationAEP
  | BrowserFreezePayload
  | ButtonFeedbackAEP
  | ButtonHelpAEP
  | ColorPickerAEP
  | DispatchedTransactionAEP
  | EditorPerfAEP
  | EditorRenderedAEP<T>
  | EditorStartAEP
  | EditorStopAEP
  | EditorTTIAEP
  | ExpandToggleAEP
  | FeedbackAEP
  | FullWidthModeAEP
  | HelpQuickInsertAEP
  | InputPerfSamlingAEP
  | InputPerfSamplingAvgAEP
  | PickerEmojiAEP
  | PickerImageAEP
  | ReactNodeViewRenderedAEP
  | RichMediaLayoutAEP
  | SelectionAEP
  | SlowInputAEP
  | TransactionMutatedAEP
  | UploadExternalFailedAEP
  | WithPluginStateCalledAEP
  | CodeBlockLanguageSelectedAEP
  | EditorContentRetrievalPerformedAEP
  | UfoSessionCompletePayloadAEP
  | MediaLinkTransformedAEP
  | TextLinkCodeMarkTransformedAEP
  | DedupeMarksTransformedAEP
  | IndentationMarksTransformedAEP
  | NodesMissingContentTransformedAEP
  | InvalidProsemirrorDocumentErrorAEP
  | DocumentProcessingErrorAEP;

export declare function getDefaultPresetOptionsFromEditorProps(
  props: EditorProps,
  createAnalyticsEvent?: CreateUIAnalyticsEvent,
): EditorPresetProps & DefaultPresetPluginOptions;

export declare const getListCommands: () => {
  indentList: typeof indentList;
  outdentList: typeof outdentList;
  toggleOrderedList: typeof toggleOrderedList;
  toggleBulletList: typeof toggleBulletList;
};

export declare function getNodesCount(node: Node_2): Record<string, number>;

declare type getPosHandler = getPosHandlerNode | boolean;

declare type getPosHandlerNode = () => number;

/**
 * Returns false if node contains only empty inline nodes and hardBreaks.
 */
export declare function hasVisibleContent(node: Node_2): boolean;

declare type HeadingLevels = 1 | 2 | 3 | 4 | 5 | 6;

declare type HeadingLevelsAndNormalText = HeadingLevels | NormalTextLevel;

declare type HelpQuickInsertAEP = UIAEP<
  ACTION.HELP_OPENED,
  ACTION_SUBJECT.HELP,
  ACTION_SUBJECT_ID.HELP_QUICK_INSERT,
  {
    inputMethod: INPUT_METHOD.QUICK_INSERT;
  },
  undefined
>;

declare type HighlightedSearchResultsAEP = UIAEP<
  ACTION.HIGHLIGHTED,
  ACTION_SUBJECT.SEARCH_RESULT,
  undefined,
  {
    source: string;
    searchSessionId: string;
    selectedResultId: string;
    selectedRelativePosition: number;
  },
  undefined
>;

/**
 * Plugin that keeps track of whether undo and redo are currently available
 * This is needed so we can enable/disable controls appropriately
 *
 * Actual undo/redo functionality is handled by prosemirror-history:
 * https://github.com/ProseMirror/prosemirror-history
 */
export declare const historyPluginKey: PluginKey<HistoryPluginState, any>;

export declare interface HistoryPluginState {
  canUndo: boolean;
  canRedo: boolean;
}

declare interface HorizontalAndVerticalCells {
  horizontalCells: number;
  verticalCells: number;
}

export declare enum HyperlinkInsertStatus {
  EDIT_LINK_TOOLBAR = 'EDIT',
  INSERT_LINK_TOOLBAR = 'INSERT',
  EDIT_INSERTED_TOOLBAR = 'EDIT_INSERTED',
}

export declare interface HyperlinkState {
  activeText?: string;
  activeLinkMark?: LinkToolbarState;
  timesViewed: number;
  canInsertLink: boolean;
  searchSessionId?: string;
  inputMethod?: INPUT_METHOD;
}

export declare const hyperlinkStateKey: PluginKey<HyperlinkState, any>;

declare type Icon = React_2.ComponentType<{
  label: string;
}>;

declare type IncrementDateSegmentAEP = TrackAEP<
  ACTION.INCREMENTED,
  ACTION_SUBJECT.DATE_SEGMENT,
  undefined,
  {
    dateSegment:
      | ACTION_SUBJECT_ID.DATE_DAY
      | ACTION_SUBJECT_ID.DATE_MONTH
      | ACTION_SUBJECT_ID.DATE_YEAR;
  },
  undefined
>;

declare enum INDENT_DIRECTION {
  INDENT = 'indent',
  OUTDENT = 'outdent',
}

declare enum INDENT_TYPE {
  PARAGRAPH = 'paragraph',
  LIST = 'list',
  HEADING = 'heading',
  CODE_BLOCK = 'codeBlock',
  TASK_LIST = 'taskList',
}

declare type IndentationMarksTransformedAEP = OperationalAEP<
  ACTION.INDENTATION_MARKS_TRANSFORMED,
  ACTION_SUBJECT.EDITOR,
  undefined,
  undefined,
  undefined
>;

declare function indentList(inputMethod?: InputMethod): Command;

export declare type InlineCommentAnnotationProvider = AnnotationTypeProvider<
  AnnotationTypes.INLINE_COMMENT,
  InlineCommentState
> & {
  createComponent?: React_2.ComponentType<InlineCommentCreateComponentProps>;
  viewComponent?: React_2.ComponentType<InlineCommentViewComponentProps>;
  isToolbarAbove?: boolean;
};

export declare type InlineCommentCreateComponentProps = AnnotationComponentProps & {
  /**
   * Creates an annotation mark in the document with the given id.
   */
  onCreate: (id: string) => void;
};

export declare type InlineCommentState = {
  resolved: boolean;
};

export declare type InlineCommentViewComponentProps = AnnotationComponentProps & {
  /**
   * Existing annotations where the cursor is placed.
   * These are provided in order, inner-most first.
   */
  annotations: Array<AnnotationInfo>;
  /**
   * Resolves an annotation with the given ID around the selection.
   */
  onResolve: (id: string) => void;
  /**
   * Removes the annotation from the document
   */
  onDelete?: (id: string) => void;
};

export declare enum INPUT_METHOD {
  ASCII = 'ascii',
  AUTO = 'auto',
  AUTO_DETECT = 'autoDetect',
  BUTTON = 'button',
  BLUR = 'blur',
  CARD = 'card',
  CLIPBOARD = 'clipboard',
  CONFIG_PANEL = 'configPanel',
  CONTEXT_MENU = 'contextMenu',
  DRAG_AND_DROP = 'dragAndDrop',
  EXTERNAL = 'external',
  EXTENSION_API = 'extensionApi',
  FLOATING_TB = 'floatingToolbar',
  FORMATTING = 'autoformatting',
  INSERT_MENU = 'insertMenu',
  KEYBOARD = 'keyboard',
  MACRO_BROWSER = 'macroBrowser',
  MANUAL = 'manual',
  PICKER = 'picker',
  PICKER_CLOUD = 'cloudPicker',
  PREFILL = 'prefill',
  QUICK_INSERT = 'quickInsert',
  SHORTCUT = 'shortcut',
  TOOLBAR = 'toolbar',
  TYPEAHEAD = 'typeAhead',
}

declare type InputMethod = INPUT_METHOD.KEYBOARD | INPUT_METHOD.TOOLBAR;

declare type InputMethod_2 = INPUT_METHOD.KEYBOARD | INPUT_METHOD.TOOLBAR;

declare type InputMethodInsertLink =
  | INPUT_METHOD.TYPEAHEAD
  | INPUT_METHOD.CLIPBOARD
  | INPUT_METHOD.FORMATTING
  | INPUT_METHOD.AUTO_DETECT
  | INPUT_METHOD.MANUAL;

declare type InputMethodInsertMedia =
  | INPUT_METHOD.CLIPBOARD
  | INPUT_METHOD.PICKER_CLOUD
  | INPUT_METHOD.DRAG_AND_DROP;

declare type InputPerfSamlingAEP = OperationalAEPWithObjectId<
  ACTION.INPUT_PERF_SAMPLING,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    time: number;
    nodeSize: number;
    participants: number;
    nodeCount?: Record<string, number>;
    severity?: SEVERITY;
  },
  undefined
>;

declare type InputPerfSamplingAvgAEP = OperationalAEPWithObjectId<
  ACTION.INPUT_PERF_SAMPLING_AVG,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    mean: number;
    median: number;
    sampleSize: number;
    participants: number;
    nodeCount?: Record<string, number>;
    nodeSize: number;
    severity?: SEVERITY;
  },
  undefined
>;

declare interface InputTracking {
  /**
   * @description Control whether samples of typing performance are taken. When this is false no measurements are taken and no events are sent.
   * @default false
   */
  enabled: boolean;
  /**
   * @description Control whether samples of typing performance are taken. Depends on enabled being true.
   * @default false
   */
  countNodes?: boolean;
  /**
   * @description Control for which nth transaction a typing performance sample is taken. Depends on enabled being true.
   * @default 100
   */
  samplingRate?: number;
  /**
   * @description input events that exceed [slowThreshold]ms generate analytics event. Depends on enabled being true.
   * @default 300
   */
  slowThreshold?: number;
  /**
   * @description input events that exceed [freezeThreshold]ms generate analytics event. Depends on enabled being true.
   * @default 600
   */
  freezeThreshold?: number;
  /**
   * @description Control whether input tracking severity is tracked. When this is false the severity is not recorded.
   * @default false
   */
  trackSeverity?: boolean;
  /**
   * @description Control for calculating severity level (NORMAL/DEGRADED/BLOCKING). Depends on severityTracking being true.
   * @default 100
   */
  severityNormalThreshold?: number;
  /**
   * @description Control for calculating severity level (NORMAL/DEGRADED/BLOCKING). Depends on severityTracking being true.
   * @default 500
   */
  severityDegradedThreshold?: number;
}

declare type InsertActionDecisionAEP = InsertAEP<
  ACTION_SUBJECT_ID.DECISION | ACTION_SUBJECT_ID.ACTION,
  {
    inputMethod:
      | INPUT_METHOD.QUICK_INSERT
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU
      | INPUT_METHOD.FORMATTING
      | INPUT_METHOD.KEYBOARD;
    containerAri?: string;
    objectAri?: string;
    localId: string;
    listLocalId: string;
    userContext?: USER_CONTEXT.EDIT | USER_CONTEXT.NEW;
    position: number;
    listSize: number;
  },
  undefined
>;

declare type InsertAEP<
  ActionSubjectID,
  Attributes,
  NonPrivacySafeAttributes
> = TrackAEP<
  ACTION.INSERTED,
  ACTION_SUBJECT.DOCUMENT,
  ActionSubjectID,
  Attributes,
  NonPrivacySafeAttributes,
  NonRequiredAttributes
>;

export declare type InsertBlockInputMethodToolbar =
  | INPUT_METHOD.TOOLBAR
  | INPUT_METHOD.INSERT_MENU;

export declare function insertBlockType(name: string): Command;

export declare const insertBlockTypesWithAnalytics: (
  name: string,
  inputMethod: BlockTypeInputMethod,
) => Command;

declare type InsertCodeBlockAEP = InsertAEP<
  ACTION_SUBJECT_ID.CODE_BLOCK,
  {
    inputMethod:
      | INPUT_METHOD.QUICK_INSERT
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU
      | INPUT_METHOD.FORMATTING
      | INPUT_METHOD.INSERT_MENU;
  },
  undefined
>;

export declare const insertDate: (
  date?: DateType | undefined,
  inputMethod?: InsertBlockInputMethodToolbar | undefined,
  commitMethod?: INPUT_METHOD.KEYBOARD | INPUT_METHOD.PICKER | undefined,
  enterPressed?: boolean,
) => Command;

declare type InsertDateAEP = InsertAEP<
  ACTION_SUBJECT_ID.DATE,
  {
    inputMethod:
      | INPUT_METHOD.QUICK_INSERT
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU;
  },
  undefined
>;

declare type InsertDividerAEP = InsertAEP<
  ACTION_SUBJECT_ID.DIVIDER,
  {
    inputMethod:
      | INPUT_METHOD.QUICK_INSERT
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU
      | INPUT_METHOD.FORMATTING
      | INPUT_METHOD.SHORTCUT;
  },
  undefined
>;

declare type InsertEmojiAEP = InsertAEP<
  ACTION_SUBJECT_ID.EMOJI,
  {
    inputMethod:
      | INPUT_METHOD.TYPEAHEAD
      | INPUT_METHOD.PICKER
      | INPUT_METHOD.ASCII;
  },
  undefined
>;

declare type InsertEventPayload =
  | InsertDividerAEP
  | InsertLineBreakAEP
  | InsertPanelAEP
  | InsertCodeBlockAEP
  | InsertTableAEP
  | InsertExpandAEP
  | InsertActionDecisionAEP
  | InsertEmojiAEP
  | InsertStatusAEP
  | InsertMediaSingleAEP
  | InsertMediaGroupAEP
  | InsertMediaInlineAEP
  | InsertLinkAEP
  | InsertLinkPreviewAEP
  | InsertMediaLinkAEP
  | InsertSmartLinkAEP
  | InsertLayoutAEP
  | InsertExtensionAEP
  | InsertNodeViaExtensionAPIAEP
  | InsertDateAEP
  | InsertPlaceholderTextAEP;

export declare const insertExpand: Command;

declare type InsertExpandAEP = InsertAEP<
  ACTION_SUBJECT_ID.EXPAND | ACTION_SUBJECT_ID.NESTED_EXPAND,
  {
    inputMethod: INPUT_METHOD.QUICK_INSERT | INPUT_METHOD.INSERT_MENU;
  },
  undefined
>;

declare type InsertExtensionAEP = InsertAEP<
  ACTION_SUBJECT_ID.EXTENSION,
  {
    extensionType: string;
    key: string;
    inputMethod: INPUT_METHOD.QUICK_INSERT;
  },
  any
>;

export declare const insertHorizontalRule: (
  inputMethod:
    | INPUT_METHOD.QUICK_INSERT
    | INPUT_METHOD.TOOLBAR
    | INPUT_METHOD.INSERT_MENU
    | INPUT_METHOD.FORMATTING
    | INPUT_METHOD.SHORTCUT,
) => Command;

declare type InsertItemProps = {
  contentItem: TypeAheadItem;
  query: string;
  sourceListItem: TypeAheadItem[];
};

declare type InsertLayoutAEP = InsertAEP<
  ACTION_SUBJECT_ID.LAYOUT,
  {
    inputMethod:
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU
      | INPUT_METHOD.QUICK_INSERT;
  },
  undefined
>;

declare type InsertLineBreakAEP = TrackAEP<
  ACTION.INSERTED,
  ACTION_SUBJECT.TEXT,
  ACTION_SUBJECT_ID.LINE_BREAK,
  undefined,
  undefined
>;

export declare function insertLink(
  from: number,
  to: number,
  incomingHref: string,
  incomingTitle?: string,
  displayText?: string,
  source?: LinkInputMethod,
): Command;

declare type InsertLinkAEP = InsertAEP<
  ACTION_SUBJECT_ID.LINK,
  {
    inputMethod: InputMethodInsertLink;
    fromCurrentDomain: boolean;
  },
  {
    linkDomain: string;
  }
>;

declare type InsertLinkPreviewAEP = InsertAEP<
  ACTION_SUBJECT_ID.LINK_PREVIEW,
  {
    status: LINK_STATUS.RESOLVED | LINK_STATUS.UNRESOLVED;
    representation?:
      | LINK_REPRESENTATION.TEXT
      | LINK_REPRESENTATION.INLINE_CARD
      | LINK_REPRESENTATION.INLINE_CARD
      | LINK_REPRESENTATION.BLOCK_CARD;
    resourceType?:
      | LINK_RESOURCE.JIRA
      | LINK_RESOURCE.CONFLUENCE
      | LINK_RESOURCE.BITBUCKET_PR
      | LINK_RESOURCE.BITBUCKET_REPO
      | LINK_RESOURCE.TRELLO_CARD
      | LINK_RESOURCE.TRELLO_BOARD
      | LINK_RESOURCE.STATUS_PAGE
      | LINK_RESOURCE.BOX
      | LINK_RESOURCE.DROPBOX
      | LINK_RESOURCE.OFFICE
      | LINK_RESOURCE.DRIVE
      | LINK_RESOURCE.YOUTUBE
      | LINK_RESOURCE.TWITTER
      | LINK_RESOURCE.OTHER;
  },
  undefined
>;

export declare const insertLinkWithAnalytics: (
  inputMethod: LinkInputMethod,
  from: number,
  to: number,
  href: string,
  title?: string | undefined,
  displayText?: string | undefined,
  cardsAvailable?: boolean,
) => Command;

export declare const insertLinkWithAnalyticsMobileNative: (
  inputMethod: LinkInputMethod,
  from: number,
  to: number,
  href: string,
  title?: string | undefined,
  displayText?: string | undefined,
) => Command;

declare type InsertMediaGroupAEP = InsertAEP<
  ACTION_SUBJECT_ID.MEDIA,
  {
    inputMethod?: InputMethodInsertMedia;
    fileExtension?: string;
    type: ACTION_SUBJECT_ID.MEDIA_SINGLE | ACTION_SUBJECT_ID.MEDIA_GROUP;
  },
  undefined
>;

declare type InsertMediaInlineAEP = InsertAEP<
  ACTION_SUBJECT_ID.MEDIA,
  {
    inputMethod?: InputMethodInsertMedia;
    fileExtension?: string;
    type: ACTION_SUBJECT_ID.MEDIA_INLINE;
  },
  undefined
>;

declare type InsertMediaLinkAEP = InsertAEP<
  ACTION_SUBJECT_ID.MEDIA_LINK,
  {
    inputMethod: INPUT_METHOD.TYPEAHEAD | INPUT_METHOD.MANUAL;
  },
  undefined
>;

declare type InsertMediaSingleAEP = InsertAEP<
  ACTION_SUBJECT_ID.MEDIA,
  {
    inputMethod: InputMethodInsertMedia;
    fileExtension?: string;
    type: ACTION_SUBJECT_ID.MEDIA_SINGLE | ACTION_SUBJECT_ID.MEDIA_GROUP;
  },
  undefined
>;

export declare const insertMediaSingleNode: (
  view: EditorView,
  mediaState: MediaState,
  inputMethod?: InputMethodInsertMedia | undefined,
  collection?: string | undefined,
  alignLeftOnInsert?: boolean | undefined,
) => boolean;

declare type InsertNodeViaExtensionAPIAEP = InsertAEP<
  undefined,
  {
    nodeType: string;
    inputMethod: INPUT_METHOD.EXTENSION_API;
    hasReferentiality: Boolean;
    nodeTypesReferenced?: string[];
    layout?: ExtensionLayout;
    extensionType?: string;
    /**
     * extensionkey follows this format:
     * ${manifest.key}:${manifest.modules.nodes.name}
     * e.g: 'awesome:item', 'awesome:default', 'awesome:list'
     */
    extensionKey?: string;
  },
  undefined
>;

declare type InsertPanelAEP = InsertAEP<
  ACTION_SUBJECT_ID.PANEL,
  {
    inputMethod:
      | INPUT_METHOD.QUICK_INSERT
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU;
    panelType: PanelType;
  },
  undefined
>;

declare type InsertPlaceholderTextAEP = InsertAEP<
  ACTION_SUBJECT_ID.PLACEHOLDER_TEXT,
  {
    inputMethod:
      | INPUT_METHOD.QUICK_INSERT
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU;
  },
  undefined
>;

declare type InsertSmartLinkAEP = InsertAEP<
  ACTION_SUBJECT_ID.SMART_LINK,
  {
    inputMethod:
      | INPUT_METHOD.CLIPBOARD
      | INPUT_METHOD.AUTO_DETECT
      | INPUT_METHOD.TYPEAHEAD
      | INPUT_METHOD.MANUAL
      | INPUT_METHOD.FORMATTING;
    nodeType: 'inlineCard' | 'blockCard' | 'embedCard';
    nodeContext: SmartLinkNodeContext;
    domainName: string;
    fromCurrentDomain: boolean;
  },
  undefined
>;

declare type InsertState = {
  type: HyperlinkInsertStatus.INSERT_LINK_TOOLBAR;
  from: number;
  to: number;
};

declare type InsertStatusAEP = InsertAEP<
  ACTION_SUBJECT_ID.STATUS,
  {
    inputMethod:
      | INPUT_METHOD.QUICK_INSERT
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU;
  },
  undefined
>;

declare type InsertTableAEP = InsertAEP<
  ACTION_SUBJECT_ID.TABLE,
  {
    inputMethod:
      | INPUT_METHOD.QUICK_INSERT
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU
      | INPUT_METHOD.FORMATTING
      | INPUT_METHOD.SHORTCUT;
  },
  undefined
>;

export declare const insertTaskDecision: (
  view: EditorView,
  listType: TaskDecisionListType,
  inputMethod?:
    | INPUT_METHOD.FORMATTING
    | INPUT_METHOD.QUICK_INSERT
    | InsertBlockInputMethodToolbar,
  listLocalId?: string | undefined,
  itemLocalId?: string | undefined,
) => Command;

export declare const insertTaskDecisionCommand: (
  listType: TaskDecisionListType,
  inputMethod?:
    | INPUT_METHOD.FORMATTING
    | INPUT_METHOD.QUICK_INSERT
    | InsertBlockInputMethodToolbar,
  addItem?: AddItemTransactionCreator | undefined,
  listLocalId?: string | undefined,
  itemLocalId?: string | undefined,
) => Command;

declare type InvalidDocumentEncounteredAEP = OperationalAEP<
  ACTION.INVALID_DOCUMENT_ENCOUNTERED,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    nodeType: string;
    reason: string;
    tableLocalId: string;
    spanValue: number;
  },
  undefined
>;

declare type InvalidProsemirrorDocumentErrorAEP = OperationalAEP<
  ACTION.INVALID_PROSEMIRROR_DOCUMENT,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    errorStack?: string;
  },
  undefined
>;

declare type InvalidTransactionErrorAEP = OperationalAEP<
  ACTION.DISPATCHED_INVALID_TRANSACTION,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    analyticsEventPayloads: AnalyticsEventPayloadWithChannel[];
    invalidNodes: (SimplifiedNode | string)[];
  },
  undefined
>;

declare type InvalidTransactionStepErrorAEP = OperationalAEP<
  ACTION.DISCARDED_INVALID_STEPS_FROM_TRANSACTION,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    analyticsEventPayloads: AnalyticsEventPayloadWithChannel[];
  },
  undefined
>;

declare type InviteToEditButtonProps = {
  onClick: (event: React.MouseEvent<HTMLElement>) => void;
  selected: boolean;
};

declare type InviteToEditComponentProps = {
  children: ReactElement<InviteToEditButtonProps>;
};

/**
 * Checks if a node looks like an empty document
 */
export declare function isEmptyDocument(node: Node_2): boolean;

export declare function isLinkAtPos(pos: number): Predicate;

export declare function isTextAtPos(pos: number): Predicate;

declare enum LAYOUT_TYPE {
  SINGLE_COL = 'singleColumn',
  TWO_COLS_EQUAL = 'twoColumnsEqual',
  THREE_COLS_EQUAL = 'threeColumnsEqual',
  LEFT_SIDEBAR = 'twoColumnsLeftSidebar',
  RIGHT_SIDEBAR = 'twoColumnsRightSidebar',
  THREE_WITH_SIDEBARS = 'threeColumnsWithSidebars ',
}

declare interface LayoutPluginOptions extends LongPressSelectionPluginOptions {
  allowBreakout?: boolean;
  UNSAFE_addSidebarLayouts?: boolean;
  UNSAFE_allowSingleColumnLayout?: boolean;
}

export declare const lightModeStatusColorPalette: PaletteColor[];

declare enum LINK_REPRESENTATION {
  TEXT = 'text',
  INLINE_CARD = 'inlineCard',
  BLOCK_CARD = 'blockCard',
  EMBED = 'embed',
}

declare enum LINK_RESOURCE {
  JIRA = 'jiraIssue',
  CONFLUENCE = 'confluencePage',
  BITBUCKET_PR = 'bitbucketPR',
  BITBUCKET_REPO = 'bitbucketRepo',
  TRELLO_CARD = 'trelloCard',
  TRELLO_BOARD = 'trelloBoard',
  STATUS_PAGE = 'statusPage',
  BOX = 'boxFile',
  DROPBOX = 'dropboxFile',
  OFFICE = 'office',
  DRIVE = 'drive',
  YOUTUBE = 'youtubeVideo',
  TWITTER = 'twitterTweet',
  OTHER = 'other',
}

declare enum LINK_STATUS {
  RESOLVED = 'resolved',
  UNRESOLVED = 'unresolved',
}

export declare type LinkInputMethod =
  | INPUT_METHOD.MANUAL
  | INPUT_METHOD.TYPEAHEAD;

declare type LinkToolbarState =
  | EditState
  | EditInsertedState
  | InsertState
  | undefined;

declare enum LIST_TEXT_SCENARIOS {
  JOIN_SIBLINGS = 'joinSiblings',
  JOIN_DESCENDANT_TO_PARENT = 'joinDescendantToParent',
  JOIN_TO_SIBLING_DESCENDANT = 'joinToSiblingDescendant',
  JOIN_PARAGRAPH_WITH_LIST = 'joinParagraphWithList',
  JOIN_PARENT_SIBLING_TO_PARENT_CHILD = 'joinParentSiblingToParentChild',
  JOIN_LIST_ITEM_WITH_PARAGRAPH = 'joinListItemWithParagraph',
}

declare type ListContentSanitizedAEP = TrackAEP<
  ACTION.NODE_CONTENT_SANITIZED,
  ACTION_SUBJECT.LIST,
  ACTION_SUBJECT_ID.FORMAT_LIST_BULLET | ACTION_SUBJECT_ID.FORMAT_LIST_NUMBER,
  {
    inputMethod: INPUT_METHOD.FORMATTING;
    nodeSanitized: string;
    marksRemoved: string[];
  },
  undefined
>;

declare type ListConvertedTrackAEP = TrackAEP<
  ACTION.CONVERTED,
  ACTION_SUBJECT.LIST,
  | ACTION_SUBJECT_ID.FORMAT_LIST_BULLET
  | ACTION_SUBJECT_ID.FORMAT_LIST_NUMBER
  | ACTION_SUBJECT_ID.TEXT,
  {
    transformedFrom:
      | ACTION_SUBJECT_ID.FORMAT_LIST_BULLET
      | ACTION_SUBJECT_ID.FORMAT_LIST_NUMBER;
    inputMethod: INPUT_METHOD.TOOLBAR | INPUT_METHOD.KEYBOARD;
  } & CommonListAnalyticsAttributes,
  undefined
>;

declare type Listener = (data: any) => void;

declare type Listener_2<T = any> = (data: T) => void;

declare type ListEventPayload =
  | ListItemJoinedForwardAEP
  | ListItemJoinedBackwardsAEP
  | ListConvertedTrackAEP
  | ListIndentedAEP
  | ListOutdentedAEP
  | ListInsertedAEP
  | ListContentSanitizedAEP;

declare type ListIndentedAEP = TrackAEP<
  ACTION.INDENTED,
  ACTION_SUBJECT.LIST,
  ACTION_SUBJECT_ID.FORMAT_LIST_BULLET | ACTION_SUBJECT_ID.FORMAT_LIST_NUMBER,
  {
    inputMethod: INPUT_METHOD;
  } & CommonListAnalyticsAttributes,
  undefined
>;

export declare type ListInputMethod =
  | INPUT_METHOD.KEYBOARD
  | INPUT_METHOD.TOOLBAR;

declare type ListInsertedAEP = TrackAEP<
  ACTION.INSERTED,
  ACTION_SUBJECT.LIST,
  ACTION_SUBJECT_ID.FORMAT_LIST_BULLET | ACTION_SUBJECT_ID.FORMAT_LIST_NUMBER,
  {
    inputMethod:
      | INPUT_METHOD.FORMATTING
      | INPUT_METHOD.KEYBOARD
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.QUICK_INSERT;
  },
  undefined
>;

declare type ListItemJoinedBackwardsAEP = ListItemJoinedFormatAEP<{
  inputMethod: INPUT_METHOD.KEYBOARD;
  direction: DELETE_DIRECTION.BACKWARD;
  scenario:
    | LIST_TEXT_SCENARIOS.JOIN_SIBLINGS
    | LIST_TEXT_SCENARIOS.JOIN_DESCENDANT_TO_PARENT
    | LIST_TEXT_SCENARIOS.JOIN_TO_SIBLING_DESCENDANT;
}>;

declare type ListItemJoinedFormatAEP<Attributes> = TrackAEP<
  ACTION.LIST_ITEM_JOINED,
  ACTION_SUBJECT.LIST,
  ACTION_SUBJECT_ID.FORMAT_LIST_BULLET | ACTION_SUBJECT_ID.FORMAT_LIST_NUMBER,
  Attributes,
  undefined
>;

declare type ListItemJoinedForwardAEP = ListItemJoinedFormatAEP<{
  inputMethod: INPUT_METHOD.KEYBOARD;
  direction: DELETE_DIRECTION.FORWARD;
  scenario:
    | LIST_TEXT_SCENARIOS.JOIN_PARAGRAPH_WITH_LIST
    | LIST_TEXT_SCENARIOS.JOIN_SIBLINGS
    | LIST_TEXT_SCENARIOS.JOIN_DESCENDANT_TO_PARENT
    | LIST_TEXT_SCENARIOS.JOIN_PARENT_SIBLING_TO_PARENT_CHILD
    | LIST_TEXT_SCENARIOS.JOIN_LIST_ITEM_WITH_PARAGRAPH;
}>;

declare type ListOutdentedAEP = TrackAEP<
  ACTION.OUTDENTED,
  ACTION_SUBJECT.LIST,
  ACTION_SUBJECT_ID.FORMAT_LIST_BULLET | ACTION_SUBJECT_ID.FORMAT_LIST_NUMBER,
  {
    inputMethod: INPUT_METHOD;
  } & CommonListAnalyticsAttributes,
  undefined
>;

export declare interface ListState {
  bulletListActive: boolean;
  bulletListDisabled: boolean;
  orderedListActive: boolean;
  orderedListDisabled: boolean;
  decorationSet: DecorationSet;
}

export declare const listStateKey: PluginKey<ListState, any>;

declare interface LongPressSelectionPluginOptions {
  useLongPressSelection?: boolean;
}

export { MacroAttributes };

export { MacroProvider };

declare interface MarkConfig {
  name: string;
  mark: MarkSpec;
}

declare interface MeasureHelpers {
  startMeasure: (measureName: string) => void;
  stopMeasure: (
    measureName: string,
    onMeasureComplete?: (duration: number, startTime: number) => void,
  ) => void;
}

declare type MeasureListener = (entry: SimpleEntry) => void;

export declare const measurements: {
  EDITOR_MOUNTED: string;
  PROSEMIRROR_RENDERED: string;
  PROSEMIRROR_CONTENT_RENDERED: string;
  ON_EDITOR_READY_CALLBACK: string;
  PASTE: string;
};

declare type MediaAltTextAction = TrackAEP<
  ACTION.ADDED | ACTION.CLOSED | ACTION.EDITED | ACTION.CLEARED | ACTION.OPENED,
  ACTION_SUBJECT.MEDIA,
  ACTION_SUBJECT_ID.ALT_TEXT,
  undefined,
  undefined
>;

declare type MediaCaptionActionType =
  | ACTION.DELETED
  | ACTION.EDITED
  | ACTION.ADDED;

declare type MediaEventPayload =
  | MediaLinkAEP
  | MediaAltTextAction
  | MediaUIAction
  | CaptionTrackAction
  | ChangeMediaAEP;

declare type MediaLinkActionType =
  | ACTION.ADDED
  | ACTION.EDITED
  | ACTION.DELETED
  | ACTION.VISITED
  | ACTION.ERRORED;

declare type MediaLinkAEP = TrackAEP<
  MediaLinkActionType,
  ACTION_SUBJECT.MEDIA,
  ACTION_SUBJECT_ID.LINK,
  any,
  undefined
>;

declare type MediaLinkTransformedAEP = OperationalAEP<
  ACTION.MEDIA_LINK_TRANSFORMED,
  ACTION_SUBJECT.EDITOR,
  undefined,
  undefined,
  undefined
>;

declare interface MediaNodeWithPosHandler {
  node: Node_2;
  getPos: ProsemirrorGetPosHandler;
}

export declare interface MediaOptions {
  provider?: Providers['mediaProvider'];
  allowMediaSingle?: boolean | MediaSingleOptions;
  allowMediaGroup?: boolean;
  customDropzoneContainer?: HTMLElement;
  customMediaPicker?: CustomMediaPicker;
  allowResizing?: boolean;
  allowResizingInTables?: boolean;
  allowLinking?: boolean;
  allowLazyLoading?: boolean;
  allowBreakoutSnapPoints?: boolean;
  allowAdvancedToolBarOptions?: boolean;
  allowMediaSingleEditable?: boolean;
  allowRemoteDimensionsFetch?: boolean;
  allowDropzoneDropLine?: boolean;
  allowMarkingUploadsAsIncomplete?: boolean;
  fullWidthEnabled?: boolean;
  uploadErrorHandler?: (state: MediaState) => void;
  waitForMediaUpload?: boolean;
  isCopyPasteEnabled?: boolean;
  allowAltTextOnImages?: boolean;
  enableDownloadButton?: boolean;
  altTextValidator?: (value: string) => string[];
  useForgePlugins?: boolean;
  allowTemplatePlaceholders?: boolean | PlaceholderTextOptions;
  alignLeftOnInsert?: boolean;
  featureFlags?: MediaFeatureFlags;
}

export declare const mediaPlugin: (
  options?: MediaOptions | undefined,
) => EditorPlugin;

export declare const mediaPluginKey: PluginKey<MediaPluginState, any>;

declare type MediaPluginOptions = {
  providerFactory: ProviderFactory;
  nodeViews: {
    [name: string]: (
      node: Node_2,
      view: EditorView,
      getPos: getPosHandler,
    ) => NodeView;
  };
  errorReporter?: ErrorReporter;
  uploadErrorHandler?: (state: MediaState) => void;
  waitForMediaUpload?: boolean;
  customDropzoneContainer?: HTMLElement;
  customMediaPicker?: CustomMediaPicker;
  allowResizing: boolean;
};

declare interface MediaPluginState {
  allowsUploads: boolean;
  mediaClientConfig?: MediaClientConfig;
  uploadMediaClientConfig?: MediaClientConfig;
  ignoreLinks: boolean;
  waitForMediaUpload: boolean;
  allUploadsFinished: boolean;
  showDropzone: boolean;
  isFullscreen: boolean;
  element?: HTMLElement;
  layout: RichMediaLayout;
  mediaNodes: MediaNodeWithPosHandler[];
  mediaGroupNodes: Record<string, any>;
  mobileUploadComplete: Record<string, boolean>;
  options: MediaPluginOptions;
  mediaProvider?: MediaProvider_2;
  pickers: PickerFacade[];
  pickerPromises: Array<Promise<PickerFacade>>;
  editingMediaSinglePos?: number;
  showEditingDialog?: boolean;
  mediaOptions?: MediaOptions;
  dispatch?: Dispatch;
  onContextIdentifierProvider: (
    _name: string,
    provider?: Promise<ContextIdentifierProvider>,
  ) => Promise<void>;
  setMediaProvider: (mediaProvider?: Promise<MediaProvider_2>) => Promise<void>;
  getMediaOptions: () => MediaPluginOptions;
  insertFile: (
    mediaState: MediaState,
    onMediaStateChanged: MediaStateEventSubscriber,
    pickerType?: string,
  ) => void;
  addPendingTask: (promise: Promise<any>) => void;
  splitMediaGroup: () => boolean;
  onPopupPickerClose: () => void;
  showMediaPicker: () => void;
  setBrowseFn: (browseFn: () => void) => void;
  onPopupToggle: (onPopupToogleCallback: (isOpen: boolean) => void) => void;
  waitForPendingTasks: (
    timeout?: number,
    lastTask?: Promise<MediaState | null>,
  ) => Promise<MediaState | null>;
  handleMediaNodeRemoval: (
    node: Node_2 | undefined,
    getPos: ProsemirrorGetPosHandler,
  ) => void;
  handleMediaNodeMount: (
    node: Node_2,
    getPos: ProsemirrorGetPosHandler,
  ) => void;
  handleMediaNodeUnmount: (oldNode: Node_2) => void;
  findMediaNode: (id: string) => MediaNodeWithPosHandler | null;
  updateMediaNodeAttrs: (
    id: string,
    attrs: object,
    isMediaSingle: boolean,
  ) => undefined | boolean;
  isMobileUploadCompleted: (mediaId: string) => boolean | undefined;
  removeNodeById: (state: MediaState) => void;
  removeSelectedMediaContainer: () => boolean;
  selectedMediaContainerNode: () => Node_2 | undefined;
  handleDrag: (dragState: 'enter' | 'leave') => void;
  updateElement(): void;
  setView(view: EditorView): void;
  destroy(): void;
  updateAndDispatch(
    props: Partial<
      Pick<this, 'allowsUploads' | 'allUploadsFinished' | 'isFullscreen'>
    >,
  ): void;
}

export { MediaProvider_2 as MediaProvider };

declare interface MediaSingleOptions {
  disableLayout?: boolean;
}

export declare interface MediaState {
  id: string;
  status?: MediaStateStatus;
  fileName?: string;
  fileSize?: number;
  fileMimeType?: string;
  collection?: string;
  dimensions?: {
    width: number | undefined;
    height: number | undefined;
  };
  scaleFactor?: number;
  error?: {
    name: string;
    description: string;
  };
  /** still require to support Mobile */
  publicId?: string;
  contextId?: string;
}

declare type MediaStateEvent = MediaState;

declare type MediaStateEventListener = (evt: MediaStateEvent) => void;

declare type MediaStateEventSubscriber = (
  listener: MediaStateEventListener,
) => void;

declare type MediaStateStatus =
  | 'unknown'
  | 'ready'
  | 'cancelled'
  | 'preview'
  | 'error'
  | 'mobile-upload-end';

declare type MediaSwitchType =
  | ACTION_SUBJECT_ID.MEDIA_INLINE
  | ACTION_SUBJECT_ID.MEDIA_GROUP;

declare type MediaUIAction = UIAEP<
  ACTION.EDITED,
  ACTION_SUBJECT.MEDIA_SINGLE | ACTION_SUBJECT.EMBEDS,
  ACTION_SUBJECT_ID.RESIZED,
  any,
  undefined
>;

declare interface MentionPluginConfig {
  HighlightComponent?: React.ComponentType;
  insertDisplayName?: boolean;
}

export declare const mentionPluginKey: PluginKey<MentionPluginState, any>;

export declare type MentionPluginState = {
  mentionProvider?: MentionProvider_2 | TeamMentionProvider;
  contextIdentifierProvider?: ContextIdentifierProvider;
  mentions?: Array<MentionDescription>;
};

export { MentionProvider };

export { MentionResource };

declare interface MenuItem {
  key?: string;
  content: string | React_2.ReactChild | React_2.ReactFragment;
  value: {
    name: string;
  };
  shortcut?: string;
  elemBefore?: React_2.ReactElement<any>;
  elemAfter?: React_2.ReactElement<any>;
  tooltipDescription?: string;
  tooltipPosition?: string;
  isActive?: boolean;
  isDisabled?: boolean;
  handleRef?: any;
  className?: string;
  'aria-label'?: React_2.AriaAttributes['aria-label'];
  'aria-haspopup'?: React_2.AriaAttributes['aria-haspopup'];
  onClick?: (editorActions: EditorActions) => void;
}

declare interface MessageDescriptor_2 {
  id: string;
  description: string;
  defaultMessage: string;
}

export declare const messages: {
  layoutFixedWidth: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  layoutWide: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  layoutFullWidth: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  alignImageRight: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  alignImageCenter: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  alignImageLeft: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  remove: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  removeEmoji: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  visit: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  inviteToEditButtonTitle: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  saveButton: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  cancelButton: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  taskList: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  bulletList: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  nestedExpand: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  decisionList: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  defaultBlockNode: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  panel: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  blockquote: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  timeUpdated: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  timeViewed: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  timeAgo: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  copyToClipboard: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  copiedToClipboard: {
    id: string;
    defaultMessage: string;
    description: string;
  };
};

declare type MobileUploadEndEventPayload = {
  readonly file: MediaFile & {
    readonly collectionName?: string;
    readonly publicId?: string;
  };
};

declare enum MODE {
  RENDERER = 'renderer',
  EDITOR = 'editor',
}

declare type MountedPortal = {
  children: () => React_2.ReactChild | null;
  hasAnalyticsContext: boolean;
  hasIntlContext: boolean;
};

declare const name_2: string;
export { name_2 as name };

declare type NamedPluginKeys = Readonly<{
  [stateName: string]: PluginKey;
}>;

declare type NamedPluginStates<P extends NamedPluginKeys> = Readonly<
  Partial<
    {
      [K in keyof P]: P[K] extends PluginKey<infer T> ? T : never;
    }
  >
>;

declare type NewCollabSyncUpErrorAEP = OperationalAEP<
  ACTION.NEW_COLLAB_SYNC_UP_ERROR_NO_STEPS,
  ACTION_SUBJECT.EDITOR,
  undefined,
  NewCollabSyncUpErrorAttributes,
  undefined
>;

declare type NewMediaEvent = (
  state: MediaState,
  onStateChanged: MediaStateEventSubscriber,
  pickerType?: string,
) => void;

declare interface NodeConfig {
  name: string;
  node: NodeSpec;
}

declare type NodeCount = Record<string, number>;

declare type NodeEventPayload =
  | ChangePanelAEP
  | DeletePanelAEP
  | DeletedSmartLink
  | VisitedSmartLink
  | VisitedHyperlink
  | ChangedLayoutAEP
  | DeletedLayoutAEP
  | DeletedExpandAEP
  | ChangeSmartLinkAEP
  | UnsupportedContentAEP;

declare interface NodeSelectionData {
  type: 'node';
  anchor: number;
}

declare type NodesMissingContentTransformedAEP = OperationalAEP<
  ACTION.NODES_MISSING_CONTENT_TRANSFORMED,
  ACTION_SUBJECT.EDITOR,
  undefined,
  undefined,
  undefined
>;

declare type NodeViewTracking = {
  /**
     * @description Control whether
     NodeView performance is tracked. When this is false no measurements are taken and no events are sent.
     * @default false
     */
  enabled: boolean;
  /**
   * @description The nth re-render of NodeView after which an analytics event is sent. Depends on enabled being true.
   * @default false
   */
  samplingRate?: 100;
  /**
   * @description NodeView render that exceeds the threshold generate analytics event. Depends on enabled being true.
   * @default 7
   */
  slowThreshold?: number;
};

declare interface NonRequiredAttributes {
  insertLocation?: string;
  nodeLocation?: string;
  selectionType?: SELECTION_TYPE;
  selectionPosition?: SELECTION_POSITION;
}

declare type NormalTextLevel = 0;

declare type OnChangeCallbackTracking = {
  /**
   * @description Whether onChange callback tracking should be enabled. Requires TransactionTracking
   * to be enabled.
   * @default: false
   */
  enabled: boolean;
};

declare type OnEditorReadyCallbackTracking = {
  /**
   * @description Control whether onEditorReady callback tracking should be enabled.
   * @default false
   */
  enabled: boolean;
};

declare type OnEditorViewStateUpdated = (props: {
  readonly originalTransaction: Readonly<Transaction>;
  readonly transactions: Transaction[];
  readonly oldEditorState: Readonly<EditorState>;
  readonly newEditorState: Readonly<EditorState>;
}) => void;

declare type OpenAEP = UIAEP<
  ACTION.OPENED,
  ACTION_SUBJECT.CONFIG_PANEL,
  undefined,
  {},
  undefined
>;

declare type OpenAEP_2 = UIAEP<
  ACTION.OPENED,
  ACTION_SUBJECT.ELEMENT_BROWSER,
  undefined,
  {
    mode: 'full' | 'inline';
  },
  undefined
>;

export declare const openDatePicker: () => Command;

declare type OperationalAEP<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes,
  NonPrivacySafeAttributes
> = AEP<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes,
  NonPrivacySafeAttributes,
  EVENT_TYPE.OPERATIONAL
>;

declare type OperationalAEPWithObjectId<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes,
  NonPrivacySafeAttributes
> = OperationalAEP<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes & {
    objectId?: string;
  },
  NonPrivacySafeAttributes
>;

declare type OperationalExposureAEP<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes
> = OperationalAEP<Action, ActionSubject, ActionSubjectID, Attributes, {}> & {
  source?: string;
  tags?: string[];
};

declare function outdentList(inputMethod?: InputMethod_2): Command;

export declare interface PaletteColor {
  value: string;
  label: string;
  border: string;
  message?: MessageDescriptor;
}

declare interface PanelPluginConfig {
  allowCustomPanel?: boolean;
  allowCustomPanelEdit?: boolean;
}

declare type PASTE_ACTION_SUBJECT_ID =
  | ACTION_SUBJECT_ID.PASTE_BLOCKQUOTE
  | ACTION_SUBJECT_ID.PASTE_BLOCK_CARD
  | ACTION_SUBJECT_ID.PASTE_BODIED_EXTENSION
  | ACTION_SUBJECT_ID.PASTE_BULLET_LIST
  | ACTION_SUBJECT_ID.PASTE_CODE_BLOCK
  | ACTION_SUBJECT_ID.PASTE_DECISION_LIST
  | ACTION_SUBJECT_ID.PASTE_EXTENSION
  | ACTION_SUBJECT_ID.PASTE_HEADING
  | ACTION_SUBJECT_ID.PASTE_MEDIA_GROUP
  | ACTION_SUBJECT_ID.PASTE_MEDIA_SINGLE
  | ACTION_SUBJECT_ID.PASTE_ORDERED_LIST
  | ACTION_SUBJECT_ID.PASTE_PANEL
  | ACTION_SUBJECT_ID.PASTE_PARAGRAPH
  | ACTION_SUBJECT_ID.PASTE_RULE
  | ACTION_SUBJECT_ID.PASTE_TABLE
  | ACTION_SUBJECT_ID.PASTE_TABLE_CELL
  | ACTION_SUBJECT_ID.PASTE_TABLE_HEADER
  | ACTION_SUBJECT_ID.PASTE_TABLE_ROW
  | ACTION_SUBJECT_ID.PASTE_TASK_LIST
  | ACTION_SUBJECT_ID.PASTE_EXPAND
  | ACTION_SUBJECT_ID.PASTE_NESTED_EXPAND;

declare type PasteAEP = PasteBaseAEP<
  ACTION.PASTED,
  {
    inputMethod: INPUT_METHOD.KEYBOARD;
    type: PasteType;
    content: PasteContent;
    source?: PasteSource;
    pasteSize: number;
  },
  | {
      linkDomain?: string[];
    }
  | undefined
>;

declare type PasteAsPlainAEP = PasteBaseAEP<
  ACTION.PASTED_AS_PLAIN,
  {
    inputMethod: string;
    pasteSize: number;
    linksInPasteCount: number;
  },
  undefined
>;

declare type PasteBaseAEP<
  Action,
  Attributes,
  NonPrivacySafeAttributes
> = TrackAEP<
  Action,
  ACTION_SUBJECT.DOCUMENT,
  PASTE_ACTION_SUBJECT_ID,
  Attributes,
  NonPrivacySafeAttributes
>;

declare type PasteBaseOperationalAEP<
  Action,
  Attributes,
  NonPrivacySafeAttributes
> = OperationalAEP<
  Action,
  ACTION_SUBJECT.EDITOR,
  PASTE_ACTION_SUBJECT_ID,
  Attributes,
  NonPrivacySafeAttributes
>;

declare type PasteContent =
  | 'text'
  | 'url'
  | 'code'
  | 'mediaSingle'
  | 'mediaCard'
  | 'mediaGroup'
  | 'blockquote'
  | 'blockCard'
  | 'bodiedExtension'
  | 'bulletList'
  | 'codeBlock'
  | 'decisionList'
  | 'decisionItem'
  | 'extension'
  | 'heading'
  | 'layoutSection'
  | 'tableCells'
  | 'table'
  | 'expand'
  | 'nestedExpand'
  | 'orderedList'
  | 'panel'
  | 'rule'
  | 'tableHeader'
  | 'tableRow'
  | 'taskItem'
  | 'uncategorized'
  | 'mixed';

declare type PastedTimedAEP = PasteBaseOperationalAEP<
  ACTION.PASTED_TIMED,
  {
    pasteIntoNode: PASTE_ACTION_SUBJECT_ID;
    content: Array<string>;
    time: number;
  },
  undefined
>;

declare type PasteEventPayload = PasteAEP | PasteAsPlainAEP | PastedTimedAEP;

declare type PastePluginOptions = {
  plainTextPasteLinkification?: boolean;
  cardOptions?: CardOptions;
  sanitizePrivateContent?: boolean;
};

declare type PasteSource =
  | 'fabric-editor'
  | 'apple-pages'
  | 'google-spreadsheets'
  | 'google-docs'
  | 'microsoft-excel'
  | 'microsoft-word'
  | 'dropbox-paper'
  | 'uncategorized';

declare type PasteTracking = {
  /**
   * @description Control whether paste tracking should be enabled.
   * @default false
   */
  enabled: boolean;
};

declare type PasteType = 'richText' | 'plain' | 'markdown' | 'binary';

declare type PerformanceTracking = {
  /**
   * @description Control whether measurements for all analytics events are performed
   */
  catchAllTracking?: CatchAllTracking;
  /**
   * @description Control whether time to interactive is tracked
   */
  ttiTracking?: TTITracking;
  /**
   * @description Control whether transactions are tracked
   */
  inputTracking?: InputTracking;
  /**
   * @description Control whether transactions are tracked
   */
  transactionTracking?: TransactionTracking;
  /**
   * @description Control whether editor ui is tracked
   */
  uiTracking?: UITracking;
  /**
   * @description Control whether nodeviews are tracked
   */
  nodeViewTracking?: NodeViewTracking;
  /**
   * @description Control whether browser freezes / long tasks are tracked
   */
  bFreezeTracking?: BrowserFreezetracking;
  /**
   * @description Control whether proseMirror rendered event is tracked
   */
  proseMirrorRenderedTracking?: ProseMirrorRenderedTracking;
  /**
   * @description Control whether editor content retrieval events are tracked
   */
  contentRetrievalTracking?: ContentRetrievalTracking;
  /**
   * @description Control onChange callback is tracked. Requires TransactionTracking to be enabled,
   * and uses the sampling rate in TransactionTracking.
   */
  onChangeCallbackTracking?: OnChangeCallbackTracking;
  /**
   * @description Control whether onEditorReady callback is tracked.
   */
  onEditorReadyCallbackTracking?: OnEditorReadyCallbackTracking;
  /**
   * @description Control whether paste is tracked.
   */
  pasteTracking?: PasteTracking;
  /**
   * @description Control whether render of different component is tracked.
   */
  renderTracking?: RenderTracking;
};

declare type PermittedLayoutsDescriptor = TableLayout[] | 'all';

declare type PickerAEP<ActionSubjectID, Attributes> = UIAEP<
  ACTION.OPENED,
  ACTION_SUBJECT.PICKER,
  ActionSubjectID,
  Attributes,
  undefined
>;

declare type PickerEmojiAEP = PickerAEP<
  ACTION_SUBJECT_ID.PICKER_EMOJI,
  {
    inputMethod:
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU
      | INPUT_METHOD.KEYBOARD;
  }
>;

declare class PickerFacade {
  readonly config: PickerFacadeConfig;
  readonly pickerConfig?: CustomMediaPicker | null | undefined;
  private picker?;
  private onDragListeners;
  private pickerType;
  private onStartListeners;
  private eventListeners;
  private analyticsName;
  erroredFiles: Set<string>;
  constructor(
    pickerType: PickerType,
    config: PickerFacadeConfig,
    pickerConfig?: CustomMediaPicker | null | undefined,
    analyticsName?: string,
  );
  init(): Promise<PickerFacade>;
  get type(): PickerType;
  get mediaPicker(): CustomMediaPicker | undefined;
  destroy(): void;
  setUploadParams(params: UploadParams): void;
  onNewMedia(cb: NewMediaEvent): void;
  onDrag(cb: (state: 'enter' | 'leave') => any): void;
  handleUploadPreviewUpdate: (event: UploadPreviewUpdateEventPayload) => void;
  private subscribeStateChanged;
  handleUploadError: ({ error, fileId }: UploadErrorEventPayload) => void;
  handleMobileUploadEnd: (event: MobileUploadEndEventPayload) => void;
  handleReady: (event: UploadEndEventPayload) => void;
}

declare type PickerFacadeConfig = {
  mediaClientConfig: MediaClientConfig;
  errorReporter: ErrorReportingHandler;
  featureFlags?: MediaFeatureFlags_2;
};

declare type PickerImageAEP = PickerAEP<
  ACTION_SUBJECT_ID.PICKER_CLOUD,
  {
    inputMethod:
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.QUICK_INSERT
      | INPUT_METHOD.INSERT_MENU;
  }
>;

declare type PickerType = 'clipboard' | 'dropzone' | 'customMediaPicker';

declare interface PlaceholderPluginOptions {
  placeholder?: string;
  placeholderHints?: string[];
  placeholderBracketHint?: string;
}

declare interface PlaceholderTextOptions {
  allowInserting?: boolean;
}

declare enum PLATFORMS {
  NATIVE = 'mobileNative',
  HYBRID = 'mobileHybrid',
  WEB = 'web',
}

declare interface PluginConfig {
  advanced?: boolean;
  allowBackgroundColor?: boolean;
  allowColumnResizing?: boolean;
  allowHeaderColumn?: boolean;
  allowHeaderRow?: boolean;
  allowMergeCells?: boolean;
  allowNumberColumn?: boolean;
  allowColumnSorting?: boolean;
  allowAddColumnWithCustomStep?: boolean;
  allowCollapse?: boolean;
  isHeaderRowRequired?: boolean;
  stickToolbarToBottom?: boolean;
  permittedLayouts?: PermittedLayoutsDescriptor;
  allowControls?: boolean;
  stickyHeaders?: boolean;
  allowCellOptionsInFloatingToolbar?: boolean;
  tableCellOptimization?: boolean;
  tableRenderOptimization?: boolean;
  stickyHeadersOptimization?: boolean;
  initialRenderOptimization?: boolean;
  mouseMoveOptimization?: boolean;
  tableOverflowShadowsOptimization?: boolean;
  allowDistributeColumns?: boolean;
}

declare interface PluginMethodReport {
  stateApply: number;
  viewUpdate: number;
  onEditorViewStateUpdated: number;
}

declare interface PluginPerformanceReportData {
  trigger: string;
  duration: number;
  nodes: NodeCount;
  extensionNodes: NodeCount;
  plugins: PluginsReport;
  slowPlugins: PluginsReport;
  stepDurations: {
    stateApply: number;
    viewUpdate: number;
    onChange: number;
    onEditorViewStateUpdated: number;
    countNodes: number;
  };
}

declare type PluginsOptions = {
  [pluginName: string]: any;
  quickInsert?: QuickInsertHandler;
  typeAhead?: TypeAheadHandler;
  floatingToolbar?: FloatingToolbarHandler;
  contextPanel?: ContextPanelHandler;
};

declare interface PluginsReport {
  [name: string]: PluginMethodReport;
}

declare type PMPlugin = {
  name: string;
  plugin: PMPluginFactory;
};

declare type PMPluginFactory = (
  params: PMPluginFactoryParams,
) => SafePlugin | undefined;

declare type PMPluginFactoryParams = {
  schema: Schema;
  dispatch: Dispatch;
  eventDispatcher: EventDispatcher;
  providerFactory: ProviderFactory;
  errorReporter?: ErrorReporter;
  portalProviderAPI: PortalProviderAPI;
  reactContext: () => EditorReactContext;
  dispatchAnalyticsEvent: DispatchAnalyticsEvent;
  featureFlags: EditorFeatureFlags;
  getIntl: () => IntlShape;
};

export declare const PortalProvider: React_2.FC<
  WithIntlProps<BasePortalProviderProps>
> & {
  WrappedComponent: React_2.ComponentType<BasePortalProviderProps>;
};

export declare class PortalProviderAPI extends EventDispatcher {
  portals: Map<HTMLElement, MountedPortal>;
  context: any;
  intl: IntlShape;
  onAnalyticsEvent?: FireAnalyticsCallback;
  useAnalyticsContext?: boolean;
  themeMode?: ThemeModes;
  constructor(
    intl: IntlShape,
    onAnalyticsEvent?: FireAnalyticsCallback,
    analyticsContext?: boolean,
    themeMode?: ThemeModes,
  );
  setContext: (context: any) => void;
  render(
    children: () => React_2.ReactChild | JSX.Element | null,
    container: HTMLElement,
    hasAnalyticsContext?: boolean,
    hasIntlContext?: boolean,
  ): void;
  forceUpdate({ intl }: { intl: IntlShape }): void;
  remove(container: HTMLElement): void;
}

export declare class PortalRenderer extends React_2.Component<
  {
    portalProviderAPI: PortalProviderAPI;
  },
  PortalRendererState
> {
  constructor(props: { portalProviderAPI: PortalProviderAPI });
  handleUpdate: (portals: Portals) => void;
  render(): JSX.Element;
}

declare type PortalRendererState = {
  portals: Portals;
};

declare type Portals = Map<HTMLElement, React_2.ReactChild>;

declare type Predicate = (state: EditorState, view?: EditorView) => boolean;

export { PresenceProvider };

export { PresenceResource };

declare type PrimaryToolbarComponents =
  | BeforeAndAfterToolbarComponents
  | ReactComponents;

declare const processItems: (
  items: Array<QuickInsertHandler>,
  intl: IntlShape,
  extendedActions?: Record<string, Function> | undefined,
) => QuickInsertItem[];

export declare const processQuickInsertItems: typeof processItems;

declare interface Props {
  placeholder?: string;
  children?: any;
  isExpanded?: boolean;
  onFocus?: (e: React_2.FocusEvent<HTMLInputElement>) => void;
  onExpand?: () => void;
}

declare interface Props_2 {
  title?: string;
  titlePosition?: PositionType;
}

declare interface Props_3 {
  /** @deprecated  To pass package version use feedbackInfo property – <Editor feedbackInfo={{ packageVersion }} /> */
  packageVersion?: string;
  /** @deprecated  'To pass package name use feedbackInfo property – <Editor feedbackInfo={{ packageName }} /> */
  packageName?: string;
  product?: EditorProduct;
  popupsMountPoint?: HTMLElement;
  popupsBoundariesElement?: HTMLElement;
  popupsScrollableElement?: HTMLElement;
  /** @deprecated 'To pass feedback labels use feedbackInfo property – <Editor feedbackInfo={{ labels }} />' */
  labels?: string[];
}

declare type Props_4 = {
  visible: boolean;
  children?: React_2.ReactElement;
};

declare type Props_5 = {
  oldPluginState: TypeAheadPluginState;
  newPluginState: TypeAheadPluginState;
};

declare interface Props_6<P extends NamedPluginKeys> {
  debounce?: boolean;
  eventDispatcher?: EventDispatcher;
  editorView?: EditorView;
  plugins: P;
  render: (pluginState: NamedPluginStates<P>) => React_2.ReactElement | null;
}

declare type ProsemirrorGetPosHandler = () => number;

declare type ProseMirrorRenderedTracking = {
  enabled?: boolean;
  /**
   * @description Control whether proseMirror rendered event severity is tracked. When this is false the severity is not recorded.
   * @default false
   */
  trackSeverity: boolean;
  /**
   * @description Control for calculating severity level (NORMAL/DEGRADED/BLOCKING). Depends on severityTracking being true.
   * @default 2000
   */
  severityNormalThreshold: number;
  /**
   * @description Control for calculating severity level (NORMAL/DEGRADED/BLOCKING). Depends on severityTracking being true.
   * @default 3000
   */
  severityDegradedThreshold: number;
};

declare enum PUNC {
  DASH = 'emDash',
  ELLIPSIS = 'ellipsis',
  QUOTE_SINGLE = 'singleQuote',
  QUOTE_DOUBLE = 'doubleQuote',
}

export { QuickInsertActionInsert };

declare type QuickInsertHandler =
  | Array<QuickInsertItem>
  | ((intl: IntlShape) => Array<QuickInsertItem>);

export { QuickInsertItem };

export { QuickInsertItemId };

declare type QuickInsertOptions =
  | boolean
  | {
      provider: Promise<QuickInsertProvider>;
    };

export declare const quickInsertPluginKey: PluginKey<
  QuickInsertPluginState,
  any
>;

declare interface QuickInsertPluginOptions {
  headless?: boolean;
  disableDefaultItems?: boolean;
  enableElementBrowser?: boolean;
  elementBrowserHelpUrl?: string;
  emptyStateHandler?: EmptyStateHandler;
}

export declare type QuickInsertPluginState = {
  isElementBrowserModalOpen: boolean;
  lazyDefaultItems: () => QuickInsertItem[];
  providedItems?: QuickInsertItem[];
  provider?: QuickInsertProvider;
  emptyStateHandler?: EmptyStateHandler;
};

export { QuickInsertProvider };

declare type QuickSearchPerfAEP = OperationalAEP<
  ACTION.INVOKED,
  ACTION_SUBJECT.SEARCH_RESULT,
  ACTION_SUBJECT_ID.QUICK_SEARCH,
  {
    duration: number;
    count: number;
    errorCode?: number;
  },
  {
    error?: string;
  }
>;

declare type ReactComponents = ReactElement<any> | ReactElement<any>[];

export declare const ReactEditorView: React_2.FC<
  WithIntlProps<EditorViewProps & WrappedComponentProps<'intl'>>
> & {
  WrappedComponent: React_2.ComponentType<
    EditorViewProps & WrappedComponentProps<'intl'>
  >;
};

declare type ReactNodeViewRenderedAEP = OperationalAEP<
  ACTION.REACT_NODEVIEW_RENDERED,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    node: string;
    duration: number;
    participants: number;
  },
  undefined
>;

declare type RecentActivitiesPerfAEP = OperationalAEP<
  ACTION.INVOKED,
  ACTION_SUBJECT.SEARCH_RESULT,
  ACTION_SUBJECT_ID.RECENT_ACTIVITIES,
  {
    duration: number;
    count: number;
    errorCode?: number;
  },
  {
    error?: string;
  }
>;

declare interface RectData {
  top: number;
  left: number;
}

export declare const removeStatus: (showStatusPickerAt: number) => Command;

declare interface RenderOptionsPropsT<T> {
  hide: () => void;
  dispatchCommand: (command: T) => void;
}

declare type RenderTracking = {
  /**
   * @description Control whether editor render tracking should be enabled.
   * @default false
   */
  editor: {
    enabled: boolean;
    useShallow?: boolean;
  };
  reactEditorView: {
    enabled: boolean;
    useShallow?: boolean;
  };
};

declare type ReplaceAllAEP = TrackAEP<
  ACTION.REPLACED_ALL,
  ACTION_SUBJECT.TEXT,
  undefined,
  undefined,
  undefined
>;

declare type ReplaceOneAEP = TrackAEP<
  ACTION.REPLACED_ONE,
  ACTION_SUBJECT.TEXT,
  undefined,
  {
    triggerMethod: TRIGGER_METHOD.KEYBOARD | TRIGGER_METHOD.BUTTON;
  },
  undefined
>;

declare type ReplaceTextChangeAEP = TrackAEP<
  ACTION.CHANGED_REPLACEMENT_TEXT,
  ACTION_SUBJECT.FIND_REPLACE_DIALOG,
  undefined,
  undefined,
  undefined
>;

declare enum RESOLVE_METHOD {
  COMPONENT = 'component',
  CONSUMER = 'consumer',
  ORPHANED = 'orphaned',
}

declare type RichMediaLayoutAEP = TrackAEP<
  ACTION.SELECTED,
  ACTION_SUBJECT.MEDIA_SINGLE | ACTION_SUBJECT.EMBEDS,
  ACTION_SUBJECT_ID.RICH_MEDIA_LAYOUT,
  {
    previousLayoutType: RichMediaLayout;
    currentLayoutType: RichMediaLayout;
  },
  undefined
>;

declare type ScreenAEP<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes,
  NonPrivacySafeAttributes
> = AEP<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes,
  NonPrivacySafeAttributes,
  EVENT_TYPE.SCREEN
>;

declare type ScrollGutterPluginOptions = {
  /** Element the page uses for scrolling */
  getScrollElement?: (view: EditorView) => HTMLElement | null;
  /**
   * Whether to allow custom functionality to scroll to gutter element in
   * plugin's handleScrollToSelection function
   * Default is true
   */
  allowCustomScrollHandler?: boolean;
  /**
   * Persist scroll gutter when the mobile appearance is COMPACT
   * Default is false
   */
  persistScrollGutter?: boolean;
  gutterSize?: number;
};

declare type SelectAEP<ActionSubjectID, Attributes> = TrackAEP<
  ACTION.SELECTED,
  ACTION_SUBJECT.DOCUMENT,
  ActionSubjectID,
  Attributes,
  undefined
>;

declare type SelectAllAEP = SelectAEP<ACTION_SUBJECT_ID.ALL, undefined>;

declare type SelectCellAEP = SelectAEP<
  ACTION_SUBJECT_ID.CELL,
  {
    selectedCells: number;
    totalCells: number;
  }
>;

declare type SelectedSearchResultsAEP = UIAEP<
  ACTION.SELECTED,
  ACTION_SUBJECT.SEARCH_RESULT,
  undefined,
  {
    source: string;
    searchSessionId: string;
    trigger: string;
    resultCount: number;
    selectedResultId: string;
    selectedRelativePosition: number;
    prefetch: boolean;
  },
  undefined
>;

declare enum SELECTION_POSITION {
  START = 'start',
  MIDDLE = 'middle',
  END = 'end',
  LEFT = 'left',
  RIGHT = 'right',
}

declare enum SELECTION_TYPE {
  CURSOR = 'cursor',
  RANGED = 'ranged',
  GAP_CURSOR = 'gapCursor',
  NODE = 'node',
  CELL = 'cell',
}

declare enum SELECTION_TYPE_2 {
  TEXT = 'text',
  NODE = 'node',
  CELL = 'cell',
  GAP_CURSOR = 'gapCursor',
}

declare type SelectionAEP = TrackAEP<
  ACTION.MATCHED,
  ACTION_SUBJECT.SELECTION,
  undefined,
  undefined,
  undefined
>;

export declare type SelectionData =
  | AllSelectionData
  | NodeSelectionData
  | TextSelectionData
  | GapSelectionData
  | CellSelectionData;

export declare interface SelectionDataState {
  rect: RectData;
  selection: SelectionData;
  nodeTypes: string[];
  markTypes: string[];
}

declare type SelectionEventPayload =
  | SelectNodeAEP
  | SelectRangeAEP
  | SelectAllAEP
  | SelectCellAEP;

declare type SelectionJson = {
  type: SELECTION_TYPE_2;
  anchor?: number;
  head?: number;
  side?: GAP_CURSOR_POSITION;
  pos?: number;
};

export declare const selectionPluginKey: PluginKey<any, any>;

declare interface SelectionPluginOptions
  extends LongPressSelectionPluginOptions {}

declare type SelectNodeAEP = SelectAEP<
  ACTION_SUBJECT_ID.NODE,
  {
    node: string;
  }
>;

export declare interface SelectOption<T = unknown> {
  value: string;
  label: string;
  selected?: boolean;
  disabled?: boolean;
  hidden?: boolean;
  data?: T;
}

declare type SelectRangeAEP = SelectAEP<
  ACTION_SUBJECT_ID.RANGE,
  {
    nodes: string[];
    from: number;
    to: number;
  }
>;

export declare function setBlockType(name: string): Command;

export declare function setBlockTypeWithAnalytics(
  name: string,
  inputMethod: BlockTypeInputMethod,
): Command;

export declare const setIsExpanded: (isExpanded: boolean) => Command;

export declare const setKeyboardHeight: (keyboardHeight: number) => Command;

export declare const setMobilePaddingTop: (paddingTop: number) => Command;

export declare const setStatusPickerAt: (
  showStatusPickerAt: number | null,
) => (state: EditorState, dispatch: (tr: Transaction) => void) => boolean;

export declare function setTextSelection(
  view: EditorView,
  anchor: number,
  head?: number,
): void;

declare type ShownPostQuerySearchResultsAEP = UIAEP<
  ACTION.SHOWN,
  ACTION_SUBJECT.SEARCH_RESULT,
  ACTION_SUBJECT_ID.POST_QUERY_SEARCH_RESULTS,
  {
    source: string;
    postQueryRequestDurationMs: number;
    searchSessionId: string;
    resultCount: number;
    results: Array<{
      resultContentId: string;
      resultType: string;
    }>;
  },
  undefined
>;

declare type ShownPreQuerySearchResultsAEP = UIAEP<
  ACTION.SHOWN,
  ACTION_SUBJECT.SEARCH_RESULT,
  ACTION_SUBJECT_ID.PRE_QUERY_SEARCH_RESULTS,
  {
    source: string;
    preQueryRequestDurationMs: number;
    searchSessionId: string;
    resultCount: number;
    results: Array<{
      resultContentId: string;
      resultType: string;
    }>;
  },
  undefined
>;

declare interface SimpleEntry {
  name: string;
  duration: number;
  startTime: number;
}

declare type SimplifiedNode = {
  type: string;
  pos: number;
  nodeSize: number;
  marks?: string[];
  content?: SimplifiedNode[];
};

declare type SlowInputAEP = OperationalAEPWithObjectId<
  ACTION.SLOW_INPUT,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    time: number;
    nodeSize: number;
    participants: number;
    nodeCount?: Record<string, number>;
  },
  undefined
>;

declare enum SMART_LINK_TYPE {
  INLINE_CARD = 'inline',
  BLOCK_CARD = 'block',
  URL = 'url',
}

declare type SmartLinkErrorAEP = OperationalAEP<
  ACTION.ERRORED,
  ACTION_SUBJECT.SMART_LINK,
  undefined,
  {
    error: string;
    errorStack?: string;
  },
  undefined
>;

declare type SmartLinkNodeContext =
  | 'doc'
  | 'blockquote'
  | 'tableCell'
  | 'tableHeader'
  | 'decisionList'
  | 'listItem'
  | 'bodiedExtension'
  | 'panel'
  | 'taskList'
  | 'mixed';

declare interface SortColumn {
  sortOrder: TableSortOrder;
  mode: 'editor';
}

declare type State = {
  extensionProvider?: ExtensionProvider;
  quickInsertProvider?: Promise<QuickInsertProvider>;
};

declare interface State_2 {}

declare interface State_3 {
  jiraIssueCollectorScriptLoading: boolean;
  showOptOutOption?: boolean;
  target?: HTMLElement;
}

declare interface State_4 {
  [name: string]: any;
}

export declare const statusMessages: {
  placeholder: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  editText: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  editColor: {
    id: string;
    defaultMessage: string;
    description: string;
  };
};

export declare const statusPluginKey: PluginKey<StatusState, any>;

export declare type StatusState = {
  isNew: boolean;
  showStatusPickerAt: number | null;
};

export declare type StatusType = {
  color: Color;
  text: string;
  localId?: string;
};

declare type SubscribeToToolbarAndPickerUpdates = (
  editorView: EditorView,
  cb: (args: SubscribeToToolbarAndPickerUpdatesCallbackArgs) => void,
) => () => void;

export declare const subscribeToToolbarAndPickerUpdates: SubscribeToToolbarAndPickerUpdates;

declare type SubscribeToToolbarAndPickerUpdatesCallbackArgs = {
  dateState: DatePluginState;
  statusState: StatusState;
  toolbarConfig: ConfigWithNodeInfo | null | undefined;
};

declare type SubscribeTypeAheadUpdates = (
  editorView: EditorView,
  cb: (props: Props_5) => void,
) => () => void;

export declare const subscribeTypeAheadUpdates: SubscribeTypeAheadUpdates;

declare type SubstituteAEP<ActionSubjectID, Attributes> = TrackAEP<
  ACTION.SUBSTITUTED,
  ACTION_SUBJECT.TEXT,
  ActionSubjectID,
  Attributes,
  undefined
>;

declare type SubstituteEventPayload =
  | SubstituteProductAEP
  | SubstituteSymbolAEP
  | SubstitutePuncAEP;

declare type SubstituteProductAEP = SubstituteAEP<
  ACTION_SUBJECT_ID.PRODUCT_NAME,
  {
    product: string;
    originalSpelling: string;
  }
>;

declare type SubstitutePuncAEP = SubstituteAEP<
  ACTION_SUBJECT_ID.PUNC,
  {
    punctuation:
      | PUNC.DASH
      | PUNC.ELLIPSIS
      | PUNC.QUOTE_SINGLE
      | PUNC.QUOTE_DOUBLE;
  }
>;

declare type SubstituteSymbolAEP = SubstituteAEP<
  ACTION_SUBJECT_ID.SYMBOL,
  {
    symbol: SYMBOL.ARROW_RIGHT | SYMBOL.ARROW_LEFT | SYMBOL.ARROW_DOUBLE;
  }
>;

declare enum SYMBOL {
  ARROW_RIGHT = 'rightArrow',
  ARROW_LEFT = 'leftArrow',
  ARROW_DOUBLE = 'doubleArrow',
}

declare type SynchronyEntityErrorAEP = OperationalAEP<
  ACTION.SYNCHRONY_ENTITY_ERROR | ACTION.SYNCHRONY_DISCONNECTED,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    onLine: boolean;
    visibilityState: string;
  },
  undefined
>;

declare type SynchronyErrorAEP = OperationalAEP<
  ACTION.SYNCHRONY_ERROR,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    error: Error;
    docStructure?: string | SimplifiedNode;
    browserExtensions?: UserBrowserExtensionResults;
  },
  undefined
>;

declare enum TABLE_ACTION {
  DELETED = 'deleted',
  CLEARED = 'cleared',
  COLLAPSED = 'collapsed',
  MERGED = 'merged',
  SPLIT = 'split',
  COLORED = 'colored',
  TOGGLED_HEADER_COLUMN = 'toggledHeaderColumn',
  TOGGLED_HEADER_ROW = 'toggledHeaderRow',
  TOGGLED_NUMBER_COLUMN = 'toggledNumberColumn',
  CHANGED_BREAKOUT_MODE = 'changedBreakoutMode',
  CUT = 'cut',
  COPIED = 'copied',
  ADDED_ROW = 'addedRow',
  ADDED_COLUMN = 'addedColumn',
  DELETED_ROW = 'deletedRow',
  DELETED_COLUMN = 'deletedColumn',
  SORTED_COLUMN = 'sortedColumn',
  REPLACED = 'replaced',
  ATTEMPTED_TABLE_WIDTH_CHANGE = 'attemptedTableWidthChange',
  DISTRIBUTED_COLUMNS_WIDTHS = 'distributedColumnsWidths',
}

declare enum TABLE_BREAKOUT {
  WIDE = 'wide',
  FULL_WIDTH = 'fullWidth',
  NORMAL = 'normal',
}

declare type TableAddRowOrColumnAEP = TableAEP<
  TABLE_ACTION.ADDED_ROW | TABLE_ACTION.ADDED_COLUMN,
  {
    inputMethod:
      | INPUT_METHOD.SHORTCUT
      | INPUT_METHOD.CONTEXT_MENU
      | INPUT_METHOD.BUTTON
      | INPUT_METHOD.KEYBOARD
      | INPUT_METHOD.FLOATING_TB;
    position: number;
  } & TotalRowAndColCount,
  undefined
>;

declare type TableAEP<Action, Attributes, NonPrivacySafeAttributes> = TrackAEP<
  Action,
  ACTION_SUBJECT.TABLE,
  null,
  Attributes,
  NonPrivacySafeAttributes
>;

declare type TableAttemptedResizeAEP = UIAEP<
  TABLE_ACTION.ATTEMPTED_TABLE_WIDTH_CHANGE,
  ACTION_SUBJECT.TABLE,
  null,
  AttemptedResizeInfo,
  undefined
>;

declare type TableChangeBreakoutAEP = TableAEP<
  TABLE_ACTION.CHANGED_BREAKOUT_MODE,
  {
    newBreakoutMode: TABLE_BREAKOUT;
    previousBreakoutMode: TABLE_BREAKOUT;
  } & TotalRowAndColCount,
  undefined
>;

declare type TableClearAEP = TableAEP<
  TABLE_ACTION.CLEARED,
  {
    inputMethod:
      | INPUT_METHOD.KEYBOARD
      | INPUT_METHOD.CONTEXT_MENU
      | INPUT_METHOD.FLOATING_TB;
  } & HorizontalAndVerticalCells &
    TotalRowAndColCount,
  undefined
>;

declare type TableCollapsedAEP = TableAEP<
  TABLE_ACTION.COLLAPSED,
  TotalRowAndColCount,
  undefined
>;

declare type TableColorAEP = TableAEP<
  TABLE_ACTION.COLORED,
  {
    cellColor: string;
  } & AllCellInfo,
  undefined
>;

declare type TableCopyAndCutAEP = TableAEP<
  TABLE_ACTION.CUT | TABLE_ACTION.COPIED,
  AllCellInfo,
  undefined
>;

declare type TableDeleteAEP = TableAEP<
  TABLE_ACTION.DELETED,
  {
    inputMethod: INPUT_METHOD.KEYBOARD | INPUT_METHOD.FLOATING_TB;
  } & TotalRowAndColCount,
  undefined
>;

declare type TableDeleteRowOrColumnAEP = TableAEP<
  TABLE_ACTION.DELETED_ROW | TABLE_ACTION.DELETED_COLUMN,
  {
    inputMethod:
      | INPUT_METHOD.CONTEXT_MENU
      | INPUT_METHOD.BUTTON
      | INPUT_METHOD.FLOATING_TB;
    position: number;
    count: number;
  } & TotalRowAndColCount,
  undefined
>;

declare type TableDistributeColumnsWidthsAEP = TableAEP<
  TABLE_ACTION.DISTRIBUTED_COLUMNS_WIDTHS,
  {
    inputMethod: INPUT_METHOD.CONTEXT_MENU;
    position: number;
    count: number;
  } & TotalRowAndColCount,
  undefined
>;

declare type TableEventPayload =
  | TableDeleteAEP
  | TableClearAEP
  | TableMergeSplitAEP
  | TableColorAEP
  | TableToggleHeaderAEP
  | TableChangeBreakoutAEP
  | TableCopyAndCutAEP
  | TableAddRowOrColumnAEP
  | TableSortColumnAEP
  | TableDeleteRowOrColumnAEP
  | TableReplaceAEP
  | TableAttemptedResizeAEP
  | TableDistributeColumnsWidthsAEP
  | TableCollapsedAEP;

declare type TableMergeSplitAEP = TableAEP<
  TABLE_ACTION.MERGED | TABLE_ACTION.SPLIT,
  AllCellInfo,
  undefined
>;

declare type TableReplaceAEP = TableAEP<
  TABLE_ACTION.REPLACED,
  {
    inputMethod: INPUT_METHOD.KEYBOARD | INPUT_METHOD.CLIPBOARD;
  } & TotalRowAndColCount,
  undefined
>;

declare type TableSortColumnAEP = TableAEP<
  TABLE_ACTION.SORTED_COLUMN,
  {
    inputMethod:
      | INPUT_METHOD.SHORTCUT
      | INPUT_METHOD.CONTEXT_MENU
      | INPUT_METHOD.BUTTON
      | INPUT_METHOD.KEYBOARD;
    position: number;
  } & TotalRowAndColCount &
    SortColumn,
  undefined
>;

declare type TableToggleHeaderAEP = TableAEP<
  | TABLE_ACTION.TOGGLED_NUMBER_COLUMN
  | TABLE_ACTION.TOGGLED_HEADER_ROW
  | TABLE_ACTION.TOGGLED_HEADER_COLUMN,
  {
    newState: boolean;
  } & TotalRowAndColCount,
  undefined
>;

declare enum TARGET_SELECTION_SOURCE {
  CURRENT_SELECTION = 'currentSelection',
  HTML_ELEMENT = 'htmlElement',
}

export declare type TaskDecisionInputMethod =
  | INPUT_METHOD.TOOLBAR
  | INPUT_METHOD.INSERT_MENU
  | INPUT_METHOD.QUICK_INSERT
  | INPUT_METHOD.FORMATTING
  | INPUT_METHOD.KEYBOARD;

declare type TaskDecisionListType = 'taskList' | 'decisionList';

export { TeamMentionResource };

declare type TextColorDefaultColor = {
  color: string;
  label: string;
};

declare interface TextColorPluginConfig {
  defaultColor?: TextColorDefaultColor;
  allowMoreTextColors?: boolean;
}

export declare const textColorPluginKey: PluginKey<TextColorPluginState, any>;

export declare type TextColorPluginState = {
  palette: Array<PaletteColor>;
  paletteExpanded?: Array<PaletteColor>;
  defaultColor: string;
  disabled?: boolean;
  color: string | null;
};

declare type TextColorSelectedAEP = ExperimentalAEP<
  ACTION.FORMATTED,
  ACTION_SUBJECT.TEXT,
  ACTION_SUBJECT_ID.FORMAT_COLOR,
  TextColorSelectedAttr
>;

declare interface TextColorSelectedAttr {
  color: string;
  isNewColor: boolean;
}

declare type TextColorShowPaletteToggleAEP = ExperimentalAEP<
  ACTION.OPENED | ACTION.CLOSED,
  ACTION_SUBJECT.TOOLBAR,
  ACTION_SUBJECT_ID.FORMAT_COLOR,
  TextColorShowPaletteToggleAttr
>;

declare interface TextColorShowPaletteToggleAttr {
  noSelect: boolean;
}

export declare type TextFormattingInputMethodBasic =
  | TextFormattingInputMethodToolbar
  | INPUT_METHOD.SHORTCUT
  | INPUT_METHOD.FORMATTING;

export declare type TextFormattingInputMethodToolbar = INPUT_METHOD.TOOLBAR;

declare interface TextFormattingOptions {
  disableSuperscriptAndSubscript?: boolean;
  disableUnderline?: boolean;
  disableCode?: boolean;
  disableSmartTextCompletion?: boolean;
  responsiveToolbarMenu?: boolean;
}

export declare interface TextFormattingState {
  emActive?: boolean;
  emDisabled?: boolean;
  emHidden?: boolean;
  codeActive?: boolean;
  codeDisabled?: boolean;
  codeHidden?: boolean;
  underlineActive?: boolean;
  underlineDisabled?: boolean;
  underlineHidden?: boolean;
  strikeActive?: boolean;
  strikeDisabled?: boolean;
  strikeHidden?: boolean;
  strongActive?: boolean;
  strongDisabled?: boolean;
  strongHidden?: boolean;
  superscriptActive?: boolean;
  superscriptDisabled?: boolean;
  superscriptHidden?: boolean;
  subscriptActive?: boolean;
  subscriptDisabled?: boolean;
  subscriptHidden?: boolean;
}

export declare const textFormattingStateKey: PluginKey<
  TextFormattingState,
  any
>;

declare type TextLinkCodeMarkTransformedAEP = OperationalAEP<
  ACTION.TEXT_LINK_MARK_TRANSFORMED,
  ACTION_SUBJECT.EDITOR,
  undefined,
  undefined,
  undefined
>;

declare interface TextSelectionData {
  type: 'text';
  anchor: number;
  head: number;
}

declare function toggleBulletList(
  view: EditorView,
  inputMethod?: ListInputMethod,
): boolean;

export declare const toggleCode: () => Command;

export declare const toggleCodeWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

export declare const toggleEm: () => Command;

export declare const toggleEmWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

declare function toggleOrderedList(
  view: EditorView,
  inputMethod?: ListInputMethod,
): boolean;

export declare const toggleStrike: () => Command;

export declare const toggleStrikeWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

export declare const toggleStrong: () => Command;

export declare const toggleStrongWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

export declare const toggleSubscript: () => Command;

export declare const toggleSubscriptWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

export declare const toggleSuperscript: () => Command;

export declare const toggleSuperscriptWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

export declare const toggleUnderline: () => Command;

export declare const toggleUnderlineWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

export declare class ToolbarFeedback extends PureComponent<Props_3, State_3> {
  static contextTypes: {
    editorActions: PropTypes.Validator<object>;
  };
  state: State_3;
  constructor(props: Props_3);
  private handleRef;
  showJiraCollectorDialogCallback?: () => void;
  private getFeedbackInfo;
  render(): jsx.JSX.Element | null;
  private collectFeedback;
  private toggleShowOptOutOption;
  private openJiraIssueCollector;
  private openFeedbackPopup;
  private openLearnMorePage;
  private hasJquery;
}

export declare const ToolbarHelp: React_2.FC<
  WithIntlProps<Props_2 & WrappedComponentProps<'intl'>>
> & {
  WrappedComponent: React_2.ComponentType<
    Props_2 & WrappedComponentProps<'intl'>
  >;
};

declare enum ToolbarSize {
  XXL = 6,
  XL = 5,
  L = 4,
  M = 3,
  S = 2,
  XXXS = 1,
}

declare type ToolbarUIComponentFactory = (
  params: ToolbarUiComponentFactoryParams,
) => React_2.ReactElement<any> | null;

declare type ToolbarUiComponentFactoryParams = UiComponentFactoryParams & {
  toolbarSize: ToolbarSize;
  isToolbarReducedSpacing: boolean;
  isLastItem?: boolean;
};

declare interface TotalRowAndColCount {
  totalRowCount: number;
  totalColumnCount: number;
}

declare type TrackAEP<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes,
  NonPrivacySafeAttributes,
  ImplicitAttributes extends {} = {}
> = AEP<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes,
  NonPrivacySafeAttributes,
  EVENT_TYPE.TRACK,
  ImplicitAttributes
>;

declare type TransactionEventPayload = DispatchedValidTransactionAEP;

declare type TransactionMutatedAEP = OperationalAEP<
  ACTION.TRANSACTION_MUTATED_AFTER_DISPATCH,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    pluginKey: string;
  },
  undefined
>;

declare class TransactionTracker {
  private dispatchCallCounter;
  private readonly measureMap;
  private readonly measureListeners;
  addMeasureListener(listener: MeasureListener): void;
  removeMeasureListener(listener: MeasureListener): void;
  shouldTrackTransaction(options: TransactionTracking): boolean;
  bumpDispatchCounter: (options: TransactionTracking) => number;
  getMeasureHelpers: (options: TransactionTracking) => MeasureHelpers;
  private startMeasureSimple;
  private stopMeasureSimple;
}

declare type TransactionTracking = {
  /**
   * @description Whether transactionTracking should be enabled. When this is false no measurements are taken and no events are sent.
   * @default false
   **/
  enabled: boolean;
  /**
   * @description Enable timing using browser performance API. This option has been added to verify memory leaks.
   * @default false
   **/
  usePerformanceMarks?: boolean;
  /**
   * @description The nth transaction after which a `dispatchTransaction` event is sent. Depends on enabled being true.
   * @default 100
   **/
  samplingRate?: number;
  /**
   * @description Transactions that need longer to dispatch than [slowThreshold]ms generate a `dispatchTransaction` event. Depends on enabled being true.
   * @default 300
   **/
  slowThreshold?: number;
  /**
   * @description Transactions that need longer to dispatch than [outlierThreshold]ms AND have outlier plugins generate a `dispatchTransaction` event. Depends on enabled being true.
   * @default 30
   **/
  outlierThreshold?: number;
  /**
   * @description The factor by which statistically significant outliers in plugin execution times are computed where t = p75 + (p75 - p25) * outlierFactor.
   * @default 3
   **/
  outlierFactor?: number;
};

declare enum TRIGGER_METHOD {
  BUTTON = 'button',
  KEYBOARD = 'keyboard',
  SHORTCUT = 'shortcut',
  TOOLBAR = 'toolbar',
}

declare type TTITracking = {
  /**
   * @description Whether ttiTracking should be enabled
   * @default: false
   */
  enabled: boolean;
  /**
   * @description Time between long tasks that tti measurement considers long enough to treat page as interactive in ms
   * @default: 1000
   */
  ttiIdleThreshold?: number;
  /**
   * @description Time in [seconds] after which to stop tti measurements, used to prevent issues when page never becomes responsive, e.g. infinite loops in rendering / etc...
   * @default: 60
   */
  ttiCancelTimeout?: number;
  /**
   * @description Control whether TTI severity is tracked. When this is false the severity is not recorded.
   * @default false
   */
  trackSeverity?: boolean;
  /**
   * @description Control for calculating tti severity level (NORMAL/DEGRADED/BLOCKING). Depends on trackSeverity being true.
   * @default 40000
   */
  ttiSeverityNormalThreshold?: number;
  /**
   * @description Control for calculating tti severity level (NORMAL/DEGRADED/BLOCKING). Depends on trackSeverity being true.
   * @default 60000
   */
  ttiSeverityDegradedThreshold?: number;
  /**
   * @description Control for calculating ttiFromInvocation severity level (NORMAL/DEGRADED/BLOCKING). Depends on trackSeverity being true.
   * @default 5000
   */
  ttiFromInvocationSeverityNormalThreshold?: number;
  /**
   * @description Control for calculating ttiFromInvocation severity level (NORMAL/DEGRADED/BLOCKING). Depends on trackSeverity being true.
   * @default 8000
   */
  ttiFromInvocationSeverityDegradedThreshold?: number;
};

declare type TypeAheadAEP<ActionSubjectID, Attributes> = UIAEP<
  ACTION.INVOKED,
  ACTION_SUBJECT.TYPEAHEAD,
  ActionSubjectID,
  Attributes,
  undefined
>;

declare type TypeAheadEmojiAEP = TypeAheadAEP<
  ACTION_SUBJECT_ID.TYPEAHEAD_EMOJI | TypeAheadAvailableNodes.EMOJI,
  {
    inputMethod:
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU
      | INPUT_METHOD.QUICK_INSERT
      | INPUT_METHOD.KEYBOARD;
  }
>;

declare type TypeAheadForceSelect = (
  props: TypeAheadForceSelectProps,
) => TypeAheadItem | undefined;

declare type TypeAheadForceSelectProps = {
  query: string;
  items: Array<TypeAheadItem>;
  editorState: EditorState;
};

declare type TypeAheadHandler = {
  id: TypeAheadAvailableNodes;
  trigger: string;
  customRegex?: string;
  headless?: boolean;
  forceSelect?: TypeAheadForceSelect;
  onInvokeAnalytics?: TypeAheadPayload;
  onOpen?: (editorState: EditorState) => void;
  getItems: (props: {
    query: string;
    editorState: EditorState;
  }) => Promise<Array<TypeAheadItem>>;
  selectItem: TypeAheadSelectItem;
  dismiss?: (props: {
    editorState: EditorState;
    query: string;
    stats: TypeAheadStats;
    wasItemInserted?: boolean;
  }) => void;
  getHighlight?: (state: EditorState) => JSX.Element | null;
};

declare type TypeAheadInputMethod =
  | INPUT_METHOD.INSERT_MENU
  | INPUT_METHOD.KEYBOARD
  | INPUT_METHOD.QUICK_INSERT
  | INPUT_METHOD.TOOLBAR;

declare type TypeAheadInsert = (
  node?: Node_2 | Object | string | Fragment,
  opts?: {
    selectInlineNode?: boolean;
  },
) => Transaction;

export { TypeAheadItem };

declare type TypeAheadItemViewedAEP = OperationalAEP<
  ACTION.VIEWED,
  ACTION_SUBJECT.TYPEAHEAD_ITEM,
  undefined,
  {
    index?: number;
    items?: number;
  },
  undefined
>;

declare type TypeAheadLinkAEP = TypeAheadAEP<
  ACTION_SUBJECT_ID.TYPEAHEAD_LINK,
  {
    inputMethod:
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU
      | INPUT_METHOD.QUICK_INSERT
      | INPUT_METHOD.SHORTCUT;
  }
>;

declare type TypeAheadMentionAEP = TypeAheadAEP<
  ACTION_SUBJECT_ID.TYPEAHEAD_MENTION | TypeAheadAvailableNodes.MENTION,
  {
    inputMethod:
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU
      | INPUT_METHOD.QUICK_INSERT
      | INPUT_METHOD.KEYBOARD;
  }
>;

declare type TypeAheadPayload =
  | TypeAheadEmojiAEP
  | TypeAheadLinkAEP
  | TypeAheadMentionAEP
  | TypeAheadQuickInsertAEP
  | TypeAheadRenderedAEP
  | TypeAheadItemViewedAEP;

export declare const typeAheadPluginKey: PluginKey<TypeAheadPluginState, any>;

declare type TypeAheadPluginOptions = {
  isMobile?: boolean;
  createAnalyticsEvent?: CreateUIAnalyticsEvent_2;
};

export declare type TypeAheadPluginState = {
  decorationSet: DecorationSet;
  decorationElement: HTMLElement | null;
  typeAheadHandlers: Array<TypeAheadHandler>;
  query: string;
  items: Array<TypeAheadItem>;
  triggerHandler?: TypeAheadHandler;
  selectedIndex: number;
  stats: TypeAheadStatsSerializable | null;
  inputMethod: TypeAheadInputMethod | null;
};

declare type TypeAheadQuickInsertAEP = TypeAheadAEP<
  | ACTION_SUBJECT_ID.TYPEAHEAD_QUICK_INSERT
  | TypeAheadAvailableNodes.QUICK_INSERT,
  {
    inputMethod:
      | INPUT_METHOD.TOOLBAR
      | INPUT_METHOD.INSERT_MENU
      | INPUT_METHOD.QUICK_INSERT
      | INPUT_METHOD.KEYBOARD;
  }
>;

declare type TypeAheadRenderedAEP = OperationalAEP<
  ACTION.RENDERED,
  ACTION_SUBJECT.TYPEAHEAD,
  undefined,
  {
    time?: number;
    items?: number;
    initial?: boolean;
  },
  undefined
>;

declare type TypeAheadSelectItem = (
  state: EditorState,
  item: TypeAheadItem,
  insert: TypeAheadInsert,
  meta: {
    mode: SelectItemMode;
    stats: TypeAheadStats;
    query: string;
    sourceListItem: Array<TypeAheadItem>;
  },
) => Transaction | false;

declare interface TypeAheadStats {
  startedAt: number;
  endedAt: number;
  keyCount: {
    arrowUp: number;
    arrowDown: number;
  };
}

declare interface TypeAheadStatsSerializable extends TypeAheadStats {
  serialize: () => TypeAheadStats;
}

declare type TypeDateFinishedAEP = TrackAEP<
  ACTION.TYPING_FINISHED,
  ACTION_SUBJECT.DATE,
  undefined,
  undefined,
  undefined
>;

declare type TypeDateStartedAEP = TrackAEP<
  ACTION.TYPING_STARTED,
  ACTION_SUBJECT.DATE,
  undefined,
  undefined,
  undefined
>;

declare type UfoSessionCompletePayloadAEP = OperationalAEP<
  ACTION.UFO_SESSION_COMPLETE,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    interval: number;
  },
  undefined
>;

declare type UIAEP<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes,
  NonPrivacySafeAttributes
> = AEP<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes,
  NonPrivacySafeAttributes,
  EVENT_TYPE.UI
>;

declare type UIComponentFactory = (
  params: UiComponentFactoryParams,
) => React_2.ReactElement<any> | null;

declare type UiComponentFactoryParams = {
  editorView: EditorView;
  editorActions: EditorActions;
  eventDispatcher: EventDispatcher;
  dispatchAnalyticsEvent?: DispatchAnalyticsEvent;
  providerFactory: ProviderFactory;
  appearance: EditorAppearance;
  popupsMountPoint?: HTMLElement;
  popupsBoundariesElement?: HTMLElement;
  popupsScrollableElement?: HTMLElement;
  containerElement: HTMLElement | null;
  disabled: boolean;
  wrapperElement: HTMLElement | null;
};

declare type UITracking = {
  /**
   * @description Whether tracking of WithPluginState should be enabled. When this is false no measurements are taken and no events are sent.
   * @default false
   **/
  enabled: boolean;
  /**
   * @description The nth re-render of WithPluginState after which an analytics event is sent. Depends on enabled being true.
   * @default 100
   **/
  samplingRate?: number;
  /**
   * @description WithPluginState render that exceeds [slowThreshold]ms generate analytics event. Depends on enabled being true.
   * @default 4
   **/
  slowThreshold?: number;
};

declare type UnlinkToolbarAEP = UIAEP<
  ACTION.UNLINK,
  ACTION_SUBJECT.SMART_LINK | ACTION_SUBJECT.HYPERLINK,
  ACTION_SUBJECT_ID.CARD_INLINE | undefined,
  {},
  undefined
>;

declare type UnsupportedContentAEP = TrackAEP<
  ACTION.UNSUPPORTED_CONTENT_ENCOUNTERED,
  ACTION_SUBJECT.DOCUMENT,
  | ACTION_SUBJECT_ID.UNSUPPORTED_BLOCK
  | ACTION_SUBJECT_ID.UNSUPPORTED_INLINE
  | ACTION_SUBJECT_ID.UNSUPPORTED_MARK,
  {
    unsupportedNode: {
      type: string;
      parentType: string;
      ancestry: string;
    };
  },
  undefined
>;

export declare type UpdateEvent = 'create' | 'delete' | 'resolve' | 'unresolve';

export declare function updateLink(
  href: string,
  text: string,
  pos: number,
  to?: number,
): Command;

export declare const updateStatus: (status?: StatusType | undefined) => Command;

export declare const updateStatusWithAnalytics: (
  inputMethod: InsertBlockInputMethodToolbar,
  status?: StatusType | undefined,
) => Command;

declare type UploadExternalFailedAEP = OperationalAEP<
  ACTION.UPLOAD_EXTERNAL_FAIL,
  ACTION_SUBJECT.EDITOR,
  undefined,
  undefined,
  undefined
>;

declare enum USER_CONTEXT {
  EDIT = 'edit',
  NEW = 'new',
}

export declare const version: string;

declare type ViewedCreateLinkInlineDialogAEP = ScreenAEP<
  ACTION.VIEWED,
  ACTION_SUBJECT.CREATE_LINK_INLINE_DIALOG,
  undefined,
  {
    timesViewed: number;
    searchSessionId: string;
    trigger: string;
  },
  undefined
>;

declare type VisibilityEvent = 'setvisibility';

declare type VisitedHyperlink = TrackAEP<
  ACTION.VISITED,
  ACTION_SUBJECT.HYPERLINK,
  undefined,
  {
    inputMethod: INPUT_METHOD.TOOLBAR;
  },
  undefined
>;

declare type VisitedSmartLink = TrackAEP<
  ACTION.VISITED,
  ACTION_SUBJECT.SMART_LINK,
  ACTION_SUBJECT_ID.CARD_BLOCK | ACTION_SUBJECT_ID.CARD_INLINE,
  {
    inputMethod: INPUT_METHOD.TOOLBAR | INPUT_METHOD.CARD;
  },
  undefined
>;

export declare class WithEditorActions extends React_2.Component<
  WithEditorActionsProps,
  any
> {
  static contextTypes: {
    editorActions: PropTypes.Validator<object>;
  };
  context: {
    editorActions: EditorActions;
  };
  componentDidMount(): void;
  componentWillUnmount(): void;
  private onContextUpdate;
  render(): React_2.ReactElement<
    any,
    string | React_2.JSXElementConstructor<any>
  > | null;
}

declare interface WithEditorActionsProps {
  render(actions: EditorActions): React_2.ReactElement<any> | null;
}

export declare class WithHelpTrigger extends React_2.Component<
  {
    render: (openHelp: () => void) => React_2.ReactNode;
  },
  any
> {
  static contextTypes: {
    editorActions: PropTypes.Validator<object>;
  };
  openHelp: () => void;
  render(): React_2.ReactNode;
}

/**
 * Wraps component in a high order component that watches state changes of given plugins
 * and passes those states to the wrapped component.
 *
 * Example:
 * <WithPluginState
 *   eventDispatcher={eventDispatcher}
 *   editorView={editorView}
 *   plugins={{
 *     hyperlink: hyperlinkPluginKey
 *   }}
 *   render={renderComponent}
 * />
 *
 * renderComponent: ({ hyperlink }) => React.Component;
 */
export declare class WithPluginState<
  P extends NamedPluginKeys
> extends React_2.Component<Props_6<P>, State_4> {
  static displayName: string;
  private listeners;
  private debounce;
  private notAppliedState;
  private isSubscribed;
  private callsCount;
  static contextTypes: {
    editorActions: PropTypes.Requireable<object>;
    editorSharedConfig: PropTypes.Requireable<object>;
  };
  context: Context_2;
  state: NamedPluginStates<P>;
  private getEditorView;
  private getEventDispatcher;
  private handlePluginStateChange;
  /**
   * Debounces setState calls in order to reduce number of re-renders caused by several plugin state changes.
   */
  private updateState;
  private dispatchAnalyticsEvent;
  private getPluginsStates;
  private subscribe;
  private unsubscribe;
  private onContextUpdate;
  private subscribeToContextUpdates;
  private unsubscribeFromContextUpdates;
  componentDidMount(): void;
  UNSAFE_componentWillReceiveProps(nextProps: Props_6<P>): void;
  componentWillUnmount(): void;
  render(): React_2.ReactElement<
    any,
    string | React_2.JSXElementConstructor<any>
  > | null;
}

declare type WithPluginStateCalledAEP = OperationalAEP<
  ACTION.WITH_PLUGIN_STATE_CALLED,
  ACTION_SUBJECT.EDITOR,
  undefined,
  {
    plugin: string;
    duration: number;
    participants: number;
  },
  undefined
>;

export {};
````
