## API Report File for "@atlaskit/renderer".

> Do not edit this file. This report is auto-generated by [API Extractor](https://api-extractor.com/).

[Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

````ts
/// <reference types="react" />

import type { ADFStage } from '@atlaskit/editor-common/validator';
import type { AnnotationProviders } from '@atlaskit/editor-common/types';
import { CreateUIAnalyticsEvent } from '@atlaskit/analytics-next';
import type { EventHandlers } from '@atlaskit/editor-common/ui';
import type { ExtensionHandlers } from '@atlaskit/editor-common/extensions';
import { Fragment } from 'prosemirror-model';
import { jsx } from '@emotion/react';
import { Mark } from 'prosemirror-model';
import { MediaClientConfig } from '@atlaskit/media-core';
import { MediaFeatureFlags } from '@atlaskit/media-common';
import { Node as Node_2 } from 'prosemirror-model';
import { PropsDifference } from '@atlaskit/editor-common/utils';
import { ProviderFactory } from '@atlaskit/editor-common/provider-factory';
import { Schema } from 'prosemirror-model';
import { SEVERITY } from '@atlaskit/editor-common/utils';
import { ShallowPropsDifference } from '@atlaskit/editor-common/utils';
import { SortOrder } from '@atlaskit/editor-common/types';
import { SSR } from '@atlaskit/media-common';
import type { Transformer as Transformer_2 } from '@atlaskit/editor-common/types';
import { UNSUPPORTED_CONTENT_LEVEL_SEVERITY } from '@atlaskit/editor-common/utils';
import type { UnsupportedContentLevelsTracking } from '@atlaskit/editor-common/utils';
import type { UnsupportedContentPayload } from '@atlaskit/editor-common/utils';
import { UnsupportedContentTooltipPayload } from '@atlaskit/editor-common/src/utils/analytics';

declare enum ACTION {
  STARTED = 'started',
  RENDERED = 'rendered',
  RE_RENDERED = 'reRendered',
  RENDERER_TTI = 'tti',
  CRASHED = 'unhandledErrorCaught',
  INVALID_PROSEMIRROR_DOCUMENT = 'invalidProsemirrorDocument',
  SELECT_ALL_CAUGHT = 'selectAllCaught',
  SELECT_ALL_ESCAPED = 'selectAllEscaped',
  CLICKED = 'clicked',
  VIEWED = 'viewed',
  VISITED = 'visited',
  SORT_COLUMN = 'sortedColumn',
  SORT_COLUMN_NOT_ALLOWED = 'sortColumnNotAllowed',
  TOGGLE_EXPAND = 'toggleExpand',
  INSERTED = 'inserted',
  OPENED = 'opened',
  CLOSED = 'closed',
  DELETED = 'deleted',
  EDITED = 'edited',
  RESOLVED = 'resolved',
  CREATE_NOT_ALLOWED = 'createNotAllowed',
  UNSUPPORTED_CONTENT_LEVELS_TRACKING_SUCCEEDED = 'unsupportedContentLevelsTrackingSucceeded',
  UNSUPPORTED_CONTENT_LEVELS_TRACKING_ERRORED = 'unsupportedContentLevelsTrackingErrored',
  MEDIA_LINK_TRANSFORMED = 'mediaLinkTransformed',
}

declare enum ACTION_SUBJECT {
  RENDERER = 'renderer',
  BUTTON = 'button',
  ANCHOR_LINK = 'anchorLink',
  TABLE = 'table',
  EXPAND = 'expand',
  NESTED_EXPAND = 'nestedExpand',
  MEDIA_SINGLE = 'mediaSingle',
  LINK = 'link',
  ANNOTATION = 'annotation',
  MEDIA = 'media',
}

declare enum ACTION_SUBJECT_ID {
  HEADING_ANCHOR_LINK = 'headingAnchorLink',
  LINK = 'link',
  INLINE_COMMENT = 'inlineComment',
}

export declare class ADFEncoder<T> {
  encode: (value: T) => any;
  constructor(createTransformerWithSchema: TransformerProvider<T>);
}

declare type AEP<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes,
  EventType
> = {
  action: Action;
  actionSubject: ActionSubject;
  actionSubjectId?: ActionSubjectID;
  attributes?: Attributes;
  eventType: EventType;
};

declare type AnalyticsEventPayload<T = void> =
  | RendererStartAEP
  | RendererRenderedAEP
  | RendererReRenderedAEP<T>
  | ComponentCrashErrorAEP
  | RendererUnsupportedContentLevelsTrackingSucceeded
  | RendererUnsupportedContentLevelsTrackingErrored
  | RendererSelectAllCaughtAEP
  | RendererSelectAllEscapedAEP
  | HeadingAnchorLinkButtonAEP
  | AnchorLinkAEP
  | TableSortColumnNotAllowedAEP
  | TableSortColumnAEP
  | VisitLinkAEP
  | VisitMediaLinkAEP
  | ExpandAEP
  | UnsupportedContentPayload
  | UnsupportedContentTooltipPayload
  | AnnotationAEP
  | AnnotationDeleteAEP
  | MediaLnkTransformedAEP
  | InvalidProsemirrorDocumentErrorAEP
  | RendererTTIAEP;

declare type AnchorLinkAEP = UIAEP<
  ACTION.VIEWED,
  ACTION_SUBJECT.ANCHOR_LINK,
  undefined,
  {
    platform: PLATFORM.WEB;
    mode: MODE.RENDERER;
  }
>;

declare type AnnotationActionType =
  | ACTION.INSERTED
  | ACTION.CLOSED
  | ACTION.EDITED
  | ACTION.DELETED
  | ACTION.OPENED
  | ACTION.RESOLVED
  | ACTION.VIEWED
  | ACTION.CREATE_NOT_ALLOWED;

declare type AnnotationAEP = AEP<
  AnnotationActionType,
  ACTION_SUBJECT.ANNOTATION,
  ACTION_SUBJECT_ID.INLINE_COMMENT,
  AnnotationAEPAttributes,
  undefined
>;

declare type AnnotationAEPAttributes =
  | AnnotationDraftAEPAttributes
  | AnnotationResolvedAEPAttributes;

declare type AnnotationDeleteAEP = AEP<
  AnnotationActionType,
  ACTION_SUBJECT.ANNOTATION,
  ACTION_SUBJECT_ID,
  undefined,
  EVENT_TYPE.TRACK
>;

declare type AnnotationDraftAEPAttributes = {
  overlap?: number;
};

declare type AnnotationResolvedAEPAttributes = {
  method?: RESOLVE_METHOD;
};

declare type ButtonAEP<ActionSubjectID, Attributes> = UIAEP<
  ACTION.CLICKED,
  ACTION_SUBJECT.BUTTON,
  ActionSubjectID,
  Attributes
>;

declare type ComponentCrashErrorAEP = AEP<
  ACTION.CRASHED,
  ACTION_SUBJECT.RENDERER,
  ACTION_SUBJECT_ID,
  {
    platform: PLATFORM.WEB;
    errorMessage?: string;
    errorStack?: string;
    componentStack?: string;
    errorRethrown?: boolean;
  },
  EVENT_TYPE.OPERATIONAL
>;

declare type DispatchAnalyticsEvent = (event: AnalyticsEventPayload) => void;

declare enum EVENT_TYPE {
  OPERATIONAL = 'operational',
  SCREEN = 'screen',
  TRACK = 'track',
  UI = 'ui',
}

declare type ExpandAEP = AEP<
  ACTION.TOGGLE_EXPAND,
  ACTION_SUBJECT.EXPAND | ACTION_SUBJECT.NESTED_EXPAND,
  undefined,
  {
    platform: PLATFORM.WEB;
    mode: MODE.RENDERER;
    expanded: boolean;
  },
  EVENT_TYPE.TRACK
>;

declare type HeadingAnchorLinkButtonAEP = ButtonAEP<
  ACTION_SUBJECT_ID.HEADING_ANCHOR_LINK,
  undefined
>;

declare type HeadingAnchorLinksConfig = {
  activeHeadingId?: string;
  allowNestedHeaderLinks?: boolean;
};

export declare type HeadingAnchorLinksProps =
  | boolean
  | HeadingAnchorLinksConfig;

declare type InvalidProsemirrorDocumentErrorAEP = AEP<
  ACTION.INVALID_PROSEMIRROR_DOCUMENT,
  ACTION_SUBJECT.RENDERER,
  ACTION_SUBJECT_ID,
  {
    platform: PLATFORM.WEB;
    errorStack?: string;
  },
  EVENT_TYPE.OPERATIONAL
>;

declare type MediaLnkTransformedAEP = AEP<
  ACTION.MEDIA_LINK_TRANSFORMED,
  ACTION_SUBJECT.RENDERER,
  undefined,
  undefined,
  EVENT_TYPE.OPERATIONAL
>;

declare interface MediaOptions {
  allowLinking?: boolean;
  enableDownloadButton?: boolean;
  featureFlags?: MediaFeatureFlags;
  ssr?: MediaSSR;
}

export declare type MediaSSR = {
  mode: SSR;
  config: MediaClientConfig;
};

declare enum MODE {
  RENDERER = 'renderer',
  EDITOR = 'editor',
}

declare type NodeComponentsProps = {
  [key: string]: React.ComponentType<any>;
};

declare interface ParentInfo {
  parentIsIncompleteTask: boolean;
  path: Array<Node_2>;
  pos: number;
}

declare enum PLATFORM {
  NATIVE = 'mobileNative',
  HYBRID = 'mobileHybrid',
  WEB = 'web',
}

declare interface RawObjectFeatureFlags {
  ['renderer-render-tracking']: string;
}

export declare const ReactRenderer: (props: RendererProps) => jsx.JSX.Element;

export declare class ReactSerializer implements Serializer<JSX.Element> {
  private providers?;
  private eventHandlers?;
  private extensionHandlers?;
  private portal?;
  private rendererContext?;
  private appearance?;
  private disableHeadingIDs?;
  private disableActions?;
  private headingIds;
  /**
   * The reason we have this extra array here is because we need to generate the same unique
   * heading id for 2 different nodes: headers and expands (check the implementation of
   * `getUniqueHeadingId` for more info).
   *
   * We will eventually need to refactor the current approach to generate unique ids
   * for headers under this ticket -> https://product-fabric.atlassian.net/browse/ED-9668
   */
  private expandHeadingIds;
  private allowHeadingAnchorLinks?;
  private allowColumnSorting?;
  private allowCopyToClipboard?;
  private allowPlaceholderText?;
  private allowCustomPanels?;
  private fireAnalyticsEvent?;
  private shouldOpenMediaViewer?;
  private allowAltTextOnImages?;
  private stickyHeaders?;
  private allowMediaLinking?;
  private startPos;
  private surroundTextNodesWithTextWrapper;
  private media?;
  private smartLinks?;
  private allowAnnotations;
  private allowSelectAllTrap?;
  private nodeComponents?;
  private allowWindowedCodeBlock?;
  constructor(init: ReactSerializerInit);
  private resetState;
  private getNodeProps;
  serializeFragment(
    fragment: Fragment,
    props?: any,
    target?: any,
    key?: string,
    parentInfo?: ParentInfo,
  ): JSX.Element | null;
  private serializeFragmentChild;
  private withMediaMarkProps;
  private serializeTextWrapper;
  private serializeMark;
  private renderNode;
  private renderMark;
  private getTableChildrenProps;
  private getTableProps;
  private getDateProps;
  private getMediaSingleProps;
  private getMediaProps;
  private getEmbedCardProps;
  private getMediaGroupProps;
  private getMediaInlineProps;
  private getTaskItemProps;
  private getHardBreakProps;
  private getCodeBlockProps;
  private getPanelProps;
  private getUnsupportedContentProps;
  private getProps;
  private headingAnchorSupported;
  private getHeadingProps;
  private getExpandProps;
  private getHeadingId;
  private getUniqueHeadingId;
  private getAnnotationMarkProps;
  private getMarkProps;
  static getChildNodes(fragment: Fragment): (Node_2 | TextWrapper)[];
  static getMarks(node: Node_2): Mark[];
  static buildMarkStructure(content: Node_2[]): Mark<any>[];
  static fromSchema(_: unknown, init: ReactSerializerInit): ReactSerializer;
}

declare interface ReactSerializerInit {
  providers?: ProviderFactory;
  eventHandlers?: EventHandlers;
  extensionHandlers?: ExtensionHandlers;
  portal?: HTMLElement;
  objectContext?: RendererContext;
  appearance?: RendererAppearance;
  disableHeadingIDs?: boolean;
  disableActions?: boolean;
  allowHeadingAnchorLinks?: HeadingAnchorLinksProps;
  allowColumnSorting?: boolean;
  fireAnalyticsEvent?: (event: AnalyticsEventPayload) => void;
  shouldOpenMediaViewer?: boolean;
  allowAltTextOnImages?: boolean;
  stickyHeaders?: StickyHeaderConfig;
  allowMediaLinking?: boolean;
  surroundTextNodesWithTextWrapper?: boolean;
  media?: MediaOptions;
  smartLinks?: SmartLinksOptions;
  allowCopyToClipboard?: boolean;
  allowPlaceholderText?: boolean;
  allowCustomPanels?: boolean;
  allowAnnotations?: boolean;
  allowSelectAllTrap?: boolean;
  nodeComponents?: NodeComponentsProps;
  allowWindowedCodeBlock?: boolean;
}

export declare const renderDocument: <T>(
  doc: any,
  serializer: Serializer<T>,
  schema?: Schema,
  adfStage?: ADFStage,
  useSpecBasedValidator?: boolean,
  rendererId?: string,
  dispatchAnalyticsEvent?: DispatchAnalyticsEvent | undefined,
  unsupportedContentLevelsTracking?:
    | UnsupportedContentLevelsTracking
    | undefined,
  appearance?: RendererAppearance,
) => RenderOutput<T | null>;

export declare type RendererAppearance =
  | 'comment'
  | 'full-page'
  | 'full-width'
  | 'mobile'
  | undefined;

export declare interface RendererContext {
  objectAri?: string;
  containerAri?: string;
  adDoc?: any;
  schema?: Schema;
}

export declare interface RendererProps {
  document: any;
  dataProviders?: ProviderFactory;
  eventHandlers?: EventHandlers;
  extensionHandlers?: ExtensionHandlers;
  enableSsrInlineScripts?: boolean;
  onComplete?: (stat: RenderOutputStat) => void;
  onError?: (error: any) => void;
  portal?: HTMLElement;
  rendererContext?: RendererContext;
  schema?: Schema;
  appearance?: RendererAppearance;
  adfStage?: ADFStage;
  disableHeadingIDs?: boolean;
  disableActions?: boolean;
  allowHeadingAnchorLinks?: HeadingAnchorLinksProps;
  allowPlaceholderText?: boolean;
  maxHeight?: number;
  fadeOutHeight?: number;
  truncated?: boolean;
  createAnalyticsEvent?: CreateUIAnalyticsEvent;
  allowColumnSorting?: boolean;
  shouldOpenMediaViewer?: boolean;
  allowAltTextOnImages?: boolean;
  stickyHeaders?: StickyHeaderProps;
  media?: MediaOptions;
  smartLinks?: SmartLinksOptions;
  allowAnnotations?: boolean;
  annotationProvider?: AnnotationProviders | null;
  innerRef?: React.RefObject<HTMLDivElement>;
  useSpecBasedValidator?: boolean;
  allowCopyToClipboard?: boolean;
  allowCustomPanels?: boolean;
  analyticsEventSeverityTracking?: {
    enabled: boolean;
    severityNormalThreshold: number;
    severityDegradedThreshold: number;
  };
  allowUgcScrubber?: boolean;
  allowSelectAllTrap?: boolean;
  unsupportedContentLevelsTracking?: UnsupportedContentLevelsTracking;
  nodeComponents?: NodeComponentsProps;
  /**
   * @default undefined
   * @description
   * Short lived feature flags for experiments and gradual rollouts
   * Flags are expected to follow these rules or they are filtered out
   *
   * 1. cased in kebab-case (match [a-z-])
   * 2. have boolean values or object {} values
   *
   * @example
   * ```tsx
   * (<Renderer featureFlags={{ 'my-feature': true }} />);
   * getFeatureFlags()?.myFeature === true;
   * ```
   *
   * @example
   * ```tsx
   * (<Renderer featureFlags={{ 'my-feature': 'thing' }} />);
   * getFeatureFlags()?.myFeature === undefined;
   * ```
   *
   * @example
   * ```tsx
   * (<Renderer featureFlags={{ 'product.my-feature': false }} />);
   * getFeatureFlags()?.myFeature === undefined;
   * getFeatureFlags()?.productMyFeature === undefined;
   * ```
   */
  featureFlags?:
    | {
        [featureFlag: string]: boolean;
      }
    | Partial<RawObjectFeatureFlags>;
}

declare type RendererRenderedAEP = AEP<
  ACTION.RENDERED,
  ACTION_SUBJECT.RENDERER,
  undefined,
  {
    platform: PLATFORM.WEB;
    duration: number;
    ttfb?: number;
    nodes: Record<string, number>;
    severity?: SEVERITY;
  },
  EVENT_TYPE.OPERATIONAL
>;

declare type RendererReRenderedAEP<Props> = AEP<
  ACTION.RE_RENDERED,
  ACTION_SUBJECT.RENDERER,
  undefined,
  {
    propsDifference: PropsDifference<Props> | ShallowPropsDifference<Props>;
    count: number;
    componentId?: string;
  },
  EVENT_TYPE.OPERATIONAL
>;

declare type RendererSelectAllCaughtAEP = AEP<
  ACTION.SELECT_ALL_CAUGHT,
  ACTION_SUBJECT.RENDERER,
  undefined,
  {
    platform: PLATFORM.WEB;
  },
  EVENT_TYPE.TRACK
>;

declare type RendererSelectAllEscapedAEP = AEP<
  ACTION.SELECT_ALL_ESCAPED,
  ACTION_SUBJECT.RENDERER,
  undefined,
  {
    platform: PLATFORM.WEB;
  },
  EVENT_TYPE.TRACK
>;

declare type RendererStartAEP = AEP<
  ACTION.STARTED,
  ACTION_SUBJECT.RENDERER,
  undefined,
  {
    platform: PLATFORM.WEB;
  },
  EVENT_TYPE.UI
>;

declare type RendererTTIAEP = AEP<
  ACTION.RENDERER_TTI,
  ACTION_SUBJECT.RENDERER,
  undefined,
  {
    tti: number;
    ttiFromInvocation: number;
    canceled: boolean;
  },
  EVENT_TYPE.OPERATIONAL
>;

declare type RendererUnsupportedContentLevelsTrackingErrored = AEP<
  ACTION.UNSUPPORTED_CONTENT_LEVELS_TRACKING_ERRORED,
  ACTION_SUBJECT.RENDERER,
  undefined,
  {
    platform: PLATFORM.WEB;
    error: string;
  },
  EVENT_TYPE.OPERATIONAL
>;

declare type RendererUnsupportedContentLevelsTrackingSucceeded = AEP<
  ACTION.UNSUPPORTED_CONTENT_LEVELS_TRACKING_SUCCEEDED,
  ACTION_SUBJECT.RENDERER,
  undefined,
  {
    appearance?: string;
    platform: PLATFORM.WEB;
    unsupportedContentLevelSeverity: UNSUPPORTED_CONTENT_LEVEL_SEVERITY;
    unsupportedContentLevelPercentage: number;
    unsupportedNodesCount: number;
    supportedNodesCount: number;
  },
  EVENT_TYPE.OPERATIONAL
>;

declare interface RenderOutput<T> {
  result: T;
  stat: RenderOutputStat;
  pmDoc?: Node_2;
}

export declare interface RenderOutputStat {
  buildTreeTime?: number;
  sanitizeTime: number;
  serializeTime?: number;
}

declare enum RESOLVE_METHOD {
  COMPONENT = 'component',
  CONSUMER = 'consumer',
  ORPHANED = 'orphaned',
}

export declare interface Serializer<T> {
  serializeFragment(
    fragment: Fragment,
    props?: any,
    target?: any,
    key?: string,
  ): T | null;
}

declare interface SmartLinksOptions {
  ssr?: boolean;
}

declare type StickyHeaderConfig = {
  offsetTop?: number;
};

declare type StickyHeaderProps =
  | boolean
  | ({
      show?: boolean;
    } & StickyHeaderConfig);

declare type TableSortColumnAEP = AEP<
  ACTION.SORT_COLUMN,
  ACTION_SUBJECT.TABLE,
  undefined,
  {
    platform: PLATFORM.WEB;
    mode: MODE.RENDERER;
    sortOrder: SortOrder;
    columnIndex: number;
  },
  EVENT_TYPE.TRACK
>;

declare type TableSortColumnNotAllowedAEP = AEP<
  ACTION.SORT_COLUMN_NOT_ALLOWED,
  ACTION_SUBJECT.TABLE,
  undefined,
  {
    platform: PLATFORM.WEB;
    mode: MODE.RENDERER;
  },
  EVENT_TYPE.TRACK
>;

export declare class TextSerializer implements Serializer<string> {
  private schema;
  constructor(schema: Schema);
  serializeFragment(fragment: Fragment): string;
  static fromSchema(schema?: Schema): TextSerializer;
}

declare interface TextWrapper {
  type: {
    name: 'textWrapper';
  };
  content: Node_2[];
  nodeSize: number;
}

declare type TransformerProvider<T> = (schema: Schema) => Transformer_2<T>;

declare type UIAEP<Action, ActionSubject, ActionSubjectID, Attributes> = AEP<
  Action,
  ActionSubject,
  ActionSubjectID,
  Attributes,
  EVENT_TYPE.UI
>;

declare type VisitLinkAEP = AEP<
  ACTION.VISITED,
  ACTION_SUBJECT.LINK,
  undefined,
  {
    platform: PLATFORM.WEB;
    mode: MODE.RENDERER;
  },
  EVENT_TYPE.TRACK
>;

declare type VisitMediaLinkAEP = AEP<
  ACTION.VISITED,
  ACTION_SUBJECT.MEDIA,
  ACTION_SUBJECT_ID.LINK,
  {
    platform: PLATFORM.WEB;
    mode: MODE.RENDERER;
  },
  EVENT_TYPE.TRACK
>;

export {};
````
