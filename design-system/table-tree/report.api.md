## API Report File for "@atlaskit/table-tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="react" />

import { Component } from 'react';
import { Context } from 'react';
import { ErrorInfo } from 'react';
import PropTypes from 'prop-types';
import { default as React_2 } from 'react';
import { ReactInstance } from 'react';
import { ReactNode } from 'react';
import { Validator } from 'prop-types';
import { WithAnalyticsEventsProps } from '@atlaskit/analytics-next';
import { WithContextProps } from '@atlaskit/analytics-next';

export declare const Cell: {
  new (props: Readonly<CellProps & CellWithColumnWidthProps>): {
    UNSAFE_componentWillMount(): void;
    setColumnWidth(width?: string | number | undefined): void;
    UNSAFE_componentWillReceiveProps(nextProps: CellWithColumnWidthProps): void;
    render(): JSX.Element;
    context: any;
    setState<K extends never>(
      state:
        | {}
        | ((
            prevState: Readonly<{}>,
            props: Readonly<CellProps & CellWithColumnWidthProps>,
          ) => {} | Pick<{}, K> | null)
        | Pick<{}, K>
        | null,
      callback?: (() => void) | undefined,
    ): void;
    forceUpdate(callBack?: (() => void) | undefined): void;
    readonly props: Readonly<CellProps & CellWithColumnWidthProps> &
      Readonly<{
        children?: React_2.ReactNode;
      }>;
    state: Readonly<{}>;
    refs: {
      [key: string]: React_2.ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: React_2.ErrorInfo): void;
    getSnapshotBeforeUpdate?(
      prevProps: Readonly<CellProps & CellWithColumnWidthProps>,
      prevState: Readonly<{}>,
    ): any;
    componentDidUpdate?(
      prevProps: Readonly<CellProps & CellWithColumnWidthProps>,
      prevState: Readonly<{}>,
      snapshot?: any,
    ): void;
    componentWillMount?(): void;
    componentWillReceiveProps?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextContext: any,
    ): void;
    componentWillUpdate?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
    UNSAFE_componentWillUpdate?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
  };
  new (props: CellProps & CellWithColumnWidthProps, context?: any): {
    UNSAFE_componentWillMount(): void;
    setColumnWidth(width?: string | number | undefined): void;
    UNSAFE_componentWillReceiveProps(nextProps: CellWithColumnWidthProps): void;
    render(): JSX.Element;
    context: any;
    setState<K extends never>(
      state:
        | {}
        | ((
            prevState: Readonly<{}>,
            props: Readonly<CellProps & CellWithColumnWidthProps>,
          ) => {} | Pick<{}, K> | null)
        | Pick<{}, K>
        | null,
      callback?: (() => void) | undefined,
    ): void;
    forceUpdate(callBack?: (() => void) | undefined): void;
    readonly props: Readonly<CellProps & CellWithColumnWidthProps> &
      Readonly<{
        children?: React_2.ReactNode;
      }>;
    state: Readonly<{}>;
    refs: {
      [key: string]: React_2.ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: React_2.ErrorInfo): void;
    getSnapshotBeforeUpdate?(
      prevProps: Readonly<CellProps & CellWithColumnWidthProps>,
      prevState: Readonly<{}>,
    ): any;
    componentDidUpdate?(
      prevProps: Readonly<CellProps & CellWithColumnWidthProps>,
      prevState: Readonly<{}>,
      snapshot?: any,
    ): void;
    componentWillMount?(): void;
    componentWillReceiveProps?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextContext: any,
    ): void;
    componentWillUpdate?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
    UNSAFE_componentWillUpdate?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
  };
  contextTypes: {
    tableTree: Validator<object>;
  };
  contextType?: React_2.Context<any> | undefined;
};

export declare interface CellProps {
  /**
   * Whether the cell contents should wrap or display on a single line and be concatenated.
   */
  singleLine?: boolean;
  /**
   * Indent level for the cell. Each indent level adds 25px to the left padding.
   */
  indentLevel?: number;
  /**
   * Width of the header item. Takes a string or a number representing the width in pixels.
   */
  width?: number | string;
  /**
   * Class name to apply to cell.
   */
  className?: string;
}

export declare interface CellWithColumnWidthProps {
  width?: number | string;
  columnIndex?: number;
}

export declare const Header: {
  new (props: Readonly<any>): {
    UNSAFE_componentWillMount(): void;
    setColumnWidth(width?: string | number | undefined): void;
    UNSAFE_componentWillReceiveProps(nextProps: CellWithColumnWidthProps): void;
    render(): JSX.Element;
    context: any;
    setState<K extends never>(
      state:
        | {}
        | ((
            prevState: Readonly<{}>,
            props: Readonly<any>,
          ) => {} | Pick<{}, K> | null)
        | Pick<{}, K>
        | null,
      callback?: (() => void) | undefined,
    ): void;
    forceUpdate(callBack?: (() => void) | undefined): void;
    readonly props: Readonly<any> &
      Readonly<{
        children?: ReactNode;
      }>;
    state: Readonly<{}>;
    refs: {
      [key: string]: ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(
      nextProps: Readonly<any>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;
    getSnapshotBeforeUpdate?(
      prevProps: Readonly<any>,
      prevState: Readonly<{}>,
    ): any;
    componentDidUpdate?(
      prevProps: Readonly<any>,
      prevState: Readonly<{}>,
      snapshot?: any,
    ): void;
    componentWillMount?(): void;
    componentWillReceiveProps?(
      nextProps: Readonly<any>,
      nextContext: any,
    ): void;
    componentWillUpdate?(
      nextProps: Readonly<any>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
    UNSAFE_componentWillUpdate?(
      nextProps: Readonly<any>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
  };
  new (props: any, context?: any): {
    UNSAFE_componentWillMount(): void;
    setColumnWidth(width?: string | number | undefined): void;
    UNSAFE_componentWillReceiveProps(nextProps: CellWithColumnWidthProps): void;
    render(): JSX.Element;
    context: any;
    setState<K extends never>(
      state:
        | {}
        | ((
            prevState: Readonly<{}>,
            props: Readonly<any>,
          ) => {} | Pick<{}, K> | null)
        | Pick<{}, K>
        | null,
      callback?: (() => void) | undefined,
    ): void;
    forceUpdate(callBack?: (() => void) | undefined): void;
    readonly props: Readonly<any> &
      Readonly<{
        children?: ReactNode;
      }>;
    state: Readonly<{}>;
    refs: {
      [key: string]: ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(
      nextProps: Readonly<any>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;
    getSnapshotBeforeUpdate?(
      prevProps: Readonly<any>,
      prevState: Readonly<{}>,
    ): any;
    componentDidUpdate?(
      prevProps: Readonly<any>,
      prevState: Readonly<{}>,
      snapshot?: any,
    ): void;
    componentWillMount?(): void;
    componentWillReceiveProps?(
      nextProps: Readonly<any>,
      nextContext: any,
    ): void;
    componentWillUpdate?(
      nextProps: Readonly<any>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
    UNSAFE_componentWillUpdate?(
      nextProps: Readonly<any>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
  };
  contextTypes: {
    tableTree: Validator<object>;
  };
  contextType?: Context<any> | undefined;
};

declare class Headers_2 extends Component<any> {
  render(): JSX.Element;
}
export { Headers_2 as Headers };

export declare const Row: React_2.ForwardRefExoticComponent<
  Pick<
    Pick<Omit<any, keyof WithAnalyticsEventsProps>, string | number | symbol> &
      React_2.RefAttributes<any> &
      WithContextProps,
    string | number | symbol
  > &
    React_2.RefAttributes<any>
>;

export declare class Rows<T> extends Component<RowsProps<T>> {
  render(): JSX.Element;
}

export declare interface RowsProps<T> {
  items?: WithChildren<T>[];
  render: (args: WithChildren<T>) => React_2.ReactNode;
}

declare interface State {
  columnWidths: number[];
}

declare class TableTree extends Component<any, State> {
  static childContextTypes: {
    tableTree: PropTypes.Validator<object>;
  };
  state: State;
  componentDidMount(): void;
  setColumnWidth: (columnIndex: number, width: number) => void;
  getColumnWidth: (columnIndex: any) => number | null;
  getChildContext(): {
    tableTree: {
      columnWidths: number[];
      setColumnWidth: (columnIndex: number, width: number) => void;
      getColumnWidth: (columnIndex: any) => number | null;
    };
  };
  render(): JSX.Element;
}
export default TableTree;

/**
 * This helper class will create a cache of all the id's in the items object and
 * path to the object.
 * Example:
 * [{
 *   // item 1,
 *   id: 1,
 *   children:[{
 *     // item 1.1,
 *     id: '2'
 *   }]
 * }]
 *
 * Cache will look something like:
 * {1: 0, 2: '0.children[0]'}
 */
export declare class TableTreeDataHelper<T extends any = any> {
  key: keyof T;
  keysCache: any;
  constructor({ key }?: { key?: keyof T | undefined });
  updateItems(items: T[], allItems?: T[], parentItem?: T | null): T[];
  appendItems(items: T[], allItems?: T[], parentItem?: T | null): T[];
}

declare type WithChildren<T> = T & {
  children?: T[] | null;
};

export {};
```
