## API Report File for "@atlaskit/select".

> Do not edit this file. This report is auto-generated by [API Extractor](https://api-extractor.com/).

[Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

```ts
/// <reference types="react" />

import { ActionMeta as ActionMeta_2 } from 'react-select';
import { components } from 'react-select';
import { Context } from 'react';
import { ControlProps as ControlProps_2 } from 'react-select';
import { createFilter } from 'react-select';
import { default as default_2 } from 'react-select/src/Select';
import { default as default_3 } from 'react-select';
import { ErrorInfo } from 'react';
import { FC } from 'react';
import { FormatOptionLabelMeta as FormatOptionLabelMeta_2 } from 'react-select';
import { GroupedOptionsType } from 'react-select';
import { GroupTypeBase as GroupType } from 'react-select';
import { IndicatorComponentType as IndicatorComponentType_2 } from 'react-select';
import { IndicatorProps as IndicatorProps_2 } from 'react-select';
import { InputActionMeta as InputActionMeta_2 } from 'react-select';
import { InputProps } from 'react-select';
import { jsx } from '@emotion/react';
import { makeAsyncSelect } from 'react-select/async';
import { makeCreatableSelect } from 'react-select/creatable';
import { MenuListComponentProps as MenuListComponentProps_2 } from 'react-select';
import { MenuProps as MenuProps_2 } from 'react-select';
import { mergeStyles } from 'react-select';
import { OptionProps as OptionProps_2 } from 'react-select';
import { OptionsType as OptionsType_2 } from 'react-select';
import { PopperProps } from 'react-popper';
import { Props } from 'react-select';
import { PureComponent } from 'react';
import { default as React_2 } from 'react';
import { ReactInstance } from 'react';
import { ReactNode } from 'react';
import Select from 'react-select';
import { SelectComponents } from 'react-select/src/components';
import { SelectComponentsConfig as SelectComponentsConfig_2 } from 'react-select';
import { StylesConfig as StylesConfig_2 } from 'react-select';
import { UnbindFn } from 'bind-event-listener';
import { ValueContainerProps as ValueContainerProps_2 } from 'react-select';
import { ValueType as ValueType_2 } from 'react-select';
import { WithAnalyticsEventsProps } from '@atlaskit/analytics-next';

export declare type ActionMeta<Option = OptionType> = ActionMeta_2<Option>;

export declare const AsyncCreatableSelect: {
  new <Option = OptionType, IsMulti extends boolean = false>(
    props: SelectProps<Option, IsMulti>,
  ): {
    components: Partial<SelectComponents<Option, IsMulti, GroupType<Option>>>;
    select: default_3<
      Option,
      false,
      GroupType<Option>,
      default_2<Option, false, GroupType<Option>>
    > | null;
    UNSAFE_componentWillReceiveProps(
      nextProps: SelectProps<Option, IsMulti>,
    ): void;
    cacheComponents: (
      components: Partial<SelectComponents<Option, IsMulti, GroupType<Option>>>,
    ) => void;
    focus(): void;
    blur(): void;
    onSelectRef: (
      ref: default_3<
        Option,
        false,
        GroupType<Option>,
        default_2<Option, false, GroupType<Option>>
      >,
    ) => void;
    render(): JSX.Element;
    context: any;
    setState<K extends never>(
      state:
        | {}
        | ((
            prevState: Readonly<{}>,
            props: Readonly<SelectProps<Option, IsMulti>>,
          ) => {} | Pick<{}, K> | null)
        | Pick<{}, K>
        | null,
      callback?: (() => void) | undefined,
    ): void;
    forceUpdate(callBack?: (() => void) | undefined): void;
    readonly props: Readonly<SelectProps<Option, IsMulti>> &
      Readonly<{
        children?: ReactNode;
      }>;
    state: Readonly<{}>;
    refs: {
      [key: string]: ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;
    getSnapshotBeforeUpdate?(
      prevProps: Readonly<SelectProps<Option, IsMulti>>,
      prevState: Readonly<{}>,
    ): any;
    componentDidUpdate?(
      prevProps: Readonly<SelectProps<Option, IsMulti>>,
      prevState: Readonly<{}>,
      snapshot?: any,
    ): void;
    componentWillMount?(): void;
    UNSAFE_componentWillMount?(): void;
    componentWillReceiveProps?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextContext: any,
    ): void;
    componentWillUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
    UNSAFE_componentWillUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
  };
  defaultProps: {
    validationState: string;
    isInvalid: boolean;
    spacing: string;
    onClickPreventDefault: boolean;
    tabSelectsValue: boolean;
    components: {};
    styles: {};
  };
  contextType?: Context<any> | undefined;
};

export declare const AsyncSelect: {
  new <Option = OptionType, IsMulti extends boolean = false>(
    props: SelectProps<Option, IsMulti>,
  ): {
    components: Partial<SelectComponents<Option, IsMulti, GroupType<Option>>>;
    select: default_3<
      Option,
      false,
      GroupType<Option>,
      default_2<Option, false, GroupType<Option>>
    > | null;
    UNSAFE_componentWillReceiveProps(
      nextProps: SelectProps<Option, IsMulti>,
    ): void;
    cacheComponents: (
      components: Partial<SelectComponents<Option, IsMulti, GroupType<Option>>>,
    ) => void;
    focus(): void;
    blur(): void;
    onSelectRef: (
      ref: default_3<
        Option,
        false,
        GroupType<Option>,
        default_2<Option, false, GroupType<Option>>
      >,
    ) => void;
    render(): JSX.Element;
    context: any;
    setState<K extends never>(
      state:
        | {}
        | ((
            prevState: Readonly<{}>,
            props: Readonly<SelectProps<Option, IsMulti>>,
          ) => {} | Pick<{}, K> | null)
        | Pick<{}, K>
        | null,
      callback?: (() => void) | undefined,
    ): void;
    forceUpdate(callBack?: (() => void) | undefined): void;
    readonly props: Readonly<SelectProps<Option, IsMulti>> &
      Readonly<{
        children?: ReactNode;
      }>;
    state: Readonly<{}>;
    refs: {
      [key: string]: ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;
    getSnapshotBeforeUpdate?(
      prevProps: Readonly<SelectProps<Option, IsMulti>>,
      prevState: Readonly<{}>,
    ): any;
    componentDidUpdate?(
      prevProps: Readonly<SelectProps<Option, IsMulti>>,
      prevState: Readonly<{}>,
      snapshot?: any,
    ): void;
    componentWillMount?(): void;
    UNSAFE_componentWillMount?(): void;
    componentWillReceiveProps?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextContext: any,
    ): void;
    componentWillUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
    UNSAFE_componentWillUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
  };
  defaultProps: {
    validationState: string;
    isInvalid: boolean;
    spacing: string;
    onClickPreventDefault: boolean;
    tabSelectsValue: boolean;
    components: {};
    styles: {};
  };
  contextType?: Context<any> | undefined;
};

export declare const CheckboxOption: FC<OptionProps<OptionType, true>>;

export declare const CheckboxSelect: ({
  components,
  ...props
}: SelectProps<OptionType, true>) => JSX.Element;

export { components };

export declare type ControlProps<
  OptionType,
  IsMulti extends boolean = false
> = ControlProps_2<OptionType, IsMulti>;

declare type Country = typeof groupedCountries[number]['options'][number];

declare interface Country_2 {
  abbr: string;
  code: string;
  icon: string;
  name: string;
  suggested?: boolean;
}

export declare const CountrySelect: (
  props: SelectProps<Country>,
) => jsx.JSX.Element;

export declare const CreatableSelect: {
  new <Option = OptionType, IsMulti extends boolean = false>(
    props: SelectProps<Option, IsMulti>,
  ): {
    components: Partial<SelectComponents<Option, IsMulti, GroupType<Option>>>;
    select: default_3<
      Option,
      false,
      GroupType<Option>,
      default_2<Option, false, GroupType<Option>>
    > | null;
    UNSAFE_componentWillReceiveProps(
      nextProps: SelectProps<Option, IsMulti>,
    ): void;
    cacheComponents: (
      components: Partial<SelectComponents<Option, IsMulti, GroupType<Option>>>,
    ) => void;
    focus(): void;
    blur(): void;
    onSelectRef: (
      ref: default_3<
        Option,
        false,
        GroupType<Option>,
        default_2<Option, false, GroupType<Option>>
      >,
    ) => void;
    render(): JSX.Element;
    context: any;
    setState<K extends never>(
      state:
        | {}
        | ((
            prevState: Readonly<{}>,
            props: Readonly<SelectProps<Option, IsMulti>>,
          ) => {} | Pick<{}, K> | null)
        | Pick<{}, K>
        | null,
      callback?: (() => void) | undefined,
    ): void;
    forceUpdate(callBack?: (() => void) | undefined): void;
    readonly props: Readonly<SelectProps<Option, IsMulti>> &
      Readonly<{
        children?: ReactNode;
      }>;
    state: Readonly<{}>;
    refs: {
      [key: string]: ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;
    getSnapshotBeforeUpdate?(
      prevProps: Readonly<SelectProps<Option, IsMulti>>,
      prevState: Readonly<{}>,
    ): any;
    componentDidUpdate?(
      prevProps: Readonly<SelectProps<Option, IsMulti>>,
      prevState: Readonly<{}>,
      snapshot?: any,
    ): void;
    componentWillMount?(): void;
    UNSAFE_componentWillMount?(): void;
    componentWillReceiveProps?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextContext: any,
    ): void;
    componentWillUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
    UNSAFE_componentWillUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
  };
  defaultProps: {
    validationState: string;
    isInvalid: boolean;
    spacing: string;
    onClickPreventDefault: boolean;
    tabSelectsValue: boolean;
    components: {};
    styles: {};
  };
  contextType?: Context<any> | undefined;
};

export { createFilter };

declare const _default: {
  new <Option = OptionType, IsMulti extends boolean = false>(
    props: SelectProps<Option, IsMulti>,
  ): {
    components: Partial<SelectComponents<Option, IsMulti, GroupType<Option>>>;
    select: Select<
      Option,
      false,
      GroupType<Option>,
      default_2<Option, false, GroupType<Option>>
    > | null;
    UNSAFE_componentWillReceiveProps(
      nextProps: SelectProps<Option, IsMulti>,
    ): void;
    cacheComponents: (
      components: Partial<SelectComponents<Option, IsMulti, GroupType<Option>>>,
    ) => void;
    focus(): void;
    blur(): void;
    onSelectRef: (
      ref: Select<
        Option,
        false,
        GroupType<Option>,
        default_2<Option, false, GroupType<Option>>
      >,
    ) => void;
    render(): JSX.Element;
    context: any;
    setState<K extends never>(
      state:
        | {}
        | ((
            prevState: Readonly<{}>,
            props: Readonly<SelectProps<Option, IsMulti>>,
          ) => {} | Pick<{}, K> | null)
        | Pick<{}, K>
        | null,
      callback?: (() => void) | undefined,
    ): void;
    forceUpdate(callBack?: (() => void) | undefined): void;
    readonly props: Readonly<SelectProps<Option, IsMulti>> &
      Readonly<{
        children?: ReactNode;
      }>;
    state: Readonly<{}>;
    refs: {
      [key: string]: ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;
    getSnapshotBeforeUpdate?(
      prevProps: Readonly<SelectProps<Option, IsMulti>>,
      prevState: Readonly<{}>,
    ): any;
    componentDidUpdate?(
      prevProps: Readonly<SelectProps<Option, IsMulti>>,
      prevState: Readonly<{}>,
      snapshot?: any,
    ): void;
    componentWillMount?(): void;
    UNSAFE_componentWillMount?(): void;
    componentWillReceiveProps?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextContext: any,
    ): void;
    componentWillUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
    UNSAFE_componentWillUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
  };
  defaultProps: {
    validationState: string;
    isInvalid: boolean;
    spacing: string;
    onClickPreventDefault: boolean;
    tabSelectsValue: boolean;
    components: {};
    styles: {};
  };
  contextType?: Context<any> | undefined;
};
export default _default;

declare type defaultModifiers = 'offset' | 'preventOverflow';

export declare type FormatOptionLabelMeta<
  OptionType,
  IsMulti extends boolean = false
> = FormatOptionLabelMeta_2<OptionType, IsMulti>;

declare const groupedCountries: readonly [
  {
    readonly label: 'Suggested';
    readonly options: Country_2[];
  },
  {
    readonly label: 'All Countries';
    readonly options: Country_2[];
  },
];

export { GroupedOptionsType };

export { GroupType };

export declare type IndicatorComponentType<
  OptionType,
  IsMulti extends boolean = false
> = IndicatorComponentType_2<OptionType, IsMulti>;

export declare type IndicatorProps<
  OptionType,
  IsMulti extends boolean = false
> = IndicatorProps_2<OptionType, IsMulti>;

export declare type InputActionMeta = InputActionMeta_2;

export { InputProps };

export { makeAsyncSelect };

export { makeCreatableSelect };

export declare type MenuListComponentProps<
  OptionType,
  IsMulti extends boolean = false
> = MenuListComponentProps_2<OptionType, IsMulti>;

export declare type MenuProps<
  OptionType,
  IsMulti extends boolean = false
> = MenuProps_2<OptionType, IsMulti>;

export { mergeStyles };

declare type ModifierList =
  | 'offset'
  | 'computeStyles'
  | 'preventOverflow'
  | 'handleFlipStyle'
  | 'flip'
  | 'popperOffsets'
  | 'arrow'
  | 'hide'
  | string;

export declare interface OptionProps<
  Option = OptionType,
  IsMulti extends boolean = false
> extends OptionProps_2<Option, IsMulti> {
  [key: string]: any;
  Icon?: React.ComponentType<{
    label: string;
    size?: 'small' | 'medium' | 'large' | 'xlarge';
    onClick?: (e: MouseEvent) => void;
    primaryColor?: string;
    secondaryColor?: string;
  }>;
  isDisabled: boolean;
  isFocused: boolean;
  isSelected: boolean;
}

export declare type OptionsType<Option = OptionType> = OptionsType_2<Option>;

export declare interface OptionType {
  [key: string]: any;
  label: string;
  value: string | number;
}

declare type PopperPropsNoChildren<Modifiers> = Omit<
  PopperProps<Modifiers>,
  'children'
>;

export declare class PopupSelect<
  Option = OptionType,
  IsMulti extends boolean = false
> extends PureComponent<PopupSelectProps<Option, IsMulti>, State> {
  menuRef: HTMLElement | null;
  selectRef: Select<Option, IsMulti> | null;
  targetRef: HTMLElement | null;
  unbindWindowClick: UnbindFn | null;
  unbindWindowKeydown: UnbindFn | null;
  defaultStyles: StylesConfig<Option, IsMulti>;
  isOpenControlled: boolean;
  defaultOpenState: boolean | undefined;
  state: {
    isOpen: boolean;
    mergedComponents: {
      Control: React_2.FC<ControlProps<OptionType, boolean>>;
      DropdownIndicator: () => jsx;
      Menu: ({
        children,
        innerProps,
        ...props
      }: MenuProps<OptionType, boolean>) => jsx;
    };
    mergedPopperProps: PopperPropsNoChildren<string>;
  };
  popperWrapperId: string;
  static defaultProps: {
    closeMenuOnSelect: boolean;
    components: {};
    maxMenuHeight: number;
    maxMenuWidth: number;
    minMenuWidth: number;
    popperProps: {};
    isSearchable: boolean;
    searchThreshold: number;
    styles: {};
    options: never[];
  };
  static getDerivedStateFromProps(
    props: PopupSelectProps<OptionType>,
    state: State,
  ): Partial<State<string>> | null;
  componentDidMount(): void;
  componentWillUnmount(): void;
  componentDidUpdate(prevProps: PopupSelectProps<Option, IsMulti>): void;
  handleKeyDown: (event: KeyboardEvent) => void;
  handleClick: ({ target }: MouseEvent) => void;
  handleSelectChange: (
    value: ValueType<Option, IsMulti>,
    actionMeta: ActionMeta<Option>,
  ) => void;
  /**
   * Opens the popup
   *
   * @param options.controlOverride  - Force the popup to open when it's open state is being controlled
   */
  open: (
    options?:
      | {
          controlOverride?: boolean | undefined;
        }
      | undefined,
  ) => void;
  /**
   * Closes the popup
   *
   * @param options.controlOverride  - Force the popup to close when it's open state is being controlled
   */
  close: (
    options?:
      | {
          controlOverride?: boolean | undefined;
        }
      | undefined,
  ) => void;
  resolveTargetRef: (
    popperRef: React_2.Ref<HTMLElement>,
  ) => (ref: HTMLElement) => void;
  resolveMenuRef: (
    popperRef: React_2.Ref<HTMLElement>,
  ) => (ref: HTMLElement) => void;
  getSelectRef: (ref: Select<Option, IsMulti>) => void;
  getItemCount: () => number;
  getMaxHeight: () => number | undefined;
  showSearchControl: () => boolean | undefined;
  renderSelect: () => JSX.Element | null;
  render(): JSX.Element;
}

export declare interface PopupSelectProps<
  Option = OptionType,
  IsMulti extends boolean = false,
  Modifiers = ModifierList
> extends Props<Option, IsMulti> {
  /**
   * Defines whether the menu should close when selected. Defaults to "true"
   */
  closeMenuOnSelect?: boolean;
  /**
   * The footer content shown at the bottom of the Popup, underneath the Select options
   */
  footer?: ReactNode;
  /**
     The props passed down to React Popper.

     Use these to override the default positioning strategy, behaviour and placement used by this library.
     For more information, see the [React Popper documentation](https://popper.js.org/react-popper/v2/render-props).

     */
  popperProps?: PopperPropsNoChildren<Modifiers>;
  /**
   * The maximum number of options the select can contain without rendering the search field. Defaults to 5.
   */
  searchThreshold?: number;
  /**
   * If false, renders a select with no search field. If true, renders a search field in the select when the
   * number of options exceeds the `searchThreshold`. Defaults to true.
   */
  isSearchable?: boolean;
  /**
   * The maximum width for the popup menu. Can be a number, representing width in pixels,
   * or a string containing a CSS length datatype.
   */
  maxMenuWidth?: number | string;
  /**
   * The maximum width for the popup menu. Can be a number, representing width in pixels,
   * or a string containing a CSS length datatype.
   */
  minMenuWidth?: number | string;
  /**
     Render props used to anchor the popup to your content.

     Make this an interactive element, such as an @atlaskit/button component.

     The provided render props in `options` are detailed below:
     - `isOpen`: The current state of the popup.
     Use this to change the appearance of your target based on the state of your component
     - `ref`: Pass this ref to the element the Popup should be attached to
     - `aria-haspopup`, `aria-expanded`, `aria-controls`: Spread these onto a target element to
     ensure your experience is accessible
     */
  target?: (
    options: PopupSelectTriggerProps & {
      isOpen: boolean;
    },
  ) => ReactNode;
  isOpen?: boolean;
  defaultIsOpen?: boolean;
  spacing?: string;
  validationState?: ValidationState;
  isInvalid?: boolean;
}

declare interface PopupSelectTriggerProps {
  ref: any;
  'aria-haspopup': 'true';
  'aria-expanded': boolean;
  'aria-controls'?: string;
}

export declare const RadioOption: FC<OptionProps>;

export declare const RadioSelect: ({
  components,
  ...props
}: SelectProps<OptionType>) => JSX.Element;

export declare type SelectComponentsConfig<
  OptionType,
  IsMulti extends boolean = false
> = SelectComponentsConfig_2<OptionType, IsMulti>;

export declare interface SelectProps<
  OptionType,
  IsMulti extends boolean = false
> extends Props<OptionType, IsMulti>,
    WithAnalyticsEventsProps {
  spacing?: 'compact' | 'default';
  validationState?: ValidationState;
  appearance?: 'default' | 'subtle' | 'none';
  isInvalid?: boolean;
}

export declare const SelectWithoutAnalytics: {
  new <Option = OptionType, IsMulti extends boolean = false>(
    props: SelectProps<Option, IsMulti>,
  ): {
    components: Partial<SelectComponents<Option, IsMulti, GroupType<Option>>>;
    select: Select<
      Option,
      false,
      GroupType<Option>,
      default_2<Option, false, GroupType<Option>>
    > | null;
    UNSAFE_componentWillReceiveProps(
      nextProps: SelectProps<Option, IsMulti>,
    ): void;
    cacheComponents: (
      components: Partial<SelectComponents<Option, IsMulti, GroupType<Option>>>,
    ) => void;
    focus(): void;
    blur(): void;
    onSelectRef: (
      ref: Select<
        Option,
        false,
        GroupType<Option>,
        default_2<Option, false, GroupType<Option>>
      >,
    ) => void;
    render(): JSX.Element;
    context: any;
    setState<K extends never>(
      state:
        | {}
        | ((
            prevState: Readonly<{}>,
            props: Readonly<SelectProps<Option, IsMulti>>,
          ) => {} | Pick<{}, K> | null)
        | Pick<{}, K>
        | null,
      callback?: (() => void) | undefined,
    ): void;
    forceUpdate(callBack?: (() => void) | undefined): void;
    readonly props: Readonly<SelectProps<Option, IsMulti>> &
      Readonly<{
        children?: ReactNode;
      }>;
    state: Readonly<{}>;
    refs: {
      [key: string]: ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;
    getSnapshotBeforeUpdate?(
      prevProps: Readonly<SelectProps<Option, IsMulti>>,
      prevState: Readonly<{}>,
    ): any;
    componentDidUpdate?(
      prevProps: Readonly<SelectProps<Option, IsMulti>>,
      prevState: Readonly<{}>,
      snapshot?: any,
    ): void;
    componentWillMount?(): void;
    UNSAFE_componentWillMount?(): void;
    componentWillReceiveProps?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextContext: any,
    ): void;
    componentWillUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
    UNSAFE_componentWillUpdate?(
      nextProps: Readonly<SelectProps<Option, IsMulti>>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
  };
  defaultProps: {
    validationState: string;
    isInvalid: boolean;
    spacing: string;
    onClickPreventDefault: boolean;
    tabSelectsValue: boolean;
    components: {};
    styles: {};
  };
  contextType?: Context<any> | undefined;
};

declare interface State<Modifiers = string> {
  isOpen: boolean;
  mergedComponents: Object;
  mergedPopperProps: PopperPropsNoChildren<defaultModifiers | Modifiers>;
}

export declare type StylesConfig<
  Option = OptionType,
  IsMulti extends boolean = false
> = StylesConfig_2<Option, IsMulti>;

declare type ValidationState = 'default' | 'error' | 'success';

export declare type ValueContainerProps<
  OptionType,
  IsMulti extends boolean = false
> = ValueContainerProps_2<OptionType, IsMulti>;

export declare type ValueType<
  OptionType,
  IsMulti extends boolean = false
> = ValueType_2<OptionType, IsMulti>;

export {};
```
