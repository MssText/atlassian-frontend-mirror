import { main as generateTypes } from './generate-types';
import { Dirent } from 'fs';
import fs from 'fs/promises';

let mockProcessCwdResult: string = '';
jest.mock('process', () => ({
  cwd: jest.fn().mockImplementation(() => mockProcessCwdResult),
}));

let mockFsStatFileResult: { [key: string]: boolean };
let mockFsReadFileResults: { [key: string]: string };
let mockFsWriteFileArgs: [string, string] = ['', ''];
let mockFsReadDirentResults: {
  [key: string]: Pick<Dirent, 'name' | 'isDirectory'>[];
};

jest.mock('fs/promises', () => ({
  readFile: jest.fn().mockImplementation(async (fileName) => {
    if (mockFsReadFileResults[fileName]) {
      return mockFsReadFileResults[fileName];
    }
    throw new Error(`${fileName} isn't mocked correctly`);
  }),
  writeFile: jest.fn().mockImplementation((...args) => {
    mockFsWriteFileArgs = args;
  }),
  stat: jest.fn().mockImplementation((fileName) => {
    if (mockFsStatFileResult[fileName]) {
      return {};
    }
    throw new Error();
  }),
  readdir: jest.fn().mockImplementation((dir) => {
    if (mockFsReadDirentResults[dir]) {
      return mockFsReadDirentResults[dir];
    }
    throw new Error(`${dir} isn't mocked correctly`);
  }),
}));

describe('verify behaviour of dynamic type generation for feature flags', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should generate "never" if no feature flags found', async () => {
    mockProcessCwdResult = '';
    mockFsStatFileResult = { 'package.json': true };
    mockFsReadFileResults = { 'package.json': '{}' };
    mockFsReadDirentResults = {
      '.': [{ name: 'package.json', isDirectory: () => false }],
    };
    await generateTypes();
    expect(mockFsWriteFileArgs[1]).toMatchInlineSnapshot(`
      "/** AUTOGENERATED DO NOT EDIT **/

      export type BooleanFeatureFlagType = never;
      "
    `);
  });

  it('should generate valid type if platform-feature-flags key exists found', async () => {
    mockProcessCwdResult = '';
    mockFsStatFileResult = { 'package.json': true };
    mockFsReadFileResults = {
      'package.json':
        '{"platform-feature-flags": {"test-flag": {"type": "boolean" } } }',
    };
    mockFsReadDirentResults = {
      '.': [{ name: 'package.json', isDirectory: () => false }],
    };
    await generateTypes();
    expect(mockFsWriteFileArgs[1]).toMatchInlineSnapshot(`
      "/** AUTOGENERATED DO NOT EDIT **/

      export type BooleanFeatureFlagType = \\"test-flag\\";
      "
    `);
  });

  it('should generate valid type if multiple feature flags found', async () => {
    mockProcessCwdResult = '';
    mockFsStatFileResult = {
      'package-1/package.json': true,
      'package-2/package.json': true,
    };
    mockFsReadDirentResults = {
      '.': [
        { name: 'package.json', isDirectory: () => false },
        { name: 'package-1', isDirectory: () => true },
        { name: 'package-2', isDirectory: () => true },
      ],
      'package-1': [{ name: 'package.json', isDirectory: () => false }],
      'package-2': [{ name: 'package.json', isDirectory: () => false }],
    };
    mockFsReadFileResults = {
      'package.json': '{}',

      'package-1/package.json':
        '{"platform-feature-flags": {"package-1-flag": {"type": "boolean" } } }',
      'package-2/package.json':
        '{"platform-feature-flags": {"package-2-flag": {"type": "boolean" } } }',
    };
    await generateTypes();
    expect(mockFsWriteFileArgs[1]).toMatchInlineSnapshot(`
      "/** AUTOGENERATED DO NOT EDIT **/

      export type BooleanFeatureFlagType = \\"package-1-flag\\" | \\"package-2-flag\\";
      "
    `);
  });

  it('should throw error when merging flags declared as different types', async () => {
    mockProcessCwdResult = '';
    mockFsStatFileResult = {
      'package-1/package.json': true,
      'package-2/package.json': true,
    };
    mockFsReadDirentResults = {
      '.': [
        { name: 'package.json', isDirectory: () => false },
        { name: 'package-1', isDirectory: () => true },
        { name: 'package-2', isDirectory: () => true },
      ],
      'package-1': [{ name: 'package.json', isDirectory: () => false }],
      'package-2': [{ name: 'package.json', isDirectory: () => false }],
    };
    mockFsReadFileResults = {
      'package.json': '{}',

      'package-1/package.json':
        '{"platform-feature-flags": {"test-flag": {"type": "boolean" } } }',
      'package-2/package.json':
        '{"platform-feature-flags": {"test-flag": {"type": "string" } } }',
    };

    await expect(generateTypes()).rejects.toMatchInlineSnapshot(
      '[Error: feature flag test-flag has conflicting registration types!]',
    );
  });

  it('should throw error when declaring invalid type', async () => {
    mockProcessCwdResult = '';
    mockFsStatFileResult = { 'package-1/package.json': true };
    mockFsReadDirentResults = {
      '.': [
        { name: 'package.json', isDirectory: () => false },
        { name: 'package-1', isDirectory: () => true },
      ],
      'package-1': [{ name: 'package.json', isDirectory: () => false }],
    };
    mockFsReadFileResults = {
      'package.json': '{}',

      'package-1/package.json':
        '{"platform-feature-flags": {"test-flag": {"type": "string" } } }',
    };

    await expect(generateTypes()).rejects.toMatchInlineSnapshot(
      '[Error: invalid type for feature flag: string]',
    );
  });

  it("should return highest ancestor package.json even if it isn't a monorepo", async () => {
    mockProcessCwdResult = 'test/1/2/3/4';
    mockFsReadDirentResults = {
      test: [
        { name: 'package.json', isDirectory: () => false },
        { name: 'package-1', isDirectory: () => true },
      ],
      'test/package-1': [{ name: 'package.json', isDirectory: () => false }],
    };
    mockFsReadFileResults = {
      'test/package.json': '{}',

      'test/package-1/package.json':
        '{"platform-feature-flags": {"test-flag": {"type": "boolean" } } }',
    };

    mockFsReadFileResults = {
      'test/package.json': '{}',
      'test/package-1/package.json':
        '{"platform-feature-flags": {"test-flag": {"type": "boolean" } } }',
    };

    await generateTypes();

    // fs.readdir only called from method that gets all package.json, there isn't one at the root so it should
    // only get package.json at 'test' and below
    expect(fs.readdir).toHaveBeenCalledWith('test', { withFileTypes: true });
    expect(fs.readdir).not.toHaveBeenCalledWith('.', { withFileTypes: true });
  });
});

export {};
