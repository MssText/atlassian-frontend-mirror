import { main as generateTypes } from './generate-types';
import fastglob from 'fast-glob';

let mockFastglobResult: string[] = [];
jest.mock('fast-glob', () =>
  jest.fn().mockImplementation(async () => mockFastglobResult),
);

let mockProcessCwdResult: string = '';
jest.mock('process', () => ({
  cwd: jest.fn().mockImplementation(() => mockProcessCwdResult),
}));

let mockFsReadFileResults: { [key: string]: string };
let mockFsWriteFileArgs: [string, string] = ['', ''];

jest.mock('fs/promises', () => ({
  readFile: jest.fn().mockImplementation(async (fileName) => {
    if (mockFsReadFileResults[fileName]) {
      return mockFsReadFileResults[fileName];
    }
    throw new Error();
  }),
  writeFile: jest.fn().mockImplementation((...args) => {
    mockFsWriteFileArgs = args;
  }),
}));

jest.mock('fast-glob', () => jest.fn().mockResolvedValue(mockFastglobResult));

describe('verify behaviour of dynamic type generation for feature flags', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should generate "never" if no feature flags found', async () => {
    mockProcessCwdResult = '';
    mockFastglobResult = ['package.json'];
    mockFsReadFileResults = { 'package.json': '{}' };
    await generateTypes();
    expect(mockFsWriteFileArgs[1]).toMatchInlineSnapshot(`
      "/** AUTOGENERATED DO NOT EDIT **/

      export type BooleanFeatureFlagType = never;
      "
    `);
  });

  it('should generate valid type if platform-feature-flags key exists found', async () => {
    mockProcessCwdResult = '';
    mockFastglobResult = ['package.json'];
    mockFsReadFileResults = {
      'package.json':
        '{"platform-feature-flags": {"test-flag": {"type": "boolean" } } }',
    };
    await generateTypes();
    expect(mockFsWriteFileArgs[1]).toMatchInlineSnapshot(`
      "/** AUTOGENERATED DO NOT EDIT **/

      export type BooleanFeatureFlagType = \\"test-flag\\";
      "
    `);
  });

  it('should generate valid type if multiple feature flags found', async () => {
    mockProcessCwdResult = '';
    mockFastglobResult = ['package-1/package.json', 'package-2/package.json'];
    mockFsReadFileResults = {
      'package.json': '{}',

      'package-1/package.json':
        '{"platform-feature-flags": {"package-1-flag": {"type": "boolean" } } }',
      'package-2/package.json':
        '{"platform-feature-flags": {"package-2-flag": {"type": "boolean" } } }',
    };
    await generateTypes();
    expect(mockFsWriteFileArgs[1]).toMatchInlineSnapshot(`
      "/** AUTOGENERATED DO NOT EDIT **/

      export type BooleanFeatureFlagType = \\"package-1-flag\\" | \\"package-2-flag\\";
      "
    `);
  });

  it('should generate valid type if multiple feature flags found', async () => {
    mockProcessCwdResult = '';
    mockFastglobResult = ['package-1/package.json', 'package-2/package.json'];
    mockFsReadFileResults = {
      'package.json': '{}',
      'package-1/package.json':
        '{"platform-feature-flags": {"package-1-flag": {"type": "boolean" } } }',
      'package-2/package.json':
        '{"platform-feature-flags": {"package-2-flag": {"type": "boolean" } } }',
    };
    await generateTypes();
    expect(mockFsWriteFileArgs[1]).toMatchInlineSnapshot(`
      "/** AUTOGENERATED DO NOT EDIT **/

      export type BooleanFeatureFlagType = \\"package-1-flag\\" | \\"package-2-flag\\";
      "
    `);
  });

  it('should throw error when merging flags declared as different types', async () => {
    mockProcessCwdResult = '';
    mockFastglobResult = ['package-1/package.json', 'package-2/package.json'];
    mockFsReadFileResults = {
      'package.json': '{}',

      'package-1/package.json':
        '{"platform-feature-flags": {"test-flag": {"type": "boolean" } } }',
      'package-2/package.json':
        '{"platform-feature-flags": {"test-flag": {"type": "string" } } }',
    };

    await expect(generateTypes()).rejects.toMatchInlineSnapshot(
      '[Error: feature flag test-flag has conflicting registration types!]',
    );
  });

  it('should throw error when declaring invalid type', async () => {
    mockProcessCwdResult = '';
    mockFastglobResult = ['package-1/package.json'];
    mockFsReadFileResults = {
      'package.json': '{}',
      'package-1/package.json':
        '{"platform-feature-flags": {"test-flag": {"type": "string" } } }',
    };

    await expect(generateTypes()).rejects.toMatchInlineSnapshot(
      '[Error: invalid type for feature flag: string]',
    );
  });

  it("should return highest ancestor package.json even if it isn't a monorepo", async () => {
    mockProcessCwdResult = 'test/1/2/3/4';
    mockFastglobResult = ['test/package.json', 'test/package-1/package.json'];
    mockFsReadFileResults = {
      'test/package.json': '{}',
      'test/package-1/package.json':
        '{"platform-feature-flags": {"test-flag": {"type": "boolean" } } }',
    };

    await generateTypes();
    expect(fastglob).toHaveBeenCalledTimes(1);
    expect(fastglob).toHaveBeenCalledWith(
      ['**/package.json'],
      expect.objectContaining({
        cwd: 'test',
      }),
    );
  });
});
export {};
