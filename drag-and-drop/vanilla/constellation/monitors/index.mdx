---
title: Monitors
description: A monitor can listen to all events for a particular entity type
---

A _monitor_ can listen for all events for a particular entity type (eg files). A _adapter_ will provide a monitor for an entity type.

```ts
import { monitorForElements } from '@atlaskit/drag-and-drop/adapter/element';
import { monitorForFiles } from '@atlaskit/drag-and-drop/adapter/file';

// listen for all drag events for elements
monitorForElements({
  onDragStart: () =>
    console.log('I am called whenever any `draggable` element starts dragging'),
});

// listen for all drag events for files
monitorForElements({
  onDragStart: () => console.log('I am called whenever any file drag starts'),
});
```

## Event ordering

Event listeners created with _monitors_ are called after local event listeners are finished, even if a _monitor_ happens to be created along side local event listeners

```ts
const unbind = combine(
  monitorForElements({
    onDragStart: () => 'monitor:start',
  }),
  draggable({
    element: myElement,
    onDragStart: () => 'draggable:start',
  }),
  dropTargetForElements({
    element: myElement,
    onDragStart: () => 'dropTarget:start',
  }),
);

// console.log:
// - 'draggable:start'
// - 'dropTarget:start',
// - 'monitor:start',
```

_monitors_ are called in the same order in which they are created. Over time it can be hard to reason about what this ordering is as a consumer as you might be creating / destroying monitors frequently. So it is safe to expect that "monitors are called last", but you need to be careful if you want to rely on any ordering relationships between _monitors_

```tsx
function App() {
  useEffect(() => {
    const cleanup = monitorForElements({
      onDragStart: () => 'This monitor gets created on each render!',
    });
    return cleanup;
  });

  return null;
}
```

[â†’ More information on event ordering](/components/drag-and-drop/packages/vanilla/events)

## Uniqueness

Each call to create a monitor will create a new monitor, even if the monitor definition is shared

```ts
import { monitorForElements } from '@atlaskit/drag-and-drop/adapter/element';

const args = {
  onGenerateDragPreview: () => console.log('monitor:preview'),
};

// these two monitors are sharing the same `args` reference
// but they will both create an independent monitor
const cleanup1 = monitorForElements(args);
const cleanup2 = monitorForElements(args);

// â†’ A drag starts

// console.log:
// - 'monitor:preview'
// - 'monitor:preview'

// â†’ A drag finishes

// removing one monitor
cleanup1();

// â†’ Another drag starts
// console.log:
// - 'monitor:preview'
// ðŸ‘† one monitor is still active
```

## Conditional monitoring

A _monitor_ can be conditionally activated for a drag operation by using the `canMonitor()` function.

- `canMonitor?: (args: MonitorGetFeedbackArgs<DragType>) => boolean`

```ts
type MonitorGetFeedbackArgs = {
  /**
   * The users initial drag location
   */
  initial: DragLocation;
  /**
   * The data associated with the entity being dragged
   */
  source: DragType['payload'];
};
```

```ts
monitorForElements({
  canMonitor: ({ source }) => source.data.type === 'card',
  onDragStart: () =>
    console.log('I will only be activated when dragging a card!'),
});
```

`canMonitor()` is only called once for a monitor during a drag operation as the drag is starting. If a _monitor_ is added during an active drag, then `canMonitor()` will be called as it is created with the _intial_ drag source value and initial drag location. All monitors are called with the same `MonitorGetFeedbackArgs` value during the same drag operation. We wanted to make this behvaiour clear as the `source` value can change for external drag types in the `"onDrop"` event (eg files).

If you want to do more complicated checks, you can do those inside of your _monitor_ event listeners:

```ts
monitorForElements({
  // filtering will opt the monitor into the whole drag operation
  canMonitor: ({ source }) => source.data.type === 'card',
  onDrag: ({ location }) => {
    // Additional action filtering based on changes during the drag
    if (location.current.data.action === 'delete') {
      console.log('about to delete');
    }
  },
});
```
